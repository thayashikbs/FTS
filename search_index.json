[["index.html", "金融時系列解析 1 はじめに 1.1 時系列モデリング 1.2 金融時系列データの特徴 1.3 シミュレーションによるサンプルパス生成 1.4 Rにおける時系列オブジェクト・クラスおよび関数の例 1.5 時系列データの分解", " 金融時系列解析 林 高樹 2024-03-19 (内容は随時更新します) 1 はじめに 1.1 時系列モデリング ターゲットの時系列データの特徴を表現できるような確率・統計モデルの構築 “stylized facts”等の中から, 重要な特徴にフォーカスする 実際の時系列データと構築モデルの持つ特徴が類似するように 時系列プロット, 散布図, ヒストグラム, 要約統計量等に関して 理論計算やシミュレーション(パスの生成) 金融時系列データに現れる特徴は, データ期間 (例, コロナ禍以前・以後) の他, データの観測頻度 (例, 月次, 週次, 日次, 5分次) にも依存 構築される時系列モデルに望まれる性質 (要件) 記述性 (ターゲットの時系列データとの特徴の類似性の表現) 解析容易性, 解釈可能性 操作性・取扱容易性 推定容易性, 計算効率性 モデル安定性・頑強性 予測精度の高さなど 候補となるモデルは無数 汎用的で, 良い性質を持つモデルクラスに関する研究 時系列解析分野で中核を成すクラス → 線形+定常時系列過程 モデル選択・推定, モデルの利用 ターゲット時系列の特徴を踏まえ. 適切なモデルクラスを選択する データに対してモデルを適合し, パラメータを推定する 推定モデルの妥当性をチェック (モデル診断) 予測や制御等に利用 本授業で扱う対象・アプローチ 目的変数(観測変数)自体が時系列構造を持ち, 時系列モデルで記述されるケースに主要な関心 出発点(基本的設定): 1変量の線形・定常時系列過程 → 金融時系列データは, 線形・定常時系列過程から乖離する特徴も有する → 非線形 and/or 非定常な時系列過程へ 観測変数が多次元で時系列構造を持つケース (多変量時系列) 外部変数のあるケース 金融時系列解析におけるチャレンジ 時系列データは, 確率過程の観点からは, 一本の”サンプルパス”の実現と見なせる マクロ・ミクロの状態が 時間と共に変化する金融・経済時系列データは, 再現性の乏しいデータであると考えられる さらに, 金融市場は過去に実現したデータに基づいて市場参加者が行動を変化させる ある種の”法則性”を仮定しモデルにより表現することで, 金融市場においても”最適な”行動を取りたい 1.2 金融時系列データの特徴 金融時系列データの特徴: みずほ (8411) 株価データの例 quantmod()による株価データの取得 library(&#39;quantmod&#39;) YJ8411.T &lt;- getSymbols(&#39;8411.T&#39;,from = &#39;2020-10-01&#39;, to = &#39;2023-09-29&#39;, src = &quot;yahoo&quot;, auto.assign = FALSE) # 日次株価の時系列プロット chartSeries(YJ8411.T) Figure 1.1: … # 日次4本値 chartSeries(OHLC(YJ8411.T)) Figure 1.2: … 日次収益率の時系列プロット # 日次収益率の時系列プロット ret_YJ8411 &lt;- ClCl(YJ8411.T) chartSeries(ret_YJ8411) 日次収益率のヒストグラム # 日次収益率のヒストグラム hist(ret_YJ8411) 日次収益率の要約統計量 library(psych) describe(ret_YJ8411) #&gt; vars n mean sd median trimmed mad min max range skew kurtosis se #&gt; X1 1 734 0 0.01 0 0 0.01 -0.07 0.05 0.13 -0.12 1.86 0 # 要約統計量を計算 # デフォルト出力 # mean # standard deviation # trimmed mean (with trim defaulting to .1) # median (standard or interpolated # mad: median absolute deviation (from the median). # minimum # maximum # skew # kurtosis # standard error # 注) kurtosisは-3した値 日次収益率の自己相関 # 日次収益率の自己相関 acf(ret_YJ8411, na.action = na.pass) 日次収益率絶対値の自己相関 # 日次収益率絶対値の自己相関 acf(abs(ret_YJ8411), na.action = na.pass) 1.3 シミュレーションによるサンプルパス生成 時系列モデリングでは, 観測時系列データの特徴と比較し, 適切なモデルを見い出すため, シミュレーションを積極的に利用する 正規AR(1)モデルの例: \\(X(t)=\\phi X(t-1) + W(t)\\), \\(W(t) \\sim_{i,i.d.} N(0,\\sigma^2)\\) x.ts = NULL; Tlen = 50 phi = -0.8; s = 2 for (seed.tmp in 1:5){ set.seed(seed.tmp) x = w = rnorm(Tlen) * s for (t in 2:Tlen) x[t] = phi * x[t-1] + w[t] # x.ts = ts.intersect(x.ts, ts(cumsum(x))) } ts.plot(x.ts, type=&quot;l&quot;, col=1:5, lty=1:5, ylab=&quot;&quot;,main=&quot;Simulated sample paths&quot;) 1.4 Rにおける時系列オブジェクト・クラスおよび関数の例 1.4.1 日付・時間データに対するクラス 1.4.1.1 Dateクラス 日付を表現する R内部的には, “Date”というclass属性を持つdouble型の値を持つ # as.Date(): 日付を表す文字列をDate型に変更する tomorrow &lt;- as.Date(&quot;2023-10-04&quot;) tomorrow ## [1] &quot;2023-10-04&quot; attributes(tomorrow) # 出力オブジェクトの属性(attribute) ## $class ## [1] &quot;Date&quot; # typeof(tomorrow) # 出力オブジェクトの型(type) # typeof(&quot;2023-10-23&quot;) # 入力オブジェクトの型(type) today &lt;- Sys.Date() today ## [1] &quot;2024-03-19&quot; 1.4.1.2 POSIXctクラス 日時 (日-時間) を表現する Rの内部的には, “POSIXct”というclass属性を持つdouble型の値を持つ POSIX = Portable Operating System Interfaceの略 POSIXct, POSXltの2種類: ct = calender time, lt = local time now_ct &lt;- as.POSIXct(&quot;2023-10-05 19:00&quot;, tz = &quot;UTC&quot;) now_ct ## [1] &quot;2023-10-05 19:00:00 UTC&quot; attributes(now_ct) ## $class ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; ## ## $tzone ## [1] &quot;UTC&quot; tomorrow_ct &lt;- as.POSIXct(&quot;2023-10-06 20:00&quot;, tz = &quot;UTC&quot;) tomorrow_ct - now_ct # 時間差(1日当たり) ## Time difference of 1.041667 days attributes(tomorrow_ct - now_ct) ## $class ## [1] &quot;difftime&quot; ## ## $units ## [1] &quot;days&quot; 1.4.1.3 difftimeクラス 時間差を表現する Rの内部的には, “POSIXct”というclass属性を持つdouble型の値を持つ onewk_1 &lt;- as.difftime(1, units = &quot;weeks&quot;) onewk_1 ## Time difference of 1 weeks typeof(onewk_1) ## [1] &quot;double&quot; attributes(onewk_1) ## $class ## [1] &quot;difftime&quot; ## ## $units ## [1] &quot;weeks&quot; onewk_2 &lt;- as.difftime(7, units = &quot;days&quot;) onewk_2 ## Time difference of 7 days 1.4.1.4 よりモダンかつ柔軟な日付や時間の操作 lubridateパッケージ hmsパッケージ (日内時間の操作・蓄積に特化) 1.4.2 時系列データに対するクラス(1): tsクラス tsクラス: Rの時系列オブジェクトの基本クラス # AirPassengers, # Pan Am, # international passenger bokking (in 1000s) per month # 1949--1960 (Brown, 1963) data(AirPassengers) ap &lt;- AirPassengers ap ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1949 112 118 132 129 121 135 148 148 136 119 104 118 ## 1950 115 126 141 135 125 149 170 170 158 133 114 140 ## 1951 145 150 178 163 172 178 199 199 184 162 146 166 ## 1952 171 180 193 181 183 218 230 242 209 191 172 194 ## 1953 196 196 236 235 229 243 264 272 237 211 180 201 ## 1954 204 188 235 227 234 264 302 293 259 229 203 229 ## 1955 242 233 267 269 270 315 364 347 312 274 237 278 ## 1956 284 277 317 313 318 374 413 405 355 306 271 306 ## 1957 315 301 356 348 355 422 465 467 404 347 305 336 ## 1958 340 318 362 348 363 435 491 505 404 359 310 337 ## 1959 360 342 406 396 420 472 548 559 463 407 362 405 ## 1960 417 391 419 461 472 535 622 606 508 461 390 432 #is.ts(ap); is.vector(ap) #attributes(ap) class(ap) # tsクラス ## [1] &quot;ts&quot; start(ap); end(ap); frequency(ap) ## [1] 1949 1 ## [1] 1960 12 ## [1] 12 plot(ap, ylab = &quot;Passengers (1000&#39;s)&quot;) layout(1:2) plot(aggregate(ap)) # annual levelに累計, seasonal effectsの除去、trend cycle(ap) # データ内各アイテムのシーズン抽出 ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1949 1 2 3 4 5 6 7 8 9 10 11 12 ## 1950 1 2 3 4 5 6 7 8 9 10 11 12 ## 1951 1 2 3 4 5 6 7 8 9 10 11 12 ## 1952 1 2 3 4 5 6 7 8 9 10 11 12 ## 1953 1 2 3 4 5 6 7 8 9 10 11 12 ## 1954 1 2 3 4 5 6 7 8 9 10 11 12 ## 1955 1 2 3 4 5 6 7 8 9 10 11 12 ## 1956 1 2 3 4 5 6 7 8 9 10 11 12 ## 1957 1 2 3 4 5 6 7 8 9 10 11 12 ## 1958 1 2 3 4 5 6 7 8 9 10 11 12 ## 1959 1 2 3 4 5 6 7 8 9 10 11 12 ## 1960 1 2 3 4 5 6 7 8 9 10 11 12 boxplot(ap ~ cycle(ap)) # seasonal effects 1.4.3 時系列データに対するクラス(2): zooクラスとxtsクラス 有用な時系列オブジェクトのクラス: zoo, xts zoo, xts共に, 多変量時系列を扱うことも可能 xtsは, zooに類似. かつ, 高速なため, 大規模DATAの処理に適している zooやxtsのメリット. 有用な関数が多数用意されている: differencing, merging, periodic sampling, applying rolling functions xtsパッケージは, zooパッケージが出来ること全てできる - zooクラス・オブジェクトの生成 - ts &lt;- zoo(x, dt) - 時間(index)は, Dateオブジェクト, POSIXctオブジェクト, 整数, 浮動小数点でも, 順序付き数値なら何でもOK - xtsクラス・オブジェクトの生成 - ts &lt;- xts(x, dt) - 時間(index)は, Dateオブジェクト, POSIXctオブジェクト等、日付や時間のクラスのみに対応 # R マニュアル vignette(&quot;zoo&quot;) vignette(&quot;xts&quot;) zooクラス library(zoo) # 日経平均先物(ラージ), 2018年2月5日, 1日内約定データ prices &lt;- c(22790, 22800, 22790, 22790, 22790) seconds &lt;- c(32400.014, 32400.020, 32400.035, 32400.036) # タイムスタンプ (秒) nkft_sec &lt;- zoo(prices, seconds) print(nkft_sec) ## 32400.014 32400.02 32400.035 32400.036 ## 22790 22800 22790 22790 # 同, 2023年9月25日〜9月29日(5営業日) prices &lt;- c(32480, 32080, 32150, 31850, 32020) dates &lt;- as.Date(c(&quot;2023-09-25&quot;, &quot;2023-09-26&quot;, &quot;2023-09-27&quot;, &quot;2023-09-28&quot;, &quot;2023-09-29&quot;)) # 日付 nkft_daily &lt;- zoo(prices, dates) print(nkft_daily) ## 2023-09-25 2023-09-26 2023-09-27 2023-09-28 2023-09-29 ## 32480 32080 32150 31850 32020 coredata(nkft_daily) # 株価の取り出し ## [1] 32480 32080 32150 31850 32020 index(nkft_daily) # 時間の取り出し ## [1] &quot;2023-09-25&quot; &quot;2023-09-26&quot; &quot;2023-09-27&quot; &quot;2023-09-28&quot; &quot;2023-09-29&quot; coredata(nkft_sec) ## [1] 22790 22800 22790 22790 index(nkft_sec) ## [1] 32400.01 32400.02 32400.03 32400.04 nkft_daily[2:4] ## 2023-09-26 2023-09-27 2023-09-28 ## 32080 32150 31850 nkft_daily[as.Date(&quot;2023-09-26&quot;)] ## 2023-09-26 ## 32080 nkft_daily[&quot;2023-09-26&quot;] # &lt;-- NO ## 2023-09-26 ## 32080 window(nkft_daily, start = as.Date(&#39;2023-09-26&#39;), end = as.Date(&#39;2023-09-28&#39;)) ## 2023-09-26 2023-09-27 2023-09-28 ## 32080 32150 31850 library(xts) first(nkft_sec) # 最初のデータ ## 32400.014 ## 22790 last(nkft_sec) # 最後のデータ ## 32400.036 ## 22790 1.4.3.1 quantmodパッケージの利用による株価取得 &amp; チャート作成 library(&#39;quantmod&#39;) yj8411 &lt;- getSymbols(&#39;8411.T&#39;,from = &#39;2020-10-01&#39;, to = &#39;2023-09-29&#39;, src = &quot;yahoo&quot;, auto.assign = FALSE) # 注) R/RStudioや, guantmodのバージョンによっては, 動かないことがある # 注) 画面に&quot;Error in new.session() : Could not establish session after 5 attempts.&quot;が表示され, # 株価を取得できない場合には, quantmodのバージョンを最新のものにすること. chartSeries(ClCl(yj8411)) chartSeries(yj8411) chartSeries(OHLC(yj8411)) Mizuho_ret &lt;- diff(log(Ad(yj8411))) # Adjusted price plot(Mizuho_ret) chartSeries(Mizuho_ret) class(Mizuho_ret) ## [1] &quot;xts&quot; &quot;zoo&quot; # 便利な関数の例 Mizuho_m &lt;- apply.monthly(Mizuho_ret, mean, na.rm = T) # xts Mizuho_w &lt;- apply.weekly(Mizuho_ret, mean, na.rm = T) # xts # zooオブジェクトの場合, 一旦xtsに変換して適用 # apply.monthly(as.xts(ts), df) Mizuho_ma5 &lt;- rollapply(Mizuho_ret, width = 5, mean, align = &quot;right&quot;) # zooパッケージ内 head(Mizuho_ma5) ## 8411.T.Adjusted ## 2020-10-02 NA ## 2020-10-05 NA ## 2020-10-06 NA ## 2020-10-07 NA ## 2020-10-08 NA ## 2020-10-09 0.002418767 #Mizuho_ma21 &lt;- rollapply(Mizuho_ret, width = 21, mean, align = &quot;right&quot;) # zooパッケージ内 # timestamp is taken from the rightmost value chartSeries(Mizuho_ma5) #chartSeries(Mizuho_ma21) 1.5 時系列データの分解 - データセット: AirPassengers - Pan Am, # international passenger bokking (in 1000s) per month - 1949--1960 (Brown, 1963) data(AirPassengers) ap &lt;- AirPassengers ap ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1949 112 118 132 129 121 135 148 148 136 119 104 118 ## 1950 115 126 141 135 125 149 170 170 158 133 114 140 ## 1951 145 150 178 163 172 178 199 199 184 162 146 166 ## 1952 171 180 193 181 183 218 230 242 209 191 172 194 ## 1953 196 196 236 235 229 243 264 272 237 211 180 201 ## 1954 204 188 235 227 234 264 302 293 259 229 203 229 ## 1955 242 233 267 269 270 315 364 347 312 274 237 278 ## 1956 284 277 317 313 318 374 413 405 355 306 271 306 ## 1957 315 301 356 348 355 422 465 467 404 347 305 336 ## 1958 340 318 362 348 363 435 491 505 404 359 310 337 ## 1959 360 342 406 396 420 472 548 559 463 407 362 405 ## 1960 417 391 419 461 472 535 622 606 508 461 390 432 #is.ts(ap); is.vector(ap) #attributes(ap) class(ap) # tsクラス ## [1] &quot;ts&quot; start(ap); end(ap); frequency(ap) ## [1] 1949 1 ## [1] 1960 12 ## [1] 12 plot(ap, ylab = &quot;Passengers (1000&#39;s)&quot;) layout(1:2) plot(aggregate(ap)) # annual levelに累計, seasonal effectsの除去、trend cycle(ap) # データ内各アイテムのシーズン抽出 ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1949 1 2 3 4 5 6 7 8 9 10 11 12 ## 1950 1 2 3 4 5 6 7 8 9 10 11 12 ## 1951 1 2 3 4 5 6 7 8 9 10 11 12 ## 1952 1 2 3 4 5 6 7 8 9 10 11 12 ## 1953 1 2 3 4 5 6 7 8 9 10 11 12 ## 1954 1 2 3 4 5 6 7 8 9 10 11 12 ## 1955 1 2 3 4 5 6 7 8 9 10 11 12 ## 1956 1 2 3 4 5 6 7 8 9 10 11 12 ## 1957 1 2 3 4 5 6 7 8 9 10 11 12 ## 1958 1 2 3 4 5 6 7 8 9 10 11 12 ## 1959 1 2 3 4 5 6 7 8 9 10 11 12 ## 1960 1 2 3 4 5 6 7 8 9 10 11 12 boxplot(ap ~ cycle(ap)) # seasonal effects 1.5.1 トレンド抽出, 平滑化(smoothing) 対称移動平均法(centered moving average) # filter()関数の使用 f12 &lt;- c(1/24, rep(1/12, 11), 1/24) f12 ## [1] 0.04166667 0.08333333 0.08333333 0.08333333 0.08333333 0.08333333 ## [7] 0.08333333 0.08333333 0.08333333 0.08333333 0.08333333 0.08333333 ## [13] 0.04166667 ap_m &lt;- stats::filter(as.vector(ap), f12, sides = 2) # vectorとして入力 --&gt; 年情報が欠落 plot(cbind(as.vector(ap), ap_m)) # --&gt; 年情報が欠落 #ap_m2 &lt;- filter(ap, f12, sides = 2) # tsとして入力 #plot(cbind(ap, ap_m2)) #または ap_m &lt;- ts(ap_m, start = c(1949,1), frequency = 12) # &lt;-- 年情報を戻す #plot(cbind(ap, ap_m)) #grid() #lines(1:length(ap_m), ap_m, col=&quot;blue&quot;) # トレンド除去済データ ap_s &lt;- ap - ap_m # 上のts()を使った式によるap_mの生成が必要 plot(ap_s) 1.5.2 時系列の分解 1.5.2.1 “古典的”方法 - decompose, &quot;古典的&quot;分解モデル (Rのデフォルト) - The function first determines the trend component using a moving average (if filter is NULL, a symmetric window with equal weights is used), and removes it from the time series. Then, the seasonal figure is computed by averaging, for each time unit, over all periods. The seasonal figure is then centered. Finally, the error component is determined by removing trend and seasonal figure (recycled as needed) from the original time series. decompose(ap) ## $x ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1949 112 118 132 129 121 135 148 148 136 119 104 118 ## 1950 115 126 141 135 125 149 170 170 158 133 114 140 ## 1951 145 150 178 163 172 178 199 199 184 162 146 166 ## 1952 171 180 193 181 183 218 230 242 209 191 172 194 ## 1953 196 196 236 235 229 243 264 272 237 211 180 201 ## 1954 204 188 235 227 234 264 302 293 259 229 203 229 ## 1955 242 233 267 269 270 315 364 347 312 274 237 278 ## 1956 284 277 317 313 318 374 413 405 355 306 271 306 ## 1957 315 301 356 348 355 422 465 467 404 347 305 336 ## 1958 340 318 362 348 363 435 491 505 404 359 310 337 ## 1959 360 342 406 396 420 472 548 559 463 407 362 405 ## 1960 417 391 419 461 472 535 622 606 508 461 390 432 ## ## $seasonal ## Jan Feb Mar Apr May Jun ## 1949 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1950 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1951 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1952 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1953 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1954 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1955 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1956 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1957 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1958 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1959 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## 1960 -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## Jul Aug Sep Oct Nov Dec ## 1949 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1950 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1951 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1952 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1953 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1954 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1955 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1956 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1957 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1958 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1959 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## 1960 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## ## $trend ## Jan Feb Mar Apr May Jun Jul Aug ## 1949 NA NA NA NA NA NA 126.7917 127.2500 ## 1950 131.2500 133.0833 134.9167 136.4167 137.4167 138.7500 140.9167 143.1667 ## 1951 157.1250 159.5417 161.8333 164.1250 166.6667 169.0833 171.2500 173.5833 ## 1952 183.1250 186.2083 189.0417 191.2917 193.5833 195.8333 198.0417 199.7500 ## 1953 215.8333 218.5000 220.9167 222.9167 224.0833 224.7083 225.3333 225.3333 ## 1954 228.0000 230.4583 232.2500 233.9167 235.6250 237.7500 240.5000 243.9583 ## 1955 261.8333 266.6667 271.1250 275.2083 278.5000 281.9583 285.7500 289.3333 ## 1956 309.9583 314.4167 318.6250 321.7500 324.5000 327.0833 329.5417 331.8333 ## 1957 348.2500 353.0000 357.6250 361.3750 364.5000 367.1667 369.4583 371.2083 ## 1958 375.2500 377.9167 379.5000 380.0000 380.7083 380.9583 381.8333 383.6667 ## 1959 402.5417 407.1667 411.8750 416.3333 420.5000 425.5000 430.7083 435.1250 ## 1960 456.3333 461.3750 465.2083 469.3333 472.7500 475.0417 NA NA ## Sep Oct Nov Dec ## 1949 127.9583 128.5833 129.0000 129.7500 ## 1950 145.7083 148.4167 151.5417 154.7083 ## 1951 175.4583 176.8333 178.0417 180.1667 ## 1952 202.2083 206.2500 210.4167 213.3750 ## 1953 224.9583 224.5833 224.4583 225.5417 ## 1954 247.1667 250.2500 253.5000 257.1250 ## 1955 293.2500 297.1667 301.0000 305.4583 ## 1956 334.4583 337.5417 340.5417 344.0833 ## 1957 372.1667 372.4167 372.7500 373.6250 ## 1958 386.5000 390.3333 394.7083 398.6250 ## 1959 437.7083 440.9583 445.8333 450.6250 ## 1960 NA NA NA NA ## ## $random ## Jan Feb Mar Apr May Jun ## 1949 NA NA NA NA NA NA ## 1950 8.4987374 29.1047980 8.3244949 6.6199495 -7.9103535 -25.1527778 ## 1951 12.6237374 26.6464646 18.4078283 6.9116162 9.8396465 -26.4861111 ## 1952 12.6237374 29.9797980 6.1994949 -2.2550505 -6.0770202 -13.2361111 ## 1953 4.9154040 13.6881313 17.3244949 20.1199495 9.4229798 -17.1111111 ## 1954 0.7487374 -6.2702020 4.9911616 1.1199495 2.8813131 -9.1527778 ## 1955 4.9154040 2.5214646 -1.8838384 1.8282828 -3.9936869 -2.3611111 ## 1956 -1.2095960 -1.2285354 0.6161616 -0.7133838 -1.9936869 11.5138889 ## 1957 -8.5012626 -15.8118687 0.6161616 -5.3383838 -4.9936869 19.4305556 ## 1958 -10.5012626 -23.7285354 -15.2588384 -23.9633838 -13.2020202 18.6388889 ## 1959 -17.7929293 -28.9785354 -3.6338384 -12.2967172 4.0063131 11.0972222 ## 1960 -14.5845960 -34.1868687 -43.9671717 -0.2967172 3.7563131 24.5555556 ## Jul Aug Sep Oct Nov Dec ## 1949 -42.6224747 -42.0732323 -8.4785354 11.0593434 28.5934343 16.8699495 ## 1950 -34.7474747 -35.9898990 -4.2285354 5.2260101 16.0517677 13.9116162 ## 1951 -36.0808081 -37.4065657 -7.9785354 5.8093434 21.5517677 14.4532828 ## 1952 -31.8724747 -20.5732323 -9.7285354 5.3926768 15.1767677 9.2449495 ## 1953 -25.1641414 -16.1565657 -4.4785354 7.0593434 9.1351010 4.0782828 ## 1954 -2.3308081 -13.7815657 -4.6868687 -0.6073232 3.0934343 0.4949495 ## 1955 14.4191919 -5.1565657 2.2297980 -2.5239899 -10.4065657 1.1616162 ## 1956 19.6275253 10.3434343 4.0214646 -10.8989899 -15.9482323 -9.4633838 ## 1957 31.7108586 32.9684343 15.3131313 -4.7739899 -14.1565657 -9.0050505 ## 1958 45.3358586 58.5101010 0.9797980 -10.6906566 -31.1148990 -33.0050505 ## 1959 53.4608586 61.0517677 8.7714646 -13.3156566 -30.2398990 -17.0050505 ## 1960 NA NA NA NA NA NA ## ## $figure ## [1] -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 ## [7] 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949 ## ## $type ## [1] &quot;additive&quot; ## ## attr(,&quot;class&quot;) ## [1] &quot;decomposed.ts&quot; plot(decompose(ap)) ap_decom &lt;- decompose(ap) # additive #ap_decom &lt;- decompose(ap, type = &quot;mult&quot;) # multiplicative plot(ap_decom) Trend &lt;- ap_decom$trend Seasonal &lt;- ap_decom$seasonal ts.plot(cbind(Trend, Trend * Seasonal), lty = 1:2) # トレンド成分 vs トレンド×季節性成分 → トレンド×季節性成分が圧倒 → 季節性成分にトレンド成分混入!? 時系列を対数変換 lnap &lt;- log(ap) lnap_decom &lt;- decompose(lnap) plot(lnap_decom) Trend &lt;- lnap_decom$trend Seasonal &lt;- lnap_decom$seasonal ts.plot(cbind(Trend, Trend * Seasonal), lty = 1:2) または, オプション type=“multiplicative”を指定 ap_decom_m &lt;- decompose(ap, type = &quot;multiplicative&quot;) plot(ap_decom_m) 参考文献: CM (2009), Ch.1 (自主課題) decomposeと同じように3成分に分解する自作関数を作成せよ 1.5.2.2 代替的方法 - stl(), Seasonal Decomposition of Time Series by Loess - loess(locally weighted regression)によるsmoothingを行い, 3成分に分解 #plot(stl(ap, s.window = 13)) #plot(stl(ap, s.window = 5)) plot(stl(ap, s.window = &quot;per&quot;)) - &quot;timsac&quot;: 統数研開発パッケージ - H.Akaike, T.Ozaki, M.Ishiguro, Y.Ogata, G.Kitagawa, Y-H.Tamura, E.Arahata, K.Katsura and Y.Tamura (1984) Computer Science Monographs, Timsac-84 Part 1. The Institute of Statistical Mathematics. library(timsac) # decomp() # Decompose a nonstationary time series into several possible components by square-root filter. # トレンド成分、AR成分、季節変動成分、曜日効果、白色雑音 # データセット: Blsallfood data(Blsallfood) # アメリカの食品産業に従事する労働者の人数を毎月調べた時系列 (合衆国 Bureau of Labor Statistics (BLS) 公表) #z &lt;- decomp(Blsallfood, trade = TRUE, year = 1973) # year: the first year of the data z &lt;- decomp(Blsallfood, year = 1973) z$aic; z$lkhd ## [1] 1204.446 ## [1] -581.2231 z$sigma2; z$tau1; z$tau2; z$tau3 ## [1] 27.75967 ## [1] 0.00516679 ## [1] 0.9953483 ## [1] 0.0001000029 z &lt;- decomp(Blsallfood, trade = TRUE, year = 1973) #decomp(as.vector(ap), year = 1949) # OK? z &lt;- decomp(ap, year = 1949) - baysea() - Decompose a nonstationary time series into several possible components # データセット: LaborData data(LaborData) # Labor force U.S. unemployed 16 years or over (1972-1978) data head(LaborData) ## [1] 5447 5412 5215 4697 4344 5426 z &lt;- baysea(LaborData, forecast = 12) #baysea(as.vector(ap), forecast = 12) # OK? z &lt;- baysea(ap, forecast = 12) 1.5.2.3 代替的方法 (続き) prophet() https://facebook.github.io/prophet/docs/quick_start.html#r-api https://cran.r-project.org/web/packages/prophet/prophet.pdf “非線形のトレンドに年次・週次・日次の季節性, さらに 休日効果を加えた加法モデルに基づいて時系列データを予測する手続を実装. 強い季節性があり, 数シーズンの過去データを持つ時系列データに対して良く機能. 欠損値やトレンドのシフトに対して頑強. 通常, 外れ値をうまく処理.” prophet()の主な引数 - growth: &quot;linear&quot;(デフォルト), &quot;logisitc&quot;, &quot;flat&quot; - changepoints (変化点): 日付ベクトルをユーザー指定 or 潜在的な変化点の自動選択(デフォルト) - n.changepoints (変化点の数): 25 (デフォルト) - yearly.seasonality (年次季節性への適合): &quot;auto&quot;(デフォルト), T, F, 生成するFourier項の数 - weekly.seasonality (週次季節性への適合): 同上 - daily.seasonality (週次季節性への適合): 同上 - holidays (休日の指定): なし(デフォルト - seasonality.mode (季節性の入り方): &quot;additive&quot;(加法的)(デフォルト), &quot;multiplictive&quot;(乗法的) #install.packages(&quot;prophet&quot;) library(prophet) library(zoo) # index, yearmon # 以下, 生データのまま使用 (対数変換せず) # 年月の取り出し tt &lt;- as.Date(yearmon(index(ap))) # prophetモデルの生成 ap_df &lt;- data.frame(ds = tt, y = ap) ap_ppht &lt;- prophet(ap_df) # 予測年月の生成 dates_ft &lt;- make_future_dataframe(ap_ppht, periods = 12, freq = &quot;month&quot;) tail(dates_ft) ## ds ## 151 1961-07-01 ## 152 1961-08-01 ## 153 1961-09-01 ## 154 1961-10-01 ## 155 1961-11-01 ## 156 1961-12-01 # 予測値の生成 ap_forecast &lt;- predict(ap_ppht, dates_ft) tail(ap_forecast[c(&#39;ds&#39;, &#39;yhat&#39;, &#39;yhat_lower&#39;, &#39;yhat_upper&#39;)]) ## ds yhat yhat_lower yhat_upper ## 151 1961-07-01 576.8046 549.0403 605.3782 ## 152 1961-08-01 577.2261 549.4752 606.1975 ## 153 1961-09-01 528.6678 501.5016 557.8755 ## 154 1961-10-01 493.5023 465.1356 523.0724 ## 155 1961-11-01 459.6479 429.6407 488.7700 ## 156 1961-12-01 489.0093 458.0174 515.9366 str(ap_forecast) ## &#39;data.frame&#39;: 156 obs. of 16 variables: ## $ ds : POSIXct, format: &quot;1949-01-01&quot; &quot;1949-02-01&quot; ... ## $ trend : num 107 109 111 114 116 ... ## $ additive_terms : num -21.433 -30.103 -0.467 -4.937 -3.629 ... ## $ additive_terms_lower : num -21.433 -30.103 -0.467 -4.937 -3.629 ... ## $ additive_terms_upper : num -21.433 -30.103 -0.467 -4.937 -3.629 ... ## $ yearly : num -21.433 -30.103 -0.467 -4.937 -3.629 ... ## $ yearly_lower : num -21.433 -30.103 -0.467 -4.937 -3.629 ... ## $ yearly_upper : num -21.433 -30.103 -0.467 -4.937 -3.629 ... ## $ multiplicative_terms : num 0 0 0 0 0 0 0 0 0 0 ... ## $ multiplicative_terms_lower: num 0 0 0 0 0 0 0 0 0 0 ... ## $ multiplicative_terms_upper: num 0 0 0 0 0 0 0 0 0 0 ... ## $ yhat_lower : num 56.9 49.3 83 78.5 82.2 ... ## $ yhat_upper : num 116 108 141 136 139 ... ## $ trend_lower : num 107 109 111 114 116 ... ## $ trend_upper : num 107 109 111 114 116 ... ## $ yhat : num 85.9 79.4 110.9 108.6 112 ... plot(ap_ppht, ap_forecast) # prophetによる予測の各成分のプロット prophet_plot_components(ap_ppht, ap_forecast) "],["定常性と自己相関関数.html", "2 定常性と自己相関関数 2.1 確率過程の2次特性: 平均関数と自己共分散関数 2.2 定常性 (stationarity) 2.3 標本平均と標本自己共分散関数 2.4 標本自己相関関数 2.5 自己相関関数 (標本値 vs 理論値)", " 2 定常性と自己相関関数 2.1 確率過程の2次特性: 平均関数と自己共分散関数 \\(E[X_t]&lt;\\infty\\)である確率過程 \\(\\{X_t,t=0,\\pm1,\\pm2,\\ldots\\}\\) に対して以下の二つの関数を定義することができる. 平均関数 (mean function): \\[ \\mu_X(t) = E[X_t] \\qquad (\\#eq:mean.func)\\] 自己共分散関数 (autocovariance function): \\[ \\gamma_X(t,s) = Cov[X_t,X_s] = E[(X_t - \\mu_X(t))(X_s - \\mu_X(s))] \\] さらに, 自己相関関数 (autocorrelation function) も定義できる: \\[ \\rho_X(t,s) = \\frac{\\gamma_X(t,s)}{\\sqrt{\\gamma_X(t,t)}\\sqrt{\\gamma_X(s,s)}} \\] 時系列解析では, 主にこれら1次, 2次モーメントに依存する時系列的性質に注意を向ける. 2.2 定常性 (stationarity) 確率過程に関する規則性の概念の一つ 大雑把に言えば, \\(\\{X_t,t=0,\\pm1,\\pm2,\\ldots\\}\\) とそれが時間的に任意の整数\\(h\\)だけシフトした \\(\\{X_{t+h},t=0,\\pm1,\\pm2,\\ldots\\}\\) とが統計的に類似の性質を持つこと 理論面ばかりでなく, 時系列データの解析の実践面においても想定されることの多い重要な性質 大きく, 強定常性 (strict stationarity), 弱定常性 (weak stationarity)の2種類 2.2.1 強定常性 確率過程 \\(\\{X_t,t=0,\\pm1,\\pm2,\\ldots\\}\\) が強定常であるとは (定義): 任意の長さ\\(k=1,2,\\ldots\\), 任意の時点組合せ\\(t_1,t_2,\\ldots,t_k\\), 任意のラグ\\(h=0,\\pm1,\\pm2,\\ldots\\)に対して, 二つの確率変数ベクトル \\((X_{t_1},X_{t_2},\\ldots,X_{t_k})\\) と \\((X_{t_1+h},X_{t_2+h},\\ldots,X_{t_k+h})\\) が, 同じ確率分布を持つ. すなわち, 強定常であれば, \\(X_t\\)は同一分布を持つ. また, iid確率過程は, 強定常である. 2.2.2 弱定常性 確率過程 \\(\\{X_t,t=0,\\pm1,\\pm2,\\ldots\\}\\) が弱定常であるとは (定義): \\(\\mu_X(t)\\)が時間\\(t\\)に独立である: \\(\\mu_X(t) =\\mu_X(0) =: \\mu\\) \\(\\gamma_X(t+h,t)\\)が, 各\\(h\\)に対して時間\\(t\\)に独立である: : \\(\\gamma_X(t+h,t) = \\gamma_X(h,0) =: \\gamma_X(h)\\) さらに, 自己相関関数: \\[ \\rho_X(h) = \\frac{\\gamma_X(h)}{\\gamma_X(0)}\\] 習慣により, 時系列解析では単に“定常”と言えば弱定常を指す. 2.2.3 ホワイトノイズ 最も単純な定常過程にホワイトノイズ (白色ノイズ) がある. ホワイトノイズは, 時系列解析で使われる各種モデルの構築に中心的役割を果たす. ホワイトノイズ (“弱ホワイトノイズ”): 平均が一定(通常, ゼロ), 分散が有限で一定, 自己相関がゼロの確率過程 表記: \\(\\{X_t\\} \\sim WN(0,\\sigma^2)\\) 数式表現: \\(E[X_t]=0\\), \\(E[X_t^2]=\\sigma^2 &lt; \\infty \\quad (\\forall t)\\) \\[ E[X_t X_s] = \\begin{cases} \\sigma^2 &amp; (t = s)\\\\ 0 &amp; (t \\ne s) \\end{cases} \\quad (\\forall t,s) \\] IIDノイズ 有限分散を持つiid確率過程 (通常, 平均ゼロ) 独立性 → 無相関性により, ホワイトノイズと同じ形の自己共分散関数を持つ 表記: \\(\\{X_t\\} \\sim IID(0,\\sigma^2)\\) “強ホワイトノイズ”と呼ばれることもある 2.3 標本平均と標本自己共分散関数 観測された時系列データ\\(x_1,x_2,\\ldots,x_n\\)に対して 標本平均: \\[ \\bar{x} = \\frac{1}{n} \\sum_{t=1}^n x_t \\qquad (\\#eq:smean)\\] 確率過程 \\(\\{X_t,t=0,\\pm1,\\pm2,\\ldots\\}\\) の実現値を時間軸方向に平均した値 標本自己共分散関数: \\[ \\hat{\\gamma}(h) = \\frac{1}{n} \\sum_{i=1}^{n-|h|} (x_{t+|h|}-\\bar{x})(x_{t}-\\bar{x}),\\quad|h|&lt;n \\] 標本自己相関関数: \\[ \\hat{\\rho}(h) = \\frac{\\hat{\\gamma}(h)}{\\hat{\\gamma}(0)}, \\quad |h|&lt;n \\] 定常性の仮定が成立していなとくとも, 任意の時系列データに対して, (時間軸に沿って) 標本平均関数および標本自己共分散関数・標本自己相関関数を計算することができる. 標本自己共分散関数・標本自己相関関数の形状は, トレンドや周期性の存在を示す手掛かりとなる. 2.3.1 アンサンブル平均 vs 標本平均 平均関数の定義式における期待値 (式@ref(eq:mean.func)) は, 時点\\(t\\)において, 確率変数 \\(X_t\\) の全ての実現可能な値に対して平均を計算したもの (“アンサンブル平均”) である. 一方, 標本平均 (式(??)) は, 時系列データ (確率過程の実現値) を時間軸方向に平均した値 (時系列平均) である. よって, アンサンブル平均と時系列平均は, 概念的には別物である. データの背後にある確率過程\\(\\{X_t\\}\\)が定常であれば, 平均関数は定数値 \\(\\mu\\) を取るので, 標本平均を用いて推定する意味が出てくる. 標本平均 \\(\\bar{x}\\) の計算において, 十分に長いデータ期間を取る (標本サイズ \\(n \\rightarrow \\infty\\) ) ことで, \\(\\bar{x}\\) が真の値 \\(\\mu\\)に次第に近付いていく確率過程の性質を, (平均)エルゴード性 (ergodicity in (the) mean) と呼ぶ. 定常な確率過程を前提とした時系列解析は, 通常は, エルゴード性を有するモデルを前提に行われる. 2.4 標本自己相関関数 参考文献: CM, Ch.2 &amp; 4, Tsay, Ch.2 2.4.1 白色ノイズ (正規) 白色ノイズ ((Gaussian) white noise) # 乱数のシード設定 set.seed(1) w &lt;- rnorm(100) # 時系列プロット plot(w, type = &quot;l&quot;) # ヒストグラム z &lt;- seq(-3, 3, length = 1000) hist(rnorm(100), prob = T, xlim = c(-3, 3)); points(z, dnorm(z), type = &quot;l&quot;) # 自己相関関数(ACF) acf(w) # 2乗系列のACF acf(w^2) # 絶対値系列のACF acf(abs(w)) 2.4.2 ランダムウォーク (正規) ランダムウォーク ((Gaussian) random walk) x &lt;- cumsum(w) # 時系列プロット plot(x, type = &quot;l&quot;) # ACF acf(x) # 2乗系列のACF acf(x ^ 2) # 絶対値系列のACF acf(abs(x)) 2.4.3 非定常成分を含む時系列 2.4.3.1 AirPassengersデータ (出所: CM, Ch.2) data(AirPassengers) ap &lt;- AirPassengers acf(ap) 2.4.3.2 時系列の分解 decompose関数の利用 # 乗法モデルを仮定 ap_decom &lt;- decompose(ap, &quot;multiplicative&quot;) # トレンド成分 plot(ts(ap_decom$trend[7:138])) acf(ts(ap_decom$trend[7:138])) # 季節性成分 plot(ts(ap_decom$seasonal[7:138])) acf(ts(ap_decom$seasonal[7:138])) # ランダムノイズ成分 plot(ts(ap_decom$random[7:138])) acf(ts(ap_decom$random[7:138])) #library(zoo) # na.trim()使用 #acf(ap_decom$random, na.action = na.trim) # ← NA除去 # 標準偏差 sd(ap[7:138]) # sd of the original series #&gt; [1] 109.4187 sd(ap[7:138] - ap_decom$trend[7:138]) # after substracting the trend estimate #&gt; [1] 41.11491 sd(ap_decom$random[7:138]) # the error component #&gt; [1] 0.0333884 # → std dev gets smaller #または #library(zoo) #ap_d_zoo = zoo(ap_decom$random) stl関数の利用 # stl(): Seasonal Decomposition of Time Series by Loess ap_stl&lt;- stl(ap, &quot;period&quot;) # トレンド成分 plot(ap_stl$time.series[, &quot;trend&quot;]) # 季節性成分 plot(ap_stl$time.series[, &quot;seasonal&quot;]) # ランダムノイズ成分 plot(ap_stl$time.series[, &quot;remainder&quot;]) acf(ap_stl$time.series[, &quot;remainder&quot;]) 2.4.3.3 階差 (differencing) ap &lt;- AirPassengers is.ts(ap); is.vector(ts) #&gt; [1] TRUE #&gt; [1] FALSE # ACF acf(ap) # 対数値の階差系列のACF acf(diff(log(ap), lag = 1)) # 前月との階差 acf(diff(log(ap), lag = 12))# 1年前との階差 かばん検定 # かばん検定 (portmanteau test) Box.test(diff(log(ap), lag = 12)) # Box-Pierce検定 (デフォルト) #&gt; #&gt; Box-Pierce test #&gt; #&gt; data: diff(log(ap), lag = 12) #&gt; X-squared = 67.234, df = 1, p-value = 2.22e-16 Box.test(diff(log(ap), lag = 12), type = &quot;Ljung&quot;)# Ljung-Box検定 #&gt; #&gt; Box-Ljung test #&gt; #&gt; data: diff(log(ap), lag = 12) #&gt; X-squared = 68.774, df = 1, p-value &lt; 2.2e-16 2.4.3.4 株価データの例 (出所: Tsay, Ch.2) ifl &lt;- file.path(idir, &quot;m-ibmsp-2611.txt&quot;) da &lt;- read.table(&quot;m-ibmsp-2611.txt&quot;, header = T) #da &lt;- read.table(&quot;m-ibmsp6709.txt&quot;, header = T) head(da) #&gt; data ibm sp #&gt; 1 19260130 -0.010381 0.022472 #&gt; 2 19260227 -0.024476 -0.043956 #&gt; 3 19260331 -0.115591 -0.059113 #&gt; 4 19260430 0.089783 0.022688 #&gt; 5 19260528 0.036932 0.007679 #&gt; 6 19260630 0.068493 0.043184 ibm &lt;- da$ibm sp5 &lt;- da$sp plot(sp5, ibm) plot(ibm, type = &quot;l&quot;) plot(cumsum(log(ibm + 1)), type = &quot;l&quot;) # 原系列に対する自己相関性の検証 acf(ibm) acf(ibm)$acf #&gt; , , 1 #&gt; #&gt; [,1] #&gt; [1,] 1.000000000 #&gt; [2,] 0.037561974 #&gt; [3,] -0.008664145 #&gt; [4,] -0.016156989 #&gt; [5,] -0.030554233 #&gt; [6,] 0.015370816 #&gt; [7,] -0.041809301 #&gt; [8,] 0.003236462 #&gt; [9,] 0.063082544 #&gt; [10,] 0.048232274 #&gt; [11,] 0.037150816 #&gt; [12,] 0.011816712 #&gt; [13,] 0.010848647 #&gt; [14,] -0.067274698 #&gt; [15,] -0.011545286 #&gt; [16,] -0.038790792 #&gt; [17,] 0.031043139 #&gt; [18,] 0.029670820 #&gt; [19,] 0.065795548 #&gt; [20,] 0.019771486 #&gt; [21,] -0.013009184 #&gt; [22,] -0.012984508 #&gt; [23,] 0.002353094 #&gt; [24,] -0.072724702 #&gt; [25,] 0.053508492 #&gt; [26,] -0.010189813 #&gt; [27,] 0.036015597 #&gt; [28,] 0.019976030 #&gt; [29,] 0.032989584 #&gt; [30,] 0.004650878 #&gt; [31,] -0.016390330 Box.test(ibm, lag = 30) # Box-Pierce (デフォルト) #&gt; #&gt; Box-Pierce test #&gt; #&gt; data: ibm #&gt; X-squared = 38.094, df = 30, p-value = 0.1473 Box.test(ibm, lag = 30, type = &#39;Ljung&#39;) # Ljung-Box #&gt; #&gt; Box-Ljung test #&gt; #&gt; data: ibm #&gt; X-squared = 38.75, df = 30, p-value = 0.1314 #lnibm &lt;- log(ibm + 1) # Transfer to log returns #Box.test(lnibm, lag = 30, type = &#39;Ljung&#39;) # 絶対値系列, 2乗系列に対する自己相関性の検証 acf(abs(ibm)) acf(ibm ^ 2) Box.test(abs(ibm), lag = 30, type = &#39;Ljung&#39;) # Ljung-Box #&gt; #&gt; Box-Ljung test #&gt; #&gt; data: abs(ibm) #&gt; X-squared = 256.75, df = 30, p-value &lt; 2.2e-16 Box.test(ibm^2, lag = 30, type = &#39;Ljung&#39;) # Ljung-Box #&gt; #&gt; Box-Ljung test #&gt; #&gt; data: ibm^2 #&gt; X-squared = 189.3, df = 30, p-value &lt; 2.2e-16 2.4.4 線形時系列モデル 2.4.4.1 MA(1)・AR(1)モデル 2.4.4.1.1 シミュレーションによるパス生成 AR(1)モデル #par(mfrow = c(3,1)) Tlen = 100 set.seed(1) phi &lt;- - 0.8 x &lt;- w &lt;- rnorm(100) for (t in 2:100) x[t] = phi * x[t-1] + w[t] plot(x, type = &quot;l&quot;) # 時系列プロット acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) MA(1)モデル theta &lt;- - 0.8 for (t in 2:100) x[t] &lt;- w[t] + theta * w[t-1] plot(x, type = &quot;l&quot;) # 時系列プロット acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) 2.4.4.2 ARMA(1,1)モデル ARMA(1,1)モデル phi &lt;- 0.5; theta &lt;- 0.5 set.seed(1) x &lt;- arima.sim(n = Tlen, model = list(order = c(1,0,1), ar = phi, ma = theta)) plot(x, type = &quot;l&quot;) # 時系列プロット acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) 2.5 自己相関関数 (標本値 vs 理論値) AR(2) モデル シミュレーション sim_AR2 &lt;- function(phi_par, n_sim = 100, seed = 1, ...){ set.seed(seed) par(mfrow = c(3, 1)) x &lt;- w &lt;- rnorm(n_sim) for (t in 3:n_sim) {x[t] &lt;- phi_par[1] * x[t-1] + phi_par[2] * x[t-2] + w[t]} plot(x, type = &quot;l&quot;, ...) acf(x); pacf(x) par(mfrow = c(1,1)) } # Tsay, p_57, Fig 2_9のパラメータ例 phi_par1 &lt;- c(1.2, -0.35) # (phi1, phi2) phi_par2 &lt;- c(0.6, -0.4) # (phi1, phi2) phi_par3 &lt;- c(0.2, 0.35) # (phi1, phi2) phi_par4 &lt;- c(-0.2, 0.35) # (phi1, phi2) N &lt;- 400 Sd &lt;- 100 sim_AR2(phi_par1, n_sim = N, seed = Sd, main = &quot;(1)&quot;) sim_AR2(phi_par2, n_sim = N, seed = Sd, main = &quot;(2)&quot;) sim_AR2(phi_par3, n_sim = N, seed = Sd, main = &quot;(3)&quot;) sim_AR2(phi_par4, n_sim = N, seed = Sd, main = &quot;(4)&quot;) AR(2)の特性方程式の解 sol_AR2eqn &lt;- function(phi_par){ D &lt;- phi_par[1]^2 + 4 * phi_par[2] if (D&gt;= 0){ z1 &lt;- (phi_par[1] + sqrt(D)) / (-2 * phi_par[2]) z2 &lt;- (phi_par[1] - sqrt(D)) / (-2 * phi_par[2]) } else{ z1 &lt;- complex(re = phi_par[1] / (-2 * phi_par[2]), im = sqrt(-D)/(-2 * phi_par[2])) z2 &lt;- complex(re = phi_par[1] / (-2 * phi_par[2]), im = -sqrt(-D)/(-2 * phi_par[2])) } return(c(z1,z2)) } sol_AR2eqn(phi_par1) ## [1] 2.000000 1.428571 sol_AR2eqn(phi_par2) ## [1] 0.75+1.391941i 0.75-1.391941i sol_AR2eqn(phi_par3) ## [1] -2.000000 1.428571 sol_AR2eqn(phi_par4) ## [1] -1.428571 2.000000 AR(2)のACF理論値: rhoに関する差分方程式(漸化式)より計算 plot_ACF_AR2 &lt;- function(phi_par, hlen=10){ rho_0 &lt;- 1 rho_1 &lt;- phi_par[1]/(1-phi_par[2]) ACF_h &lt;- c(rho_0, rho_1) for (h in 1:hlen){ rho_2 = phi_par[1]*rho_1 + phi_par[2]*rho_0 ACF_h = c(ACF_h, rho_2) rho_0 = rho_1; rho_1 = rho_2 } barplot(ACF_h, main=phi_par) } 代替的アプローチ: 特性方程式の解を使って導出 plot_ACF_AR2_2 &lt;- function(phi_par, hlen=10){ zvec &lt;- sol_AR2eqn(phi_par) # 特性方程式の解 rho_0 &lt;- 1 rho_1 &lt;- phi_par[1]/(1-phi_par[2]) # c1, c2に関する連立方程式 cvec &lt;- solve(matrix(c(1, 1 , 1 / zvec[1], 1 / zvec[2]), 2, byrow = T), c(rho_0, rho_1) ) hvec &lt;- 0:hlen if (! is_complex(zvec)){ # 実根の場合 if (zvec[1] != zvec[2]) ACF_h &lt;- cvec[1] * zvec[1] ^ (-hvec) + cvec[2] * zvec[2] ^ (-hvec) else ACF_h &lt;- zvec[1]^(-hvec) * (cvec[1] + cvec[2] * hvec) # 重根 } else{ # 複素共役 (complex conjugates) の場合 z_mod &lt;- Mod(zvec[1]) th &lt;- Arg(zvec[1]) ACF_h &lt;- z_mod ^ (-hvec) * cos(hvec * th) } barplot(ACF_h, main = phi_par) } plot_ACF_AR2(phi_par1) plot_ACF_AR2(phi_par2) plot_ACF_AR2(phi_par3) plot_ACF_AR2(phi_par4) &lt;!— ### MA(2)モデル - シミュレーションと標本ACF・標本PACF sim_MA2 &lt;- function(theta_par, n_sim = 100, seed = 1, ...){ set.seed(seed) par(mfrow = c(3, 1)) x &lt;- w &lt;- rnorm(n_sim) for (t in 3:n_sim) {x[t] &lt;- w[t] + theta_par[1] * w[t-1] + theta_par[2] * w[t-2]} plot(x, type = &quot;l&quot;, ...) acf(x); pacf(x) par(mfrow = c(1, 1)) } theta_par1 &lt;- c(1.2, -0.35) # (theta1, theta2) theta_par2 &lt;- c(0.6, -0.4) # (theta1, theta2) theta_par3 &lt;- c(0.2, 0.35) # (theta1, theta2) theta_par4 &lt;- c(-0.2, 0.35) # (theta1, theta2) Sd &lt;- 100 sim_MA2(theta_par1, n_sim = N, seed = Sd, main = &quot;(1)&quot;) sim_MA2(theta_par2, n_sim = N, seed = Sd, main = &quot;(2)&quot;) sim_MA2(theta_par3, n_sim = N, seed = Sd, main = &quot;(3)&quot;) sim_MA2(theta_par4, n_sim = N, seed = Sd, main = &quot;(4)&quot;) 2.5.1 ARMA(1,1)モデル シミュレーションと標本ACF・標本PACF phi &lt;- 0.5; theta &lt;- 0.5 set.seed(1) x &lt;- arima.sim(n = N, model = list(order = c(1, 0, 1), ar = phi, ma = theta)) plot(x, type = &quot;l&quot;) # 時系列プロット acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) –!&gt; "],["armapqモデル.html", "3 ARMA\\((p,q)\\)モデル 3.1 ARMA\\((p,q)\\)モデルとは 3.2 ARMA\\((p,q)\\)モデルによる予測 3.3 ARMA\\((p,q)\\)モデルの推定 3.4 ARMA\\((p,q)\\)モデルの同定 (次数の特定) 3.5 Rによる実行例 3.6 ARMAモデル: データ分析例 (Tsay, Ch2)", " 3 ARMA\\((p,q)\\)モデル 3.1 ARMA\\((p,q)\\)モデルとは 定常, かつ 次の差分方程式を満たす\\({X_t}\\): \\[ X_t - \\phi_1 X_{t-1} - \\cdots - \\phi_p X_{t-p}= Z_t + \\theta_1 X_{t-1} + \\cdots + \\theta_q Z_{t-q} \\tag{1}\\] コンパクトな代替表現: \\[ \\phi(B)X_t = \\theta(B) Z_t \\tag{2}\\] Backward shift operator \\(B\\) AR多項式 \\(\\phi(z)=1 - \\phi_1 z - \\cdots - \\phi_p z^p\\) MA多項式 \\(\\theta(z)=1 + \\theta_1 z + \\cdots + \\theta_q z^q\\) 因果性と反転可能性 差分方程式の解\\({X_t}\\) 形式的に解くと, \\[ X_t = \\frac{\\theta(B)}{\\phi(B)} Z_t \\tag{3}\\] 解が存在 (定常, 因果的) するための条件? 定常性: \\(\\phi(z) \\ne 0,\\ \\forall |z|=1\\) 因果性: \\(\\phi(z) \\ne 0,\\ \\forall |z|\\le 1\\) +反転可能性: \\(\\theta(z) \\ne 0,\\ \\forall |z|\\le 1\\) ※ \\(\\phi(z)=0, \\theta(z)=0\\)は共通根を持たない (識別可能性) ※ 因果性は実用上不可欠: \\(X_t = \\sum_{i=0}^{\\infty}\\psi_i Z_{t-i}\\) (with \\(\\sum_{i=0}^{\\infty}|\\psi_i|&lt;\\infty\\)) (MA\\((\\infty)\\)表現) ※ 反転可能性は推定のために付加する条件: \\(Z_t = \\sum_{i=0}^{\\infty}\\pi_i X_{t-i}\\) (with \\(\\sum_{i=0}^{\\infty}|\\pi_i|&lt;\\infty\\)) (AR\\((\\infty)\\)表現) ARMA\\((p,q)\\)モデルの意義 なぜ必要か? AR(p)過程 実際の時系列データの記述 → 大きな\\(p\\)が必要となる可能性 MA\\((q)\\)過程. 反転可能な場合, AR\\((\\infty)\\)表現が可能 \\[ Z_t = X_t + \\sum_{i=1}^{\\infty}\\pi_i X_{t-i} \\] ∴ AR\\((p)\\)過程にMA\\((q)\\)項を付与することで, 少ないパラメータで, 現象を表現できることが期待される 3.2 ARMA\\((p,q)\\)モデルによる予測 過去データ\\(X_t,X_{t-1},\\cdots,X_1\\)に基づき, \\(h\\)期先の値\\(X_{t+h}\\)を予測したい モデルを推定 → 推定モデルを使って予測 どのように予測するか? 定常過程の予測 (当然, ARMA\\((p,q)\\)過程を含む) 線形予測 (Best Linear Prediction) 線形回帰問題を解く(正規方程式の解) AR\\((p)\\)モデル → \\(\\phi\\)係数をそのまま予測に使用 一般的解法 (MA\\((q)\\), ARMA\\((p,q)\\)モデル等にも適用): アルゴリズムによる予測(Duribin-Levinsonアルゴリズム, Innovationアルゴリズム) 3.3 ARMA\\((p,q)\\)モデルの推定 モデルをどのように推定するか? 次数\\(p,q\\)の同定(identification) (モデル選択) モデルパラメータ\\(\\phi\\) , \\(\\theta\\)の推定 予備的な推定 (→ 最尤法の初期値に利用可能) AR\\((p)\\)モデルのみ: Yule-Walker法, Burg法 MA\\((q)\\), ARMA\\((p,q)\\)モデル: Innovationアルゴリズム, Hannan-Rissanenアルゴリズム等 最尤法 標準的には, \\(Z_t\\)が正規ホワイトノイズ (IID + 正規分布) → \\(X_t\\)は, Gaussian過程 \\(Z_t\\)が非正規のIIDノイズの場合でも, 大標本ならば使用OK モデル診断 適合モデルから得られた残差系列がホワイトノイズか? 時系列プロット, 標本ACFプロット 自己相関の検定, かばん検定 正規性検定 (qqプロット, Jarque-Bera検定など) 参考文献: Brockwell and Davis, Introduction to Time Series and Forecasting. 3.4 ARMA\\((p,q)\\)モデルの同定 (次数の特定) 標本自己相関(ACF), 標本偏自己相関(PACF)の使用 定常過程は, ACVF/ACFによって特徴付けられる →時系列データから標本SACFをプロット AR\\((p)\\) → PACFが\\((p+1)\\)次以降のラグが値\\(0\\) MA\\((q)\\) → ACFが\\((q+1)\\)次以降のラグが値\\(0\\) ARMA\\((p,q)\\) →Extended ACF(EACF)の表内で, “○”(値が有意でない)の領域中で最も左上の要素の位置(行\\(p\\),列\\(q\\))を見つける AIC, BICなどのモデル選択基準の使用 モデル推定と同時に行う モデル選択基準 = - 2・対数尤度 + 罰則項(パラメータ数の増加関数) 3.5 Rによる実行例 3.5.1 ARMA\\((p,q)\\)モデルの同定 (ACF/PACF/EACFの利用) AR(3)モデル #par(mfrow = c(3,1)) Tlen = 100 phi=c(0.5,-0.8, 0.5); theta = NULL set.seed(10) x = arima.sim(n = Tlen, model = list(order = c(3,0,0), ar = phi, ma = theta)) #plot(x, type = &quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) MA(2)モデル phi = NULL; theta=c(0.3,0.4) set.seed(10) x = arima.sim(n = Tlen, model = list(order = c(0,0,2), ar = phi, ma = theta)) #plot(x, type = &quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) ARMA(2,1)モデル phi = c(0.3,-0.8); theta = 0.9 set.seed(10) x = arima.sim(n = Tlen, model = list(order = c(2,0,1), ar = phi, ma = theta)) #plot(x, type=&quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) require(TSA) ## Loading required package: TSA ## ## Attaching package: &#39;TSA&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## acf, arima ## The following object is masked from &#39;package:utils&#39;: ## ## tar m1 = eacf(x, 6, 8) # Simplified table ## AR/MA ## 0 1 2 3 4 5 6 7 8 ## 0 x x x x x o x o o ## 1 x x x x x x x o o ## 2 x o o o o o o o o ## 3 x o o o o o o o o ## 4 x x x o o o o o o ## 5 x o x o o o o o o ## 6 x o o o o o o o o print(m1$eacf, digits = 2) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## [1,] 0.30 -0.613 -0.41 0.304 0.3518 -0.131 -0.269 0.048 0.197 ## [2,] 0.34 -0.767 -0.43 0.462 0.3388 -0.214 -0.250 0.088 0.182 ## [3,] 0.50 -0.021 -0.13 -0.135 -0.0102 0.053 0.033 -0.095 -0.205 ## [4,] 0.51 -0.097 -0.11 -0.140 -0.0241 0.116 0.031 -0.062 -0.183 ## [5,] 0.26 -0.364 0.40 -0.137 -0.0169 -0.032 0.012 -0.078 -0.104 ## [6,] 0.47 -0.028 0.23 -0.162 0.0055 -0.045 0.055 -0.055 -0.114 ## [7,] 0.49 0.052 0.17 -0.067 -0.1727 -0.019 0.038 -0.070 -0.059 → EACFは\\((p,q)=(2,1)\\)を示唆. 3.5.2 ARMA\\((p,q)\\)モデルの推定・診断 仮に\\((p,q)=(2,2)\\)を選んだとすると, (x.fit = arima(x,order = c(2,0,2))) # ARMA(2,2)モデルの推定(制約なし) ## ## Call: ## arima(x = x, order = c(2, 0, 2)) ## ## Coefficients: ## ar1 ar2 ma1 ma2 intercept ## 0.3556 -0.7777 0.8059 -0.0712 -0.0247 ## s.e. 0.0887 0.0687 0.1279 0.1353 0.1187 ## ## sigma^2 estimated as 0.9372: log likelihood = -140.93, aic = 291.87 # --&gt; 有意でない係数=0を指定 (x.fit2 = arima(x,order = c(2,0,2), fixed = c(NA,NA,NA,0,NA))) # 制約付き推定 ## ## Call: ## arima(x = x, order = c(2, 0, 2), fixed = c(NA, NA, NA, 0, NA)) ## ## Coefficients: ## ar1 ar2 ma1 ma2 intercept ## 0.3270 -0.7772 0.8604 0 -0.0260 ## s.e. 0.0706 0.0691 0.0802 0 0.1249 ## ## sigma^2 estimated as 0.9407: log likelihood = -141.07, aic = 290.15 tsdiag(x.fit2, gof = 20) # モデル診断 Box.test(x.fit2$residuals, lag = 20, type = &#39;Ljung&#39;) # Ljung-Box検定 ## ## Box-Ljung test ## ## data: x.fit2$residuals ## X-squared = 13.785, df = 20, p-value = 0.8412 3.5.3 パッケージ{forecast}の利用 モデルの自動選択・推定 require(forecast) ## Loading required package: forecast ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo ## Registered S3 methods overwritten by &#39;forecast&#39;: ## method from ## fitted.Arima TSA ## plot.Arima TSA (x.fit3 = auto.arima(x)) # AIC/AICc(デフォルト)/BICによりモデルを自動選択&amp;推定 ## Series: x ## ARIMA(2,0,1) with zero mean ## ## Coefficients: ## ar1 ar2 ma1 ## 0.3273 -0.7773 0.8606 ## s.e. 0.0706 0.0691 0.0801 ## ## sigma^2 = 0.9702: log likelihood = -141.1 ## AIC=290.19 AICc=290.61 BIC=300.61 推定モデルを使った予測 (x.pred = forecast(x.fit3, h=20)) ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 101 4.8076600 3.5453579 6.0699620 2.8771355 6.7381844 ## 102 3.2942800 1.3342557 5.2543043 0.2966815 6.2918785 ## 103 -2.6587345 -4.6791846 -0.6382845 -5.7487463 0.4312772 ## 104 -3.4306758 -5.8473695 -1.0139821 -7.1266899 0.2653382 ## 105 0.9437980 -1.4734713 3.3610674 -2.7530964 4.6406925 ## 106 2.9754436 0.3543532 5.5965340 -1.0331682 6.9840554 ## 107 0.2401888 -2.4072595 2.8876371 -3.8087340 4.2891116 ## 108 -2.2341203 -4.9639829 0.4957423 -6.4090848 1.9408442 ## 109 -0.9178543 -3.6944931 1.8587845 -5.1643569 3.3286483 ## 110 1.4361307 -1.3626481 4.2349096 -2.8442321 5.7164936 ## 111 1.1834256 -1.6613440 4.0281953 -3.1672741 5.5341253 ## 112 -0.7289626 -3.5757196 2.1177945 -5.0827018 3.6247766 ## 113 -1.1584110 -4.0375796 1.7207575 -5.5617193 3.2448973 ## 114 0.1874876 -2.6922716 3.0672467 -4.2167240 4.5916991 ## 115 0.9617589 -1.9352597 3.8587775 -3.4688487 5.3923665 ## 116 0.1690270 -2.7318039 3.0698578 -4.2674110 4.6054649 ## 117 -0.6922301 -3.5997273 2.2152671 -5.1388633 3.7544032 ## 118 -0.3579265 -3.2709875 2.5551344 -4.8130688 4.0972157 ## 119 0.4209117 -2.4936672 3.3354906 -4.0365521 4.8783755 ## 120 0.4159582 -2.5036126 3.3355289 -4.0491400 4.8810563 plot(x.pred) # 3.6 ARMAモデル: データ分析例 (Tsay, Ch2) 出所: Tsay, Ch.2 (一部改変) 3.6.1 標本ACF pp.46–47 Example 2.1 ifl &lt;- file.path(dir_introTS, &quot;m-dec12910.txt&quot;) da = read.table(ifl, header=T) #da = read.table(&quot;m-dec12910.txt&quot;, header = T) head(da) ## date dec1 dec2 dec9 dec10 ## 1 19670131 0.068568 0.080373 0.180843 0.211806 ## 2 19670228 0.008735 0.011044 0.048767 0.064911 ## 3 19670331 0.039698 0.035364 0.067494 0.068904 ## 4 19670428 0.044030 0.037541 0.040785 0.044602 ## 5 19670531 -0.050631 -0.036233 -0.002191 0.000295 ## 6 19670630 0.014998 0.018870 0.102075 0.118678 d10 = da$dec10 # select the Decile 10 returns dec10 = ts(d10, frequency = 12, start = c(1967, 1)) par(mfcol = c(2, 1)) plot(dec10, xlab = &#39;year&#39;, ylab = &#39;returns&#39;) # matplot(da[, -1], type = &quot;l&quot;) title(main = &#39;(a): Simple returns&#39;) acf(d10, lag = 24) # command to obtain sample ACF of the data # RK: 有意性確認 f1 = acf(d10, lag = 24) f1$acf ## , , 1 ## ## [,1] ## [1,] 1.000000000 ## [2,] 0.227386585 ## [3,] -0.019026447 ## [4,] -0.021258247 ## [5,] 0.011011345 ## [6,] 0.002676057 ## [7,] -0.027654887 ## [8,] -0.016910608 ## [9,] -0.049183690 ## [10,] -0.039617756 ## [11,] 0.013265549 ## [12,] 0.061013220 ## [13,] 0.130411045 ## [14,] -0.036881195 ## [15,] -0.082462743 ## [16,] -0.020950139 ## [17,] 0.016726386 ## [18,] -0.013961209 ## [19,] -0.059422809 ## [20,] -0.082246074 ## [21,] -0.063641596 ## [22,] -0.039858376 ## [23,] 0.017770989 ## [24,] -0.015413528 ## [25,] 0.052212082 # (tt = f1$acf[13] * sqrt(516)) # nrow(da) = 516 (tt = f1$acf[13] * sqrt(length(d10))) # 絶対値の大きいh = 13でのt値 ## [1] 2.962369 Ljung-Box Q statistics P.48, Example 2.2 ifl &lt;- file.path(dir_introTS, &quot;m-ibmsp6709.txt&quot;) da = read.table(ifl, header=T) #da = read.table(&quot;m-ibmsp6709.txt&quot;, header = T) ibm = da$ibm lnibm = log(ibm + 1) # Transfer to log returns Box.test(ibm, lag = 12, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: ibm ## X-squared = 7.5666, df = 12, p-value = 0.818 Box.test(lnibm, lag = 12, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: lnibm ## X-squared = 7.4042, df = 12, p-value = 0.8298 3.6.2 AR, MA, ARMA (2.4–2.6) p.58, Example 2.3 GNP, 1947.Q1–2010.Q1 par(mfrow = c(1, 1)) ifl &lt;- file.path(dir_introTS, &quot;q-gnp4710.txt&quot;) da = read.table(ifl, header=T) #da = read.table(&quot;q-gnp4710.txt&quot;, header = T) head(da); tail(da); nrow(da) ## Year Mon Dat VALUE ## 1 1947 1 1 238.1 ## 2 1947 4 1 241.5 ## 3 1947 7 1 245.6 ## 4 1947 10 1 255.6 ## 5 1948 1 1 261.7 ## 6 1948 4 1 268.7 ## Year Mon Dat VALUE ## 248 2008 10 1 14317.2 ## 249 2009 1 1 14172.2 ## 250 2009 4 1 14164.2 ## 251 2009 7 1 14281.9 ## 252 2009 10 1 14442.8 ## 253 2010 1 1 14637.6 ## [1] 253 G = da$VALUE plot(G, type = &quot;l&quot;) LG = log(G) gnp = diff(LG) dim(da) ## [1] 253 4 #tdx = c(1:253) / 4 + 1947 # create the time index tdx = c(1:length(G)) / 4 + 1947 # 1947スタート, 四半期データ par(mfcol = c(2, 1)) plot(tdx, G, xlab = &#39;year&#39;, ylab = &#39;GNP&#39;, type = &#39;l&#39;) #plot(tdx[2:253], gnp, type = &#39;l&#39;, xlab = &#39;year&#39;, ylab = &#39;growth&#39;) plot(tdx[-1], gnp, type = &#39;l&#39;, xlab = &#39;year&#39;, ylab = &#39;growth&#39;) # acf(gnp, lag = 12) pacf(gnp, lag = 12) # compute PACF arima(): 一変量arimaモデルの適合 (次数order, 分析者が指定) (m1 = arima(gnp, order = c(3, 0, 0))) # ARIMA(3, 0, 0) = AR(3) ## ## Call: ## arima(x = gnp, order = c(3, 0, 0)) ## ## Coefficients: ## ar1 ar2 ar3 intercept ## 0.4386 0.2063 -0.1559 0.0163 ## s.e. 0.0620 0.0666 0.0626 0.0012 ## ## sigma^2 estimated as 9.549e-05: log likelihood = 808.56, aic = -1607.12 tsdiag(m1, gof = 12) # model checking discussed later p1 = c(1, -m1$coef[1:3]) # set-up the polynomial (AR係数) (r1 = polyroot(p1)) # solve the polynomial equation (AR特性方程式の解) ## [1] 1.616116+0.864212i -1.909216+0.000000i 1.616116-0.864212i Mod(r1) # compute absolute value ## [1] 1.832674 1.909216 1.832674 (k = 2 * pi / acos(1.616116 / 1.832674)) # compute length of the period ## [1] 12.79523 # &lt;-- (ACF)周期の計算, p.56内, k = の式 (参考) zooクラスにして実行した場合 library(zoo) ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric G.zoo = zoo(G, tdx) plot(G.zoo) m1.zoo = arima(diff(log(G.zoo)), order = c(3, 0, 0)) tsdiag(m1.zoo, gof = 12) # gnp.zoo = zoo(gnp, tdx[-1]) gnp.zoo = diff(log(G.zoo)) # zoo クラス plot(gnp.zoo) # Q statistic: based on lag autocorrelation coefficients Box.test(m1.zoo$residuals, lag = 1, type = &quot;Ljung-Box&quot;) ## ## Box-Ljung test ## ## data: m1.zoo$residuals ## X-squared = 0.0071647, df = 1, p-value = 0.9325 Box.test(m1.zoo$residuals, lag = 5, type = &quot;Ljung-Box&quot;) ## ## Box-Ljung test ## ## data: m1.zoo$residuals ## X-squared = 6.1525, df = 5, p-value = 0.2917 Box.test(m1.zoo$residuals, lag = 12, type = &quot;Ljung-Box&quot;) # → p = 0.05271 ## ## Box-Ljung test ## ## data: m1.zoo$residuals ## X-squared = 20.844, df = 12, p-value = 0.05271 p.63 mm1 = ar(gnp, method = &#39;mle&#39;) # yule-walker(デフォルト), burg, ols, yw # aic = T (デフォルト) --&gt; 次数選択実行 mm1$order # Find the identified order ## [1] 9 names(mm1) ## [1] &quot;order&quot; &quot;ar&quot; &quot;var.pred&quot; &quot;x.mean&quot; &quot;aic&quot; ## [6] &quot;n.used&quot; &quot;n.obs&quot; &quot;order.max&quot; &quot;partialacf&quot; &quot;resid&quot; ## [11] &quot;method&quot; &quot;series&quot; &quot;frequency&quot; &quot;call&quot; &quot;asy.var.coef&quot; print(mm1$aic, digits = 3) ## 0 1 2 3 4 5 6 7 8 9 10 ## 77.767 11.915 8.792 4.669 6.265 5.950 5.101 4.596 6.541 0.000 0.509 ## 11 12 ## 2.504 2.057 aic = mm1$aic # For plotting below. length(aic) ## [1] 13 plot(c(0:12), aic, type = &#39;h&#39;, xlab = &#39;order&#39;, ylab = &#39;aic&#39;) lines(0:12, aic, lty = 2) # RK: In ar.yw the variance matrix of the innovations is computed from the fitted coefficients and the autocovariance of x. (参考) zooクラス利用の場合 aic.zoo = zoo(aic, order.by = c(0:12)) plot(aic.zoo) table 2.1 (p.61)の例, Value-weighted Index # AR係数は小さいが有意. 定数項の有意性⇒期待値非ゼロ? #vw = read.table(&#39;m-ibm3dx.txt&#39;, header = T)[, 3] ifl &lt;- file.path(dir_introTS, &#39;m-ibm3dx2608.txt&#39;) vw = read.table(ifl, header=T)[, 3] ar(vw, method = &quot;mle&quot;) # demean = T ## ## Call: ## ar(x = vw, method = &quot;mle&quot;) ## ## Coefficients: ## 1 2 3 4 5 6 7 8 ## 0.1167 -0.0112 -0.1126 0.0217 0.0735 -0.0452 0.0254 0.0462 ## 9 ## 0.0660 ## ## Order selected 9 sigma^2 estimated as 0.002831 #ar(vw) # average annual simple gross returnの計算 (t1 = prod(vw + 1)) ## [1] 1592.953 # t1^(12 / 996)-1 # 年平均成長率 t1^(12 / length(vw))-1 # 年平均成長率 ## [1] 0.09290084 #tmp &lt;- ar(vw, method = &quot;mle&quot;) # tmp$ar / sqrt(diag(tmp$asy)) (m3 = arima(vw, order = c(3, 0, 0))) # include.mean = T (デフォルト) ## ## Call: ## arima(x = vw, order = c(3, 0, 0)) ## ## Coefficients: ## ar1 ar2 ar3 intercept ## 0.1158 -0.0187 -0.1042 0.0089 ## s.e. 0.0315 0.0317 0.0317 0.0017 ## ## sigma^2 estimated as 0.002875: log likelihood = 1500.86, aic = -2991.73 # --&gt; phi2有意でない (1-.1158 + .0187 + .1042)*mean(vw) # Compute the intercept phi(0). ## [1] 0.008967611 # m3$coef sqrt(m3$sigma2) # Compute standard error of residuals ## [1] 0.0536189 Box.test(m3$residuals, lag = 12, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: m3$residuals ## X-squared = 16.352, df = 12, p-value = 0.1756 # --&gt; X-squared = 16.352 (pv = 1-pchisq(16.35, 9)) # Compute p value using 12 degrees of freedom ## [1] 0.05992276 # ← カイ2乗分布の自由度12-3 = 9(AR多項式の次数p = 3) (m3 = arima(vw, order = c(3, 0, 0), fixed = c(NA, 0, NA, NA))) ## Warning in arima(vw, order = c(3, 0, 0), fixed = c(NA, 0, NA, NA)): some AR ## parameters were fixed: setting transform.pars = FALSE ## ## Call: ## arima(x = vw, order = c(3, 0, 0), fixed = c(NA, 0, NA, NA)) ## ## Coefficients: ## ar1 ar2 ar3 intercept ## 0.1136 0 -0.1063 0.0089 ## s.e. 0.0313 0 0.0315 0.0017 ## ## sigma^2 estimated as 0.002876: log likelihood = 1500.69, aic = -2993.38 # ← パラメータを推定する場合には&quot;NA&quot;指定: この例では, phi2 = 0 (1-.1136 + .1063)*.0089 # compute phi(0) ## [1] 0.00883503 sqrt(m3$sigma2) # compute residual standard error ## [1] 0.05362832 Box.test(m3$residuals, lag = 12, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: m3$residuals ## X-squared = 16.828, df = 12, p-value = 0.1562 (pv = 1-pchisq(16.83, 10)) ## [1] 0.07821131 # ← カイ2乗分布の自由度12-2 = 10(AR多項式の次数p = 2) p.77 ifl &lt;- file.path(dir_introTS, &#39;m-ibm3dx2608.txt&#39;) da = read.table(ifl, header=T) head(da) ## date ibmrtn vwrtn ewrtn sprtn ## 1 19260130 -0.010381 0.000724 0.023174 0.022472 ## 2 19260227 -0.024476 -0.033374 -0.053510 -0.043956 ## 3 19260331 -0.115591 -0.064341 -0.096824 -0.059113 ## 4 19260430 0.089783 0.038358 0.032946 0.022688 ## 5 19260528 0.036932 0.012172 0.001035 0.007679 ## 6 19260630 0.068493 0.056888 0.050487 0.043184 ew = da$ewrtn (m1 = arima(ew, order = c(0, 0, 9))) # unrestricted model ## ## Call: ## arima(x = ew, order = c(0, 0, 9)) ## ## Coefficients: ## ma1 ma2 ma3 ma4 ma5 ma6 ma7 ma8 ## 0.2144 0.0374 -0.1203 -0.0425 0.0232 -0.0302 0.0482 -0.0276 ## s.e. 0.0316 0.0321 0.0328 0.0336 0.0319 0.0318 0.0364 0.0354 ## ma9 intercept ## 0.1350 0.0122 ## s.e. 0.0323 0.0028 ## ## sigma^2 estimated as 0.005043: log likelihood = 1220.86, aic = -2419.72 # --&gt; 有意でない係数 = 0を指定 (m1 = arima(ew, order = c(0, 0, 9), fixed = c(NA, 0, NA, 0, 0, 0, 0, 0, NA, NA))) ## ## Call: ## arima(x = ew, order = c(0, 0, 9), fixed = c(NA, 0, NA, 0, 0, 0, 0, 0, NA, NA)) ## ## Coefficients: ## ma1 ma2 ma3 ma4 ma5 ma6 ma7 ma8 ma9 intercept ## 0.1909 0 -0.1199 0 0 0 0 0 0.1227 0.0122 ## s.e. 0.0293 0 0.0338 0 0 0 0 0 0.0312 0.0027 ## ## sigma^2 estimated as 0.005097: log likelihood = 1215.61, aic = -2421.22 sqrt(0.005097) ## [1] 0.07139328 Box.test(m1$residuals, lag = 12, type = &#39;Ljung&#39;) # model checking ## ## Box-Ljung test ## ## data: m1$residuals ## X-squared = 17.604, df = 12, p-value = 0.1283 (pv = 1-pchisq(17.6, 9)) # compute p-value after adjusting the d.f. ## [1] 0.04010828 # ← カイ2乗分布の自由度12-3 = 9(AR多項式の次数p = 3) # Out-of-sample prediction (m1 = arima(ew[1:986], order = c(0, 0, 9), fixed = c(NA, 0, NA, 0, 0, 0, 0, 0, NA, NA))) ## ## Call: ## arima(x = ew[1:986], order = c(0, 0, 9), fixed = c(NA, 0, NA, 0, 0, 0, 0, 0, ## NA, NA)) ## ## Coefficients: ## ma1 ma2 ma3 ma4 ma5 ma6 ma7 ma8 ma9 intercept ## 0.1844 0 -0.1206 0 0 0 0 0 0.1218 0.0128 ## s.e. 0.0295 0 0.0338 0 0 0 0 0 0.0312 0.0027 ## ## sigma^2 estimated as 0.005066: log likelihood = 1206.44, aic = -2402.88 predict(m1, 10) # prediction ## $pred ## Time Series: ## Start = 987 ## End = 996 ## Frequency = 1 ## [1] 0.004282626 0.013558874 0.015024191 0.014453445 0.012046343 0.001805558 ## [7] 0.012211538 0.005514814 0.008513456 0.012791824 ## ## $se ## Time Series: ## Start = 987 ## End = 996 ## Frequency = 1 ## [1] 0.07117456 0.07237493 0.07237493 0.07288176 0.07288176 0.07288176 ## [7] 0.07288176 0.07288176 0.07288176 0.07339566 EACF table ifl &lt;- file.path(dir_introTS, &#39;m-3m4608.txt&#39;) da = read.table(ifl, header=T) head(da) ## date rtn ## 1 19460228 -0.077922 ## 2 19460330 0.018592 ## 3 19460430 -0.100000 ## 4 19460531 0.209877 ## 5 19460628 0.005128 ## 6 19460731 0.076531 mmm = log(da$rtn + 1) library(TSA) # Load the package ## ## Attaching package: &#39;TSA&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## acf, arima ## The following object is masked from &#39;package:utils&#39;: ## ## tar m1 = eacf(mmm, 6, 12) # Simplified table ## AR/MA ## 0 1 2 3 4 5 6 7 8 9 10 11 12 ## 0 o o x o o x o o o x o x o ## 1 x o x o o x o o o o o x o ## 2 x x x o o x o o o o o o o ## 3 x x x o o o o o o o o o o ## 4 x o x o o o o o o o o o o ## 5 x x x o x o o o o o o o o ## 6 x x x x x o o o o o o o o print(m1$eacf, digits = 2) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## [1,] -0.056 -0.0380 -0.082 -0.0046 0.01774 0.0821 0.0080 0.0127 -0.03014 ## [2,] -0.474 0.0096 -0.074 -0.0209 0.00196 0.0772 -0.0288 0.0026 -0.00683 ## [3,] -0.383 -0.3476 -0.074 0.0160 -0.00553 0.0772 0.0269 0.0120 0.00045 ## [4,] -0.177 0.1381 0.384 -0.0224 0.00232 0.0419 -0.0232 0.0154 -0.00440 ## [5,] 0.421 0.0287 0.454 -0.0079 0.00071 0.0025 -0.0140 0.0305 0.01159 ## [6,] -0.114 0.2135 0.449 0.0096 0.20242 -0.0063 -0.0038 0.0403 -0.01294 ## [7,] -0.208 -0.2504 0.243 0.3111 0.16745 -0.0388 -0.0034 0.0429 -0.01009 ## [,10] [,11] [,12] [,13] ## [1,] -0.0778 0.0488 0.0909 -0.011 ## [2,] -0.0694 0.0372 0.0938 -0.024 ## [3,] -0.0268 0.0221 0.0428 0.042 ## [4,] -0.0254 0.0185 0.0100 0.043 ## [5,] 0.0042 0.0191 -0.0043 0.013 ## [6,] -0.0123 0.0315 0.0117 0.028 ## [7,] -0.0260 0.0078 0.0106 0.037 # --&gt; ARMA(0, 0)モデル "],["arimaモデルsarimaモデル.html", "4 ARIMAモデル/SARIMAモデル 4.1 ARIMA\\((p,d,q)\\)モデルとは 4.2 SARIMA\\((p,d,q)\\times (P,D,Q)_s\\)モデル (周期\\(s\\))とは 4.3 SARIMAモデルのパス発生 ({sarima}パッケージの利用) 4.4 SARIMAモデルの推定・診断 4.5 パッケージ{forecast}の利用", " 4 ARIMAモデル/SARIMAモデル 4.1 ARIMA\\((p,d,q)\\)モデルとは \\(Y_t:=(1-B)^d X_t\\)が, causal ARMA\\((p,q)\\)となる確率過程\\(X_t\\) (\\(d\\)は非負整数), すなわち, \\[ \\phi(B)Y_t = \\theta(B) Z_t \\tag{2}\\] Backward shift operator \\(B\\) AR多項式 \\(\\phi(z)=1 - \\phi_1 z - \\cdots - \\phi_p z^p\\) MA多項式 \\(\\theta(z)=1 + \\theta_1 z + \\cdots + \\theta_q z^q\\) 4.2 SARIMA\\((p,d,q)\\times (P,D,Q)_s\\)モデル (周期\\(s\\))とは \\(Y_t:=(1-B)^d (1-B^s)^D X_t\\)が, 以下で定義されるcausal ARMAとなる確率過程\\(X_t\\) (\\(d,D\\)は非負整数) \\[ \\phi(B)\\Phi(B^s) Y_t = \\theta(B) \\Theta(B^s) Z_t \\tag{2}\\] Backward shift operator \\(B\\) AR多項式 \\(\\phi(z)=1 - \\phi_1 z - \\cdots - \\phi_p z^p\\) MA多項式 \\(\\theta(z)=1 + \\theta_1 z + \\cdots + \\theta_q z^q\\) SAR多項式 \\(\\Phi(z)=1 - \\Phi_1 z - \\cdots - \\Phi_p z^P\\) SMA多項式 \\(\\Theta(z)=1 + \\Theta_1 z + \\cdots + \\Theta_q z^Q\\) 4.3 SARIMAモデルのパス発生 ({sarima}パッケージの利用) “SAR(1)”モデル (s=12) require(sarima) ## Loading required package: sarima ## Loading required package: stats4 ## ## Attaching package: &#39;sarima&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## spectrum #par(mfrow=c(3,1)) Seedv = 10 Tlen = 144 set.seed(Seedv) #x &lt;- sim_sarima(n = 144, model = list(ar = c(rep(0,11), 0.8))) # 12 seasons x &lt;- sim_sarima(n = 144, model = list(sar = 0.8, nseasons = 12, sigma2 = 1)) # 12 seasons ts.plot(x, type = &quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) “SMA(1)”モデル set.seed(Seedv) #x &lt;- sim_sarima(n = 144, model = list(ma = c(rep(0,11), 0.8))) # 12 seasons x &lt;- sim_sarima(n = 144,model = list(sma = 0.8, nseasons = 12, sigma2 = 1)) # 12 seasons ts.plot(x, type = &quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) I(1) モデル (“Random Walk”) set.seed(Seedv) x &lt;- sim_sarima(n = 144, model = list(iorder = 1, sigma2 = 1)) # (1-B)X_t = e_t (random walk) ts.plot(x, type=&quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) SARIMA\\((0,0,0) \\times (0,1,0)_{12}\\) set.seed(Seedv) x &lt;- sim_sarima(n = 144, model = list(siorder = 1,nseasons = 12, sigma2 = 1)) # (1-B)^{12} X_t = e_t ts.plot(x, type=&quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) SARIMA\\((0,1,0) \\times (0,1,0)_{12}\\) set.seed(Seedv) x &lt;- sim_sarima(n = 144, model = list(iorder = 1, siorder = 1, nseasons = 12, sigma2 = 1)) ts.plot(x, type = &quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) SARIMA\\((0,1,0) \\times (0,1,0)_{12}\\)に, 初期値xを指定したシミュレーション x &lt;- sim_sarima(n = 144, model = list(iorder = 1, siorder = 1, nseasons = 12, sigma2 = 1), x = list(init=AirPassengers[1:13])) ts.plot(x, type = &quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) SARIMA\\((0,0,0) \\times (1,0,1)_{12}\\) set.seed(Seedv) x &lt;- sim_sarima(n = 144, model = list(sar = 0.4, sma = 0.5, iorder = 0, siorder = 0, nseasons = 12)) ts.plot(x, type = &quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) SARIMA\\((0,0,1) \\times (1,0,1)_{12}\\) set.seed(Seedv) x &lt;- sim_sarima(n = 144, model = list(ma = 0.7, sar = 0.4, sma = 0.5, iorder = 0, siorder = 0, nseasons = 12)) ts.plot(x, type = &quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) SARIMA\\((2,1,1) \\times (1,1,1)_{12}\\) set.seed(Seedv) x &lt;- sim_sarima(n = 144, model = list(ar = c(1.2, -0.8), ma = 0.4, sar = 0.3, sma = 0.7, iorder = 1, siorder = 1, nseasons = 12)) ts.plot(x, type = &quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) 4.4 SARIMAモデルの推定・診断 arima関数は, SARIMAモデルの推定が可能 (一方, arima.sim関数はSARIMAモデルのパスを生成できない) 仮に\\((p,d,q)=(2,1,1), (P,D,Q)=(1,1,1), s=12\\)を正しく選んだとすると, (x.fit = arima(x, order = c(2,1,1), seasonal = list(order = c(1,1,1), period = 12))) ## ## Call: ## arima(x = x, order = c(2, 1, 1), seasonal = list(order = c(1, 1, 1), period = 12)) ## ## Coefficients: ## ar1 ar2 ma1 sar1 sma1 ## 1.2462 -0.8486 0.3504 0.2220 1.0000 ## s.e. 0.0589 0.0558 0.0842 0.0909 0.2598 ## ## sigma^2 estimated as 0.7217: log likelihood = -183.18, aic = 378.35 tsdiag(x.fit, gof = 20) # モデル診断 Box.test(x.fit$residuals,lag = 20,type = &#39;Ljung&#39;) # Ljung-Box検定 ## ## Box-Ljung test ## ## data: x.fit$residuals ## X-squared = 12.586, df = 20, p-value = 0.8944 ※ ARIMAモデル指定の場合には, 定数項パラメータは推定されない (include.meanオプションは無視される) 4.5 パッケージ{forecast}の利用 モデルの自動選択・推定 forecast::auto.arima関数は, seasonalオプションによりSARIMAモデルを推定可能 (デフォルトは, seasonal = T) require(forecast) ## Loading required package: forecast ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo (x.fit3 = auto.arima(x)) # AIC/AICc(デフォルト)/BICによりモデルを自動選択&amp;推定 ## Series: x ## ARIMA(4,1,1) with drift ## ## Coefficients: ## ar1 ar2 ar3 ar4 ma1 drift ## 2.2193 -2.3467 1.3199 -0.4084 -0.7300 -3.0955 ## s.e. 0.0898 0.1786 0.1721 0.0780 0.0598 0.4031 ## ## sigma^2 = 14.72: log likelihood = -393.94 ## AIC=801.88 AICc=802.71 BIC=822.62 → モデルは正しく推定はされてはいない. 定数項は大きな値 tsdiag(x.fit3, gof = 20) # モデル診断 Box.test(x.fit3$residuals, lag = 20, type = &#39;Ljung&#39;) # Ljung-Box検定 ## ## Box-Ljung test ## ## data: x.fit3$residuals ## X-squared = 145.11, df = 20, p-value &lt; 2.2e-16 → 季節性も残留 推定モデルを使った予測 (x.pred = forecast(x.fit3, h = 20)) ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 145 -436.1359 -441.0524 -431.2195 -443.6550 -428.6169 ## 146 -445.6132 -458.8023 -432.4240 -465.7842 -425.4421 ## 147 -452.7936 -474.2717 -431.3155 -485.6416 -419.9457 ## 148 -455.4497 -482.6672 -428.2321 -497.0753 -413.8240 ## 149 -454.4453 -484.5206 -424.3700 -500.4415 -408.4491 ## 150 -452.2585 -483.3464 -421.1706 -499.8034 -404.7136 ## 151 -451.0034 -482.3361 -419.6708 -498.9226 -403.0843 ## 152 -451.6076 -482.9808 -420.2343 -499.5887 -403.6264 ## 153 -454.0855 -485.4704 -422.7006 -502.0846 -406.0864 ## 154 -458.0720 -489.4894 -426.6545 -506.1208 -410.0231 ## 155 -463.0825 -494.6429 -431.5221 -511.3499 -414.8151 ## 156 -468.5396 -500.5108 -436.5684 -517.4353 -419.6439 ## 157 -473.8106 -506.5744 -441.0469 -523.9185 -423.7028 ## 158 -478.3561 -512.2327 -444.4796 -530.1658 -426.5464 ## 159 -481.8994 -516.9893 -446.8096 -535.5647 -428.2341 ## 160 -484.4929 -520.6666 -448.3192 -539.8159 -429.1700 ## 161 -486.4490 -523.4555 -449.4425 -543.0455 -429.8524 ## 162 -488.1924 -525.7803 -450.6045 -545.6781 -430.7066 ## 163 -490.1157 -528.1020 -452.1293 -548.2108 -432.0206 ## 164 -492.4836 -530.7678 -454.1994 -551.0343 -433.9330 plot(x.pred) # 参考. 任意トレンドを加えてのシミュレーション (xinterceptオプション使用) set.seed(Seedv) x = sim_sarima(n = 144, model = list(sma = 0.4, ma = 0.4, sar = 0.8, ar = 0.5, nseasons = 12, sigma2 = 1), xintercept = (1:144) * 0.05) ts.plot(x, type = &quot;l&quot;) # 時系列プロット par(mfrow = c(1,2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) モデル次数, 線形トレンドを正しく指定した場合のarimaによる推定 (x.fit = arima(x,order = c(1,0,1), seasonal = list(order = c(1,0,1), period = 12), xreg = 1:144)) ## ## Call: ## arima(x = x, order = c(1, 0, 1), seasonal = list(order = c(1, 0, 1), period = 12), ## xreg = 1:144) ## ## Coefficients: ## ar1 ma1 sar1 sma1 intercept 1:144 ## 0.7606 0.1744 0.7531 0.6228 -5.2907 0.3521 ## s.e. 0.0656 0.1134 0.0576 0.0957 3.0592 0.0310 ## ## sigma^2 estimated as 0.9208: log likelihood = -211.59, aic = 437.19 tsdiag(x.fit, gof = 20) # モデル診断 Box.test(x.fit$residuals, lag = 20, type = &#39;Ljung&#39;) # Ljung-Box検定 ## ## Box-Ljung test ## ## data: x.fit$residuals ## X-squared = 11.261, df = 20, p-value = 0.9392 線形トレンドを正しく指定した場合のauto.arimaによる推定 require(forecast) (x.fit3 = auto.arima(x, xreg = 1:144)) # AIC/AICc(デフォルト)/BICによりモデルを自動選択&amp;推定 ## Series: x ## Regression with ARIMA(1,0,0) errors ## ## Coefficients: ## ar1 intercept xreg ## 0.8291 -8.3410 0.3737 ## s.e. 0.0485 1.9888 0.0233 ## ## sigma^2 = 4.862: log likelihood = -317.26 ## AIC=642.53 AICc=642.81 BIC=654.41 "],["単位根過程と単位根検定.html", "5 単位根過程と単位根検定 5.1 単位根過程と見せかけの回帰 5.2 主な単位根検定法", " 5 単位根過程と単位根検定 5.1 単位根過程と見せかけの回帰 5.1.1 単位根過程 ランダムウォークモデル (I(1))のパス生成 #require(sarima) Tlen &lt;- 100 Seedv &lt;- 1 # set.seed(Seedv) #x &lt;- sim_sarima(n = Tlen, model = list(iorder = 1, sigma2 = 1)) # (1-B)X_t = e_t (random walk) #y &lt;- sim_sarima(n = Tlen, model = list(iorder = 1, sigma2 = 1)) x &lt;- arima.sim(n = Tlen, list(order = c(0, 1, 0))) y &lt;- arima.sim(n = Tlen, list(order = c(0, 1, 0))) # #par(mfrow=c(1,2)) #acf(x) # 自己相関(ACF) #pacf(x) # 偏自己相関(PACF) #matplot(cbind(x, y), type = &quot;l&quot;) ts.plot(cbind(x, y), lty = 1:2) 5.1.2 見せかけの回帰 reslm &lt;- lm(y ~ x) summary(reslm) ## ## Call: ## lm(formula = y ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -9.049 -2.862 1.383 3.172 5.519 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.42205 0.68668 0.615 0.54 ## x -0.51303 0.09909 -5.178 1.18e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.752 on 99 degrees of freedom ## Multiple R-squared: 0.2131, Adjusted R-squared: 0.2051 ## F-statistic: 26.81 on 1 and 99 DF, p-value: 1.182e-06 plot(x, y) plot(as.numeric(x), as.numeric(y)) abline(reslm) 5.1.3 見せかけの回帰の判定 library(lmtest) ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric dwtest(reslm) ## ## Durbin-Watson test ## ## data: reslm ## DW = 0.080227, p-value &lt; 2.2e-16 ## alternative hypothesis: true autocorrelation is greater than 0 Durbin-Watson検定 (簡便法) 回帰残差の系列相関の有無を検定 \\(DW \\approx 2(1-\\rho)\\) \\(0&lt;DW&lt;4\\). 無相関 \\(\\Leftrightarrow DW=2\\) 見せかけの回帰の場合. DWが小さい傾向 (正の系列相関) 代替法: Engle-Granger検定 「見せかけの回帰」については後日扱う 5.2 主な単位根検定法 ADF検定: tseries内, adf.test(); fUnitRoots内, unitrootTest(), adfTest() Phillips-Perron(PP)検定: urca内, ur.pp(); tseries内, pp.test() PP検定は, 沖本, pp.118–120参照 KPSS検定: urca内, ur.kpss(); tseries内, kpss.test() KPSS検定は, 福地・伊藤, pp.139–140参照 5.2.1 Augmented Dicky-Fuller (ADF) 検定の実行例 fUnitRootsパッケージ内, unitrootTest()使用 adfTest(): Banerjee&#39;s et al.(93)による検定統計量の計算 unitrootTest(): McKinnons(96) のアプローチによる検定統計量の計算 - type: &quot;nc&quot;(定数項・時間トレンド項共なし), &quot;c&quot;(定数項のみ有), &quot;ct&quot;(定数項・時間トレンド項共有) - lags: 誤差項の持つ最大ラグ数 上記シミュレーションデータに対して, ADF検定を実行 library(fUnitRoots) adfTest(x, type = &quot;nc&quot;, lags = 1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: 0.282 ## P VALUE: ## 0.703 ## ## Description: ## Tue Mar 19 13:23:32 2024 by user: unitrootTest(x, type = &quot;nc&quot;, lags = 1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## DF: 0.282 ## P VALUE: ## t: 0.7657 ## n: 0.7506 ## ## Description: ## Tue Mar 19 13:23:32 2024 by user: 二つの関数の結果を比較せよ. adfTest(y, type = &quot;nc&quot;, lags = 1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -0.7206 ## P VALUE: ## 0.3835 ## ## Description: ## Tue Mar 19 13:23:32 2024 by user: unitrootTest(y, type = &quot;nc&quot;, lags = 1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## DF: -0.7206 ## P VALUE: ## t: 0.4021 ## n: 0.522 ## ## Description: ## Tue Mar 19 13:23:32 2024 by user: → いずれも, 帰無仮説(phi_1=1)を棄却せず(単位根有り) adfTest(x, type = &quot;c&quot;, lags = 1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -1.4551 ## P VALUE: ## 0.5166 ## ## Description: ## Tue Mar 19 13:23:32 2024 by user: #unitrootTest(x, type = &quot;c&quot;, lags = 1) adfTest(y, type = &quot;c&quot;, lags = 1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -1.0635 ## P VALUE: ## 0.6617 ## ## Description: ## Tue Mar 19 13:23:32 2024 by user: #unitrootTest(y, type = &quot;c&quot;, lags = 1) adfTest(x, type = &quot;c&quot;, lags = 1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -1.4551 ## P VALUE: ## 0.5166 ## ## Description: ## Tue Mar 19 13:23:32 2024 by user: #unitrootTest(x, type = &quot;ct&quot;, lags = 1) adfTest(y, type = &quot;c&quot;, lags = 1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -1.0635 ## P VALUE: ## 0.6617 ## ## Description: ## Tue Mar 19 13:23:32 2024 by user: #unitrootTest(y, type = &quot;ct&quot;, lags = 1) 株価データ(quantmodパッケージにより取得) tseriesパッケージ内, adf.test()使用 adf.test(x, alternative = c(&quot;stationary&quot;, &quot;explosive&quot;), k = trunc((length(x)-1)^(1/3))) - k: number of lags in the regression. - default: trunc((length(x)-1)^(1/3)): the suggested upper bound on the rate - (to grow with the sample size for the general ARMA(p,q) setup) - alternative: &quot;stationary&quot;(デフォルト) or &quot;explosive&quot; # 対立仮説の指定 library(&#39;quantmod&#39;) ## Loading required package: xts ## Loading required package: TTR ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo yj8411 &lt;- getSymbols(&#39;8411.T&#39;,from = &#39;2020-10-01&#39;, to = &#39;2023-09-29&#39;, src = &quot;yahoo&quot;, auto.assign = FALSE) # 注) R/RStudioや, guantmodのバージョンによっては, 動かないことがある p8411 &lt;- Ad(yj8411) # 調整後株価 #lnp8411 &lt;- log(Ad(yj8411)) # 同対数値 (← 期間が長い場合など) # plot(p8411) #plot(lnp8411) acf(p8411) pacf(p8411) #acf(diff(p8411), na.action = na.omit) #pacf(diff(p8411),na.action = na.omit) 株価データに対してADF検定を実行 # ADF検定 (Augmentd Dicky-Fuller test) # (H0: x has unit root) library(tseries) adf.test(p8411) adf.test(p8411, k = 1) # adfTest(p8411, type =&quot;ct&quot;, lags = 1) # → 同一の結果 # adf.test(p8411, k = 1, alternative = &quot;explosive&quot;) # &lt;-- H0 と H1を入替 (→ 同一のDF値. 上行のp値 = 1-下行のp値) ## ## Augmented Dickey-Fuller Test ## ## data: p8411 ## Dickey-Fuller = -0.7077, Lag order = 9, p-value = 0.9698 ## alternative hypothesis: stationary ## ## ## Augmented Dickey-Fuller Test ## ## data: p8411 ## Dickey-Fuller = -0.87317, Lag order = 1, p-value = 0.9551 ## alternative hypothesis: stationary ## ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -0.8732 ## P VALUE: ## 0.9551 ## ## Description: ## Tue Mar 19 13:23:33 2024 by user: ## ## ## Augmented Dickey-Fuller Test ## ## data: p8411 ## Dickey-Fuller = -0.87317, Lag order = 1, p-value = 0.04492 ## alternative hypothesis: explosive 5.2.2 ADF検定以外の検定法 Phillips-Perron検定の実行例 #library(tseries) pp.test(p8411, type = &quot;Z(alpha)&quot;, lshort = T) # デフォルト ## ## Phillips-Perron Unit Root Test ## ## data: p8411 ## Dickey-Fuller Z(alpha) = -3.4966, Truncation lag parameter = 6, p-value ## = 0.9119 ## alternative hypothesis: stationary pp.test(p8411, type = &quot;Z(alpha)&quot;, lshort = F) ## ## Phillips-Perron Unit Root Test ## ## data: p8411 ## Dickey-Fuller Z(alpha) = -2.3572, Truncation lag parameter = 19, ## p-value = 0.9584 ## alternative hypothesis: stationary pp.test(p8411, type = &quot;Z(t_alpha)&quot;) ## ## Phillips-Perron Unit Root Test ## ## data: p8411 ## Dickey-Fuller Z(t_alpha) = -0.92218, Truncation lag parameter = 6, ## p-value = 0.9507 ## alternative hypothesis: stationary #pp.test(p8411, alternative = &quot;explosive&quot;) library(urca) ## ## Attaching package: &#39;urca&#39; ## The following objects are masked from &#39;package:fUnitRoots&#39;: ## ## punitroot, qunitroot, unitrootTable #lags: ラグの長さの指定. 4(T/100)^(1/4) or 12(T/100)^(1/4) #model: トレンドを持つ(&quot;trend&quot;), 定数項を持つ(&quot;constant&quot;) ur.pp(p8411, type = &quot;Z-alpha&quot;, model = &quot;trend&quot;, lags = &quot;short&quot;) ## ## ################################################## ## # Phillips-Perron Unit Root / Cointegration Test # ## ################################################## ## ## The value of the test statistic is: -3.4916 ur.pp(p8411, type = &quot;Z-alpha&quot;, model = &quot;trend&quot;, lags = &quot;long&quot;) ## ## ################################################## ## # Phillips-Perron Unit Root / Cointegration Test # ## ################################################## ## ## The value of the test statistic is: -2.3635 ur.pp(p8411, type = &quot;Z-tau&quot;, model = &quot;trend&quot;, lags = &quot;long&quot;) ## ## ################################################## ## # Phillips-Perron Unit Root / Cointegration Test # ## ################################################## ## ## The value of the test statistic is: -0.6783 ur.pp(p8411, type = &quot;Z-tau&quot;, model = &quot;constant&quot;) ## ## ################################################## ## # Phillips-Perron Unit Root / Cointegration Test # ## ################################################## ## ## The value of the test statistic is: 0.823 KPSS検定の実行例 ur.kpss(p8411, type = &quot;mu&quot;, lags = &quot;long&quot;) ## ## ####################################### ## # KPSS Unit Root / Cointegration Test # ## ####################################### ## ## The value of the test statistic is: 2.9445 ur.kpss(p8411, type = &quot;tau&quot;, lags = &quot;long&quot;) ## ## ####################################### ## # KPSS Unit Root / Cointegration Test # ## ####################################### ## ## The value of the test statistic is: 0.6989 "],["長期記憶過程.html", "6 長期記憶過程 6.1 ARFIMA(p,d,q)過程のシミュレーション 6.2 ARFIMA, fractional Gaussian過程のシミュレーション 6.3 Hurst指数の推定 6.4 ARFIMAモデルの推定 6.5 ARFIMAモデル: データ分析例 (Tsay, 2.11, pp.119–120)", " 6 長期記憶過程 6.1 ARFIMA(p,d,q)過程のシミュレーション fracdiffパッケージの利用 サンプルパス生成(1): p = 2, d = 0.49, q = 0 簡単のため, MA項入れず Tlen = 300 Seedv = 100; set.seed(Seedv) library(fracdiff) fds_sim &lt;- fracdiff.sim(Tlen, ar = c(0.7, -0.2), d = 0.49) # -0.5&lt;=d&lt;=0.5 x &lt;- fds_sim$series # 長期記憶系列 plot(x, type = &quot;l&quot;) par(mfrow = c(1, 2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) サンプルパス生成(2): p = 2, d = 0.1, q = 0 set.seed(Seedv) fds_sim &lt;- fracdiff.sim(Tlen, ar = c(0.7, -0.2), d = 0.1) x &lt;- fds_sim$series # 長期記憶系列 plot(x, type = &quot;l&quot;) par(mfrow = c(1, 2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) サンプルパス生成(3): p = 2, d = -0.49, q = 0 set.seed(Seedv) fds_sim &lt;- fracdiff.sim(Tlen, ar = c(0.7, -0.2), d = -0.49) x &lt;- fds_sim$series # 長期記憶系列 plot(x, type = &quot;l&quot;) par(mfrow = c(1, 2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) 6.2 ARFIMA, fractional Gaussian過程のシミュレーション longmemoパッケージの利用 - ckARMA0(n, H) - Compute the Autocovariances of a fractional ARIMA(0,d,0) process (d = H - 1/2). - The theoretical formula, C(k) = (-1)^k Γ(1-2d) / (Γ(k+1-d) Γ(1-k-d)) , where d = H - 1/2, leads to over-/underflow for larger lags k; hence use the asymptotical formula there. - ckFGN0(n, H) - Compute the Autocovariances of a fractional Gaussian process ########################################################### #install.packages(&quot;longmemo&quot;) library(longmemo) #data(&quot;NileMin&quot;) # Nile River Minima, yearly 622-1284 #nile &lt;- NileMin Seedv &lt;- 1 Tlen &lt;- 100; Hval &lt;- 0.9 plot(ckARMA0(Tlen, H = Hval), type = &quot;h&quot;) # H &gt; 0.5の時のみ plot(x = 0:(Tlen-1), ckARMA0(Tlen, H = Hval), type = &quot;h&quot;, log = &quot;xy&quot;, main = paste0(&quot;Log-Log ACF for ARFIMA(0,d,0) with H = &quot;, Hval)) # ckFGN0(n, H) # Compute the Autocovariances of a fractional Gaussian process plot(ckFGN0(Tlen, H = Hval), type = &quot;h&quot;) # (H &gt; 0.5の時のみ) plot(x = 0:(Tlen-1), ckFGN0(Tlen, H = Hval), type = &quot;h&quot;, log = &quot;xy&quot;, main = paste0(&quot;Log-Log ACF for frac. Gauss. Noise(H = &quot;, Hval, &quot;)&quot;)) - simGauss: implements the method by Davies and Harte which is relatively fast using the FFT (fft) twice. - To simulate ARIMA(p, d, q), (for d in (-1/2, 1,2), you can use arima.sim(n, model = list(ar= .., ma = ..), innov= simARMA0(n,H=d+1/2) , n.start = 0). - simFGN.fft() is about twice as fast as simFGN0() and uses Paxson&#39;s proposal, by default via B.specFGN(*, k.approx = 3, adjust = TRUE). Seedv &lt;- 1 set.seed(Seedv) x1 &lt;- simFGN0(Tlen, H = Hval) x2 &lt;- simARMA0(Tlen, H = Hval) ts.plot(ts.union(x1, x2), col = 1:2, lty = 1:2, main = paste0(&quot;frac. Gauss. Noise vs ARFIMA(0,d,0): H = &quot;, Hval)) #ts.plot(cbind(x1, x2), col = 1:2, lty = 1:2) fBM_path &lt;- function(tlen = 100, H = 0.5, sd_val = 1) { set.seed(sd_val) cumsum(simFGN0(tlen, H)) } # plot(fBM_path(Tlen, Hval, Seedv), type = &quot;l&quot;) # 異なるHの値でのサンプルパスの比較 hvals &lt;- c(0.5, 0.1, 0.8) fBM1 &lt;- fBM_path(Tlen, hvals[1], Seedv) fBM2 &lt;- fBM_path(Tlen, hvals[2], Seedv) fBM3 &lt;- fBM_path(Tlen, hvals[3], Seedv) ts.plot(cbind(fBM1, fBM2, fBM3), col = c(&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 1, lwd = c(1, 3, 3), main = paste0(&quot;frac. Brownian Motions: H = &quot;, paste(hvals, collapse = &quot;,&quot;))) 6.3 Hurst指数の推定 pracmaパッケージの利用 - hurstexp: R/S分析によるHurst指数推定 - 出力: - Hs - simplified R over S approach - Hrs - corrected R over S Hurst exponent - He - empirical Hurst exponent - Hal - corrected empirical Hurst exponent - Ht - theoretical Hurst exponent library(pracma) data(brown72) x72 &lt;- brown72 # H = 0.72 xgn &lt;- rnorm(1024) # H = 0.50 xlm &lt;- numeric(1024); xlm[1] &lt;- 0.1 # H = 0.43 for (i in 2:1024) xlm[i] &lt;- 4 * xlm[i-1] * (1 - xlm[i-1]) plot(x72, type = &quot;l&quot;) plot(xgn, type = &quot;l&quot;) plot(xlm, type = &quot;l&quot;) hurstexp(brown72) # d: smallest box size (default = 50) ## Simple R/S Hurst estimation: 0.6628842 ## Corrected R over S Hurst exponent: 0.7378703 ## Empirical Hurst exponent: 0.6920439 ## Corrected empirical Hurst exponent: 0.6577233 ## Theoretical Hurst exponent: 0.5404756 hurstexp(xgn) ## Simple R/S Hurst estimation: 0.4784489 ## Corrected R over S Hurst exponent: 0.4898617 ## Empirical Hurst exponent: 0.5041802 ## Corrected empirical Hurst exponent: 0.4636032 ## Theoretical Hurst exponent: 0.5404756 hurstexp(xlm) ## Simple R/S Hurst estimation: 0.4762169 ## Corrected R over S Hurst exponent: 0.4722421 ## Empirical Hurst exponent: 0.4872281 ## Corrected empirical Hurst exponent: 0.4460807 ## Theoretical Hurst exponent: 0.5404756 fractalパッケージの利用 library(fractal) x &lt;- x72 hurstSpec(x) RoverS(x) hurstBlock(x, method=&quot;aggAbs&quot;) hurstBlock(x, method=&quot;aggVar&quot;) hurstBlock(x, method=&quot;diffvar&quot;) hurstBlock(x, method=&quot;higuchi&quot;) 6.4 ARFIMAモデルの推定 6.4.1 最尤法 誤ってARモデルを選択した場合 set.seed(Seedv) fds_sim &lt;- fracdiff.sim(Tlen, ar = c(0.7, -0.2), d = -0.49) x &lt;- fds_sim$series # 長期記憶系列 # (ar_fit &lt;- ar(x, method = &quot;mle&quot;)) ## ## Call: ## ar(x = x, method = &quot;mle&quot;) ## ## Coefficients: ## 1 2 3 4 5 6 ## 0.2060 -0.2321 -0.2082 -0.1717 -0.1534 -0.1875 ## ## Order selected 6 sigma^2 estimated as 0.7814 → 大きい\\(p\\)を選択 AR係数, MA係数, 階差次数\\(d\\)を最尤推定 (以下, \\(p=2\\)を正しくしていたと仮定) # nar=p, nma=q # AR, MAパラメーター数 (fds_fit &lt;- fracdiff(x, nar = 2)) ## ## Call: ## fracdiff(x = x, nar = 2) ## ## Coefficients: ## d ar1 ar2 ## 4.583013e-05 3.478729e-01 -2.143891e-01 ## sigma[eps] = 0.9577181 ## a list with components: ## [1] &quot;log.likelihood&quot; &quot;n&quot; &quot;msg&quot; &quot;d&quot; ## [5] &quot;ar&quot; &quot;ma&quot; &quot;covariance.dpq&quot; &quot;fnormMin&quot; ## [9] &quot;sigma&quot; &quot;stderror.dpq&quot; &quot;correlation.dpq&quot; &quot;h&quot; ## [13] &quot;d.tol&quot; &quot;M&quot; &quot;hessian.dpq&quot; &quot;length.w&quot; ## [17] &quot;residuals&quot; &quot;fitted&quot; &quot;call&quot; → 通常は\\(p,q\\)は未知 → 複数のnar, nmaを試すべき nsarfimaパッケージの利用 library(nsarfima) # nar = p, nma = q # AR, MAパラメーター数 (arfima.fit &lt;- mle.arfima(x, p = 2)) ## $pars ## mu sig2 d ar.1 ar.2 ## -1.267263e-02 9.022758e-01 5.522776e-08 3.414323e-01 -2.625068e-01 ## ## $std.errs ## mu sig2 d ar.1 ar.2 ## 0.1016556 0.1395288 0.1733823 0.2163811 0.1612114 ## ## $cov.mat ## sig2 d ar.1 ar.2 ## sig2 0.019468294 0.00740705 -0.01170439 -0.004266261 ## d 0.007407050 0.03006142 -0.03229578 -0.021628130 ## ar.1 -0.011704389 -0.03229578 0.04682076 0.024479505 ## ar.2 -0.004266261 -0.02162813 0.02447951 0.025989126 ## ## $fit.obj ## $fit.obj$par ## d ar.1 ar.2 ## 5.522776e-08 3.414323e-01 -2.625068e-01 ## ## $fit.obj$value ## [1] 89.3253 ## ## $fit.obj$counts ## function gradient ## 208 NA ## ## $fit.obj$convergence ## [1] 0 ## ## $fit.obj$message ## NULL ## ## ## $p.val ## [1] 0.8912225 ## ## $residuals ## [1] -0.6764961052 -0.2968632520 -1.2310910722 1.4561378726 -0.0388534504 ## [6] -0.8423204011 0.4686722844 0.4643382756 0.4107973532 -0.4309650411 ## [11] 1.4299789135 -0.0006787575 -0.7857763053 -2.3890626204 1.1014635252 ## [16] -0.3966402031 0.1652482404 1.0616568645 0.7446050471 0.5154245086 ## [21] 0.7564241338 0.4668174692 -0.2693729499 -2.3064083881 0.5227350640 ## [26] -0.4642720829 -0.1309552624 -1.4100725427 -0.2774497899 0.4650877267 ## [31] 1.4649891568 -0.0290343810 0.5782727746 -0.1757284573 -1.4912805335 ## [36] -0.3789621380 -0.4655630075 0.0738483187 1.2914770769 0.8336925539 ## [41] -0.0737873115 -0.2251819617 0.5774490180 0.3286308280 -0.8047251630 ## [46] -0.6986673145 0.2958393665 0.6510135686 -0.1339248247 0.9675384987 ## [51] 0.2259759735 -0.7281405491 0.2716268869 -1.3784731074 1.4943394505 ## [56] 1.7164276897 -0.5272803532 -1.0201592423 0.3729804733 -0.5359889283 ## [61] 2.3350415888 -0.4086512940 0.6924717331 -0.3606512486 -1.0759283895 ## [66] -0.0506511539 -2.1101132511 1.5976097508 -0.1172982949 2.3325016401 ## [71] 0.2254993256 -0.8129057325 0.3788283790 -1.4331970583 -1.3747001462 ## [76] 0.2411732472 -0.5537230862 0.2049218798 0.2004499504 -0.4766722677 ## [81] -0.4042575452 -0.0270582246 1.2728679869 -1.5304518129 0.9624356049 ## [86] 0.2186716228 1.1235112273 -0.3688834767 0.4233844401 0.0726586865 ## [91] -0.6954346528 1.1689570269 0.8808727109 0.5369119812 1.3879840390 ## [96] 0.0879308998 -1.6719344153 -0.8630402713 -1.6381541198 -0.5431240556 モデル診断/残差チェック方法の例 時系列データ\\(x_t\\)と\\(d\\)の推定値(初期値)があるとする 推定された\\(d\\)が正しい値ならば, \\(Y_t=(1-B)^d X_t\\)はARMA過程になるはず \\(x_t\\)より, パス\\(y_t\\)を(近似的に)生成する (get_fracdiff_ts関数使用. 配布のRコード参照) ARMAモデルを生成パス\\(y_t\\)に適合する. 得られる残差系列が白色ノイズか? (納得いくまで) 候補を変えて試す. ここでは, AR(p)モデルに限定. 以下, 上で生成したパス\\(x_t\\), 得られた\\(d\\)の推定値をそのまま使用. 長期記憶過程xより非整数階差系列yを生成する関数 (以下で使用) # 参考: Cowpertwait and Metcalfe(2009), Ch.8 get_fracdiff_ts &lt;- function(x, d, L = 30){ # L: 項の打ち切り数 n &lt;- length(x) # fdc: (1-B)^dの2項展開係数ベクトルを生成 fdc &lt;- d fdc[1] &lt;- fdc for (k in 2:L) fdc[k] &lt;- fdc[k-1] * (d+1-k) / k # y, 非整数階差系列(fractionally differenced series)を生成 y &lt;- rep(0, L) for (i in (L+1):n) { csm &lt;- x[i] # x, 原系列（長期記憶過程) for (j in 1:L) csm &lt;- csm + ((-1)^j) * fdc[j] * x[i-j] y[i] &lt;- csm } y &lt;- y[(L+1):n] return(y) } y &lt;- get_fracdiff_ts(x, fds_fit$d) # {x_t}より非整数階差系列{y_t}を生成 (z.ar &lt;- ar(y)) # ARモデルをフィット ## ## Call: ## ar(x = y) ## ## Coefficients: ## 1 2 3 4 ## 0.2598 -0.0943 -0.1637 -0.2469 ## ## Order selected 4 sigma^2 estimated as 0.8692 ns &lt;- 1 + z.ar$order z &lt;- z.ar$res [ns:length(y)] # z.ar$resの最初のns個は欠損 par(mfcol = c(2, 2)) plot(as.ts(x), ylab = &quot;x&quot;) acf(x) ; acf(y) ; acf(z) Box.test(z, lag = 30, type = &quot;Ljung&quot;) ## ## Box-Ljung test ## ## data: z ## X-squared = 29.658, df = 30, p-value = 0.4833 6.4.2 階差次数\\(d\\)の代替的推定法 fracdiffパッケージ利用 Geweke and Porter-Hudak(83), Reisen(94) 時系列データのperidogram (スペクトル密度の推定値) ベース # library(fracdiff) # Geweke and Porter-Hudak(83)の方法 (d_GPH = fdGPH(x)) ## $d ## [1] -0.7167363 ## ## $sd.as ## [1] 0.2935592 ## ## $sd.reg ## [1] 0.2232167 # Reisen(94)の方法 (d_Sper = fdSperio(x)) ## $d ## [1] -0.6491031 ## ## $sd.as ## [1] 0.1334138 ## ## $sd.reg ## [1] 0.08329104 # GPH推定値の使用 y &lt;- get_fracdiff_ts(x, d_GPH$d) # {x_t}より非整数階差系列{y_t}を生成 # ARMAモデルの適合に, forecastパッケージのauto.arima関数使用 library(forecast) (y_fit &lt;- auto.arima(y)) # ARモデルをフィット ## Series: y ## ARIMA(0,0,3) with zero mean ## ## Coefficients: ## ma1 ma2 ma3 ## 0.8403 0.5521 0.2549 ## s.e. 0.1171 0.1411 0.1297 ## ## sigma^2 = 0.8098: log likelihood = -90.83 ## AIC=189.66 AICc=190.27 BIC=198.65 y_resid &lt;- y_fit$res par(mfcol = c(1, 2)) acf(y_resid); pacf(y_resid) Box.test(y_resid, lag = 30, type = &quot;Ljung&quot;) ## ## Box-Ljung test ## ## data: y_resid ## X-squared = 17.267, df = 30, p-value = 0.9692 よりフォーマルなモデル同定・推定の手順は, 配布資料参照. 6.5 ARFIMAモデル: データ分析例 (Tsay, 2.11, pp.119–120) データ&amp;コードの出所: https://sites.google.com/site/econometricsr/home/rcode コードは一部改 #library(fracdiff) ifl &lt;- file.path(dir_introTS, &quot;d-ibm3dx7008.txt&quot;) da = read.table(ifl, header = T) head(da) ## Date rtn vwretd ewretd sprtrn ## 1 19700102 0.000686 0.012137 0.033450 0.010211 ## 2 19700105 0.009596 0.006375 0.018947 0.004946 ## 3 19700106 0.000679 -0.007233 -0.005776 -0.006848 ## 4 19700107 0.000678 -0.001272 0.003559 -0.002047 ## 5 19700108 0.002034 0.000564 0.002890 0.000540 ## 6 19700109 -0.001353 -0.002797 -0.002923 -0.003021 ew = abs(da$vwretd) # daily abs ret&#39;s of value-weighted CRSP, 1970--2008 plot(as.ts(ew)) 次数dの推定 # pure fractionally differenced modelに対して(p=0, q=0) # Geweke-Porter-Hudak(83) estimate #(m3 = fdGPH(da$vwretd)) # d=0.05282 (m3 = fdGPH(ew)) ## $d ## [1] 0.372226 ## ## $sd.as ## [1] 0.0698385 ## ## $sd.reg ## [1] 0.06868857 → 0&lt;d&lt;0.5 ∴ stationary, invertible # Reisen (94) estimate # (m3.2 = fdSperio(ew)) # 0.3784656 # 最尤法 (nar, nmaの指定必要) #m3.0 = fracdiff(ew,nar = 0, nma = 0) # デフォルト: nar = 0, nma = 0 #summary(m3.0) # ARFIMA(1,d,1)の最尤推定 m2 = fracdiff(ew, nar = 1, nma = 1) summary(m2) ## ## Call: ## fracdiff(x = ew, nar = 1, nma = 1) ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## d 0.490938 0.007997 61.39 &lt;2e-16 *** ## ar 0.113389 0.005988 18.94 &lt;2e-16 *** ## ma 0.575895 0.005946 96.85 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## sigma[eps] = 0.0065619 ## [d.tol = 0.0001221, M = 100, h = 0.0003742] ## Log likelihood: 3.551e+04 ==&gt; AIC = -71021.02 [4 deg.freedom] coef(m2) ## d ar ma ## 0.4909382 0.1133893 0.5758949 confint(m2) ## 2.5 % 97.5 % ## d 0.4752637 0.5066127 ## ar 0.1016536 0.1251250 ## ma 0.5642407 0.5875491 注: MA係数の符号が, arima()の符号とは反対 Table 6.1: パラメータ推定値 2.5 % 97.5 % d 0.4909382 0.4752637 0.5066127 ar 0.1133893 0.1016536 0.1251250 ma 0.5758949 0.5642407 0.5875491 → dの値, 非定常境界(d=0.5)に近い set.seed(101) m2_sim &lt;- fracdiff.sim(512, ar = coef(m2)[&quot;ar&quot;], ma = - coef(m2)[&quot;ma&quot;], d = coef(m2)[&quot;d&quot;]) plot(as.ts(m2_sim$series)) hurstexp(ew) # ハースト指数 ## Simple R/S Hurst estimation: 0.7368679 ## Corrected R over S Hurst exponent: 0.8540535 ## Empirical Hurst exponent: 0.9058207 ## Corrected empirical Hurst exponent: 0.8784372 ## Theoretical Hurst exponent: 0.5264069 "],["レジームスイッチングモデル.html", "7 レジーム・スイッチング・モデル 7.1 自己相関マルコフ・スイッチング・モデル (MSM-AR) 7.2 MSM-ARモデルの適合", " 7 レジーム・スイッチング・モデル 7.1 自己相関マルコフ・スイッチング・モデル (MSM-AR) パッケージMSwM 出所: Jose A. Sanchez-Espigares and Alberto Lopez-Moreno (2018). “MSwM examples.” サンプルデータ (example): シミュレーションにより生成 \\[y_{t}=\\begin{cases} 8+2x_{t}+\\epsilon_{t}^{(1)} &amp; \\epsilon_{t}^{(1)}\\sim N(0,1),\\quad t=101:150,181:250\\\\ 1+0.9y_{t-1}+\\epsilon_{t}^{(2)} &amp; \\epsilon_{t}^{(2)}\\sim N(0,0.5),\\quad t=1:100,151:180,251:300 \\end{cases}\\] ここで, \\(x_t\\)は外生変数 (共変量). library(MSwM) data(example) #vignette(&quot;examples&quot;) # マニュアル参照 plot(ts(example)) mod &lt;- lm(y ~ x, example) summary(mod) ## ## Call: ## lm(formula = y ~ x, data = example) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.8998 -0.8429 -0.0427 0.7420 4.0337 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 9.0486 0.1398 64.709 &lt; 2e-16 *** ## x 0.8235 0.2423 3.398 0.00077 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.208 on 298 degrees of freedom ## Multiple R-squared: 0.03731, Adjusted R-squared: 0.03408 ## F-statistic: 11.55 on 1 and 298 DF, p-value: 0.0007701 par(mfrow = c(1, 2)) qqnorm(resid(mod)); qqline(resid(mod), col = 2); acf(resid(mod)) par(mfrow = c(1, 1)) plot(resid(mod), type = &quot;l&quot;); abline(v=c(100, 150, 180, 250), lty = &quot;dotted&quot;, col = &quot;red&quot;) → 単回帰係数は有意. が, 残差は正規分布から乖離&amp; 有意な自己相関が持続 7.2 MSM-ARモデルの適合 - 関数msmFit(): Fitting Markov Switching Models using the EM algorithm - msmFit(object, k, sw, p, data, family, control) - k: numeric, レジーム数 - sw: a logical vector, スイッチングする係数の指定 ← intercept, sigmaはベクトルの両端に配置 - p: integer, AR次数 (デフォルト値=0) - p&gt;0のケース → the last values of sw have to contain the AR coefficients which have switching - family: モデルのクラス (It is only required when the object is a &quot;General linear formula&quot;) 正しいレジーム数 (\\(k=2\\)), 正しいモデル構造を想定出来たものとして推定した場合: mod.mswm &lt;- msmFit(mod, k = 2, p = 1, sw = c(T, T, T, T), control = list(parallel = F)) summary(mod.mswm) ## Markov Switching Model ## ## Call: msmFit(object = mod, k = 2, sw = c(T, T, T, T), p = 1, control = list(parallel = F)) ## ## AIC BIC logLik ## 637.0736 693.479 -312.5368 ## ## Coefficients: ## ## Regime 1 ## --------- ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept)(S) 0.8417 0.3017 2.7899 0.005272 ** ## x(S) -0.0533 0.1313 -0.4059 0.684816 ## y_1(S) 0.9208 0.0305 30.1902 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.5034675 ## Multiple R-squared: 0.8375 ## ## Standardized Residuals: ## Min Q1 Med Q3 Max ## -1.5153665313 -0.0906543528 0.0001873641 0.1656717255 1.2020899002 ## ## Regime 2 ## --------- ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept)(S) 8.6393 0.7118 12.1373 &lt; 2.2e-16 *** ## x(S) 1.8771 0.3104 6.0474 1.472e-09 *** ## y_1(S) -0.0569 0.0782 -0.7276 0.4669 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9339683 ## Multiple R-squared: 0.2408 ## ## Standardized Residuals: ## Min Q1 Med Q3 Max ## -2.31102193 -0.03317756 0.01034139 0.04509106 2.85245598 ## ## Transition probabilities: ## Regime 1 Regime 2 ## Regime 1 0.98499728 0.02290885 ## Regime 2 0.01500272 0.97709115 par(mfrow = c(1, 2)) qqnorm(mod.mswm@Fit@error[, 1]); qqline(mod.mswm@Fit@error[, 1], col = 2); qqnorm(mod.mswm@Fit@error[, 2]); qqline(mod.mswm@Fit@error[, 2],col = 2); plot(ts(mod.mswm@Fit@error)) → モデルは2つのレジームを良く検出: 共変量\\(x\\)が有意なレジーム, 1期前ラグ変数\\(y_{t-1}\\)が有意なレジームを推定. 状態推定確率の対角要素(同じレジームに留まる確率)は, いずれも約0.98 レジーム#1にある状態確率の推定値 (smoothed/ filtered probabilities) par(&quot;mar&quot; = c(1, 1, 1, 1)) plotProb(mod.mswm, which = 1) レジーム#2にある状態確率の推定値 (平滑化 (smoothed) 確率, フィルター化 (filtered) 確率) par(&quot;mar&quot; = c(1, 1, 1, 1)) plotProb(mod.mswm, which = 2) 指定のレジームにおける, 反応変数, 説明変数, 状態確率の推定値 (平滑化確率) の同時プロット par(&quot;mar&quot; = c(1, 1, 1, 1)) plotReg(mod.mswm, expl = &quot;x&quot;) "],["garchモデル.html", "8 GARCHモデル 8.1 GARCHモデル 8.2 GARCHモデルの推定 8.3 GARCHモデルのバリエーション 8.4 GARCHモデル: データ分析例 (Tsay, Ch4)", " 8 GARCHモデル 8.1 GARCHモデル 8.1.1 GARCH(p,q)モデルのサンプルパス生成 ボラティリティ方程式 \\[ \\sigma_t^2=\\omega+\\alpha_1 u_{t-1}^2+\\cdots+\\alpha_p u_{t-p}^2+\\beta_1 \\sigma_{t-1}^2+\\cdots+\\beta_q \\sigma_{t-q}^2\\] パッケージfGarch https://www.rdocumentation.org/packages/fGarch/versions/3042.83.2/topics/garchSim 8.1.1.1 ARCH(p)モデル パラメータ設定例 ボラティリティ方程式 (\\(p=2, q=0\\)): \\(\\omega=10^{-6}\\) (デフォルト), \\(\\alpha_1=0.5, \\alpha_2=0.1\\) Seedv &lt;- 10 Tlen &lt;- 300 library(fGarch) ## NOTE: Packages &#39;fBasics&#39;, &#39;timeDate&#39;, and &#39;timeSeries&#39; are no longer ## attached to the search() path when &#39;fGarch&#39; is attached. ## ## If needed attach them yourself in your R script by e.g., ## require(&quot;timeSeries&quot;) # ARCH(2) - use default omega and specify alpha, set beta=0! spec &lt;- garchSpec(model = list(alpha = c(0.5, 0.1), beta = 0)) set.seed(Seedv) x &lt;- garchSim(spec, n = Tlen) plot(x) par(mfrow = c(1, 2)) acf(x); pacf(x) acf(x ^ 2); pacf(x ^ 2) acf(abs(x)); pacf(abs(x)) 8.1.1.2 GARCH(p,q)モデル パラメータ設定例 ボラティリティ方程式 (次数\\(p=2,q=1\\)): \\(\\omega=10^{-6}\\)(デフォルト), \\(\\alpha_1=0.5, \\alpha_2=0.1, \\beta_1=0.35\\) spec &lt;- garchSpec(model = list(alpha = c(0.5, 0.1), beta = 0.35)) set.seed(Seedv) x &lt;- garchSim(spec, n = Tlen) plot(x) par(mfrow = c(1, 2)) acf(x); pacf(x) acf(x ^ 2); pacf(x ^ 2) acf(abs(x)); pacf(abs(x)) 8.1.1.3 ARMA(p’,q’)-GARCH(p,q)モデル パラメータ設定例 平均方程式 (\\(p&#39;=1,q&#39;=2\\)): \\(\\phi_1=0.7,\\theta_1=0.3,\\theta_2=-0.3\\) ボラティリティ方程式 (\\(p=1,q=1\\)): \\(\\omega=10^{-6}\\)(デフォルト), \\(\\alpha_1=0.5, \\alpha_2=0.1, \\beta_1=0.35\\) spec &lt;- garchSpec(model = list(ar = 0.7, ma = c(0.3, -0.3), alpha = c(0.5, 0.1), beta = 0.35)) set.seed(Seedv) x &lt;- garchSim(spec, n = Tlen) plot(x) par(mfrow = c(1, 2)) acf(x); pacf(x) acf(x ^ 2); pacf(x ^ 2) acf(abs(x)); pacf(abs(x)) 8.2 GARCHモデルの推定 garchFit関数: 1変量ARMA-GARCHモデルを適合 最尤法 ARMAおよびGARCHのモデル次数を引数に与える (デフォルト, GARCH(1,1)) 参考: 福地・伊藤(2011). Rによる計量経済分析. Sec.8.3 https://sites.google.com/site/econometricsr/ Tsay, Ch.4 data(&quot;dem2gbp&quot;) # DEM/GBP日次対数リターン,Jan/31984〜Dec/31/1991 (1974件) x &lt;- dem2gbp; Tlen = nrow(dem2gbp) ts.plot(x) par(mfrow = c(1, 2)) acf(x); pacf(x, main = &quot;dem2gbp&quot;) acf(x ^ 2, main = &quot;dem2gbp^2&quot;); pacf(x ^ 2, main = &quot;dem2gbp^2&quot;) ARCH効果の検定 例. ラグ\\(p=5\\)を指定した場合 library(&quot;FinTS&quot;) ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric ArchTest(unlist(x), lags = 5, demean = TRUE) # xは数値ベクトルであること ## ## ARCH LM-test; Null hypothesis: no ARCH effects ## ## data: unlist(x) ## Chi-squared = 182.43, df = 5, p-value &lt; 2.2e-16 → 帰無仮説 (\\(\\alpha_1= \\ldots=\\alpha_{5}=0\\)) を棄却 例. ARCH(5)モデルの適合 fit.ARCH &lt;- garchFit(formula = ~ garch(5, 0), data = x, trace = FALSE, include.mean = TRUE) summary(fit.ARCH) ## ## Title: ## GARCH Modelling ## ## Call: ## garchFit(formula = ~garch(5, 0), data = x, include.mean = TRUE, ## trace = FALSE) ## ## Mean and Variance Equation: ## data ~ garch(5, 0) ## &lt;environment: 0x117c7d840&gt; ## [data = x] ## ## Conditional Distribution: ## norm ## ## Coefficient(s): ## mu omega alpha1 alpha2 alpha3 alpha4 ## -0.00056115 0.07923997 0.24684994 0.14580250 0.08569016 0.08462344 ## alpha5 ## 0.12554184 ## ## Std. Errors: ## based on Hessian ## ## Error Analysis: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu -0.0005612 0.0087236 -0.064 0.94871 ## omega 0.0792400 0.0065155 12.162 &lt; 2e-16 *** ## alpha1 0.2468499 0.0344795 7.159 8.11e-13 *** ## alpha2 0.1458025 0.0332822 4.381 1.18e-05 *** ## alpha3 0.0856902 0.0261306 3.279 0.00104 ** ## alpha4 0.0846234 0.0280618 3.016 0.00256 ** ## alpha5 0.1255418 0.0286409 4.383 1.17e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Log Likelihood: ## -1118.366 normalized: -0.5665483 ## ## Description: ## Tue Mar 19 13:23:42 2024 by user: ## ## ## Standardised Residuals Tests: ## Statistic p-Value ## Jarque-Bera Test R Chi^2 817.1006 0 ## Shapiro-Wilk Test R W 0.9662239 0 ## Ljung-Box Test R Q(10) 10.09528 0.432174 ## Ljung-Box Test R Q(15) 17.39533 0.2957857 ## Ljung-Box Test R Q(20) 19.36413 0.498283 ## Ljung-Box Test R^2 Q(10) 11.95177 0.2882973 ## Ljung-Box Test R^2 Q(15) 20.96312 0.1380119 ## Ljung-Box Test R^2 Q(20) 23.97484 0.2434931 ## LM Arch Test R TR^2 11.548 0.4826274 ## ## Information Criterion Statistics: ## AIC BIC SIC HQIC ## 1.140189 1.160004 1.140164 1.147469 resd = residuals(fit.ARCH, standardize = T) par(mfcol = c(3, 1)) ts.plot(resd) acf(resd); pacf(resd ^ 2) 例. GARCH(1,1)モデルの適合 fit.GARCH &lt;- garchFit(formula = ~ garch(1, 1), data = x, trace = FALSE, include.mean = TRUE) summary(fit.GARCH) ## ## Title: ## GARCH Modelling ## ## Call: ## garchFit(formula = ~garch(1, 1), data = x, include.mean = TRUE, ## trace = FALSE) ## ## Mean and Variance Equation: ## data ~ garch(1, 1) ## &lt;environment: 0x120523ac0&gt; ## [data = x] ## ## Conditional Distribution: ## norm ## ## Coefficient(s): ## mu omega alpha1 beta1 ## -0.0061903 0.0107614 0.1531341 0.8059737 ## ## Std. Errors: ## based on Hessian ## ## Error Analysis: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu -0.006190 0.008462 -0.732 0.464447 ## omega 0.010761 0.002838 3.793 0.000149 *** ## alpha1 0.153134 0.026422 5.796 6.8e-09 *** ## beta1 0.805974 0.033381 24.144 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Log Likelihood: ## -1106.608 normalized: -0.5605916 ## ## Description: ## Tue Mar 19 13:23:43 2024 by user: ## ## ## Standardised Residuals Tests: ## Statistic p-Value ## Jarque-Bera Test R Chi^2 1059.851 0 ## Shapiro-Wilk Test R W 0.9622848 0 ## Ljung-Box Test R Q(10) 10.12141 0.4299066 ## Ljung-Box Test R Q(15) 17.04349 0.3162711 ## Ljung-Box Test R Q(20) 19.29764 0.5025619 ## Ljung-Box Test R^2 Q(10) 9.062555 0.5261773 ## Ljung-Box Test R^2 Q(15) 16.07769 0.3769072 ## Ljung-Box Test R^2 Q(20) 17.50715 0.6198388 ## LM Arch Test R TR^2 9.771217 0.6360238 ## ## Information Criterion Statistics: ## AIC BIC SIC HQIC ## 1.125236 1.136559 1.125228 1.129396 coef(fit.GARCH) ## mu omega alpha1 beta1 ## -0.006190317 0.010761385 0.153134063 0.805973739 resd &lt;- residuals(fit.GARCH, standardize = T) # 標準化残差 tail(resd, 10) ## [1] 1.39586970 -0.78568121 -0.11839598 0.34278825 -1.35175439 -1.06335161 ## [7] -0.06248781 -0.30590821 -0.65122451 1.57675563 par(mfcol = c(3, 1)) ts.plot(resd) acf(resd); pacf(resd ^ 2) → 残差の系列相関は概ね消滅, 非正規性残る→ 改善余地有り Tsay, Ch.4を参照のこと ボラティリティ推定値 (内挿予測) # ボラティリティ推定値 vola &lt;- volatility(fit.GARCH) # 標準偏差表示 tail(vola, 10) ## [1] 0.3659949 0.3983608 0.3919991 0.3673416 0.3492097 0.3783785 0.3885138 ## [8] 0.3640161 0.3456269 0.3388205 par(mfcol = c(2, 1)) ts.plot(x); ts.plot(vola) \\(l\\)期先予測 (外挿予測) # n.ahead(=20)期先予測 # nx:表示する観測データ数 par(mfrow = c(1,1)) # 収益率系列xの予測 (&amp; 95%信頼区間) x.pred &lt;- predict(fit.GARCH, n.ahead = 20, plot = TRUE, conf = .95, nx = 300) # ボラティリティのl期先予測値 (標準偏差表示) (v.pred &lt;- x.pred[, &quot;standardDeviation&quot;]) ## [1] 0.3833961 0.3895421 0.3953471 0.4008358 0.4060303 0.4109507 0.4156151 ## [8] 0.4200402 0.4242410 0.4282312 0.4320237 0.4356301 0.4390612 0.4423269 ## [15] 0.4454366 0.4483989 0.4512218 0.4539128 0.4564788 0.4589264 # プロット (実績値&amp;予測値) v.pred &lt;- c(vola[(Tlen - 99):Tlen], v.pred) #; length(v.pred) plot(v.pred, type = &quot;l&quot;, ylab = &quot;vola&quot;) abline(v = 101, col = &quot;red&quot;, lty = &quot;dotted&quot;) GARCH(1,1)モデルの\\(l\\)-期先ボラティリティ予測値 \\(T\\): データ期間 (モデル推定に使用) の最終時点 (予測の起点) \\(u_T, \\sigma_T^2\\): モデル適合による時点\\(T\\)における推定値 (所与) \\(l=1\\)のケース: \\[\\sigma_T^2 (1) = \\omega + \\alpha_1 u_T^2 + \\beta_1 \\sigma_T^2\\] \\(l\\ge2\\)のケース: \\[\\sigma_T^2 (l) = \\omega \\frac{1-(\\alpha_1 + \\beta_1)^{l-1}}{1-(\\alpha_1 + \\beta_1)} + (\\alpha_1 + \\beta_1)^{l-1} \\sigma_T^2 (1)\\] 参考: Tsay, pp.200-201 代替パッケージ: rugarch library(rugarch) ## Loading required package: parallel ## ## Attaching package: &#39;rugarch&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## sigma spec &lt;- ugarchspec(variance.model = list(garchOrder = c(1, 1))) # モデルの特定 fit.GARCH &lt;- ugarchfit(data = x, spec = spec) # モデルの適合 (x.pred &lt;- ugarchforecast(fitORspec = fit.GARCH, n.ahead = 20)) # 収益率系列, ボラティリティの予測 (→ x.predに2系列を格納) ## ## *------------------------------------* ## * GARCH Model Forecast * ## *------------------------------------* ## Model: sGARCH ## Horizon: 20 ## Roll Steps: 0 ## Out of Sample: 0 ## ## 0-roll forecast [T0=1975-05-29 09:00:00]: ## Series Sigma ## T+1 0.0272008 0.3850 ## T+2 -0.0197455 0.3915 ## T+3 -0.0005006 0.3976 ## T+4 -0.0083897 0.4034 ## T+5 -0.0051557 0.4088 ## T+6 -0.0064815 0.4139 ## T+7 -0.0059380 0.4187 ## T+8 -0.0061608 0.4233 ## T+9 -0.0060694 0.4276 ## T+10 -0.0061069 0.4317 ## T+11 -0.0060915 0.4356 ## T+12 -0.0060978 0.4393 ## T+13 -0.0060952 0.4427 ## T+14 -0.0060963 0.4460 ## T+15 -0.0060959 0.4492 ## T+16 -0.0060960 0.4522 ## T+17 -0.0060960 0.4550 ## T+18 -0.0060960 0.4577 ## T+19 -0.0060960 0.4603 ## T+20 -0.0060960 0.4627 # 別々に表示 #fitted(x.pred) # 収益率系列の予測値 #x.pred@forecast$seriesFor # 同 sigma(x.pred) # ボラティリティ(条件付標準偏差)の予測値 ## 1975-05-29 09:00:00 ## T+1 0.3850257 ## T+2 0.3915075 ## T+3 0.3976065 ## T+4 0.4033520 ## T+5 0.4087702 ## T+6 0.4138848 ## T+7 0.4187168 ## T+8 0.4232855 ## T+9 0.4276084 ## T+10 0.4317014 ## T+11 0.4355791 ## T+12 0.4392549 ## T+13 0.4427411 ## T+14 0.4460491 ## T+15 0.4491894 ## T+16 0.4521716 ## T+17 0.4550049 ## T+18 0.4576977 ## T+19 0.4602578 ## T+20 0.4626924 #x.pred@forecast$sigmaFor # 同 8.3 GARCHモデルのバリエーション パッケージrugarch - ugarchspec(): 一変量GARCHモデルの特定 (specification) - modelの選択肢: “sGARCH”, “fGARCH”, “eGARCH”, “gjrGARCH”, “apARCH”, “iGARCH”, “csGARCH” - submodelの選択肢(model=“fGARCH”の場合): “GARCH”, “TGARCH”, “AVGARCH”, “NGARCH”, “NAGARCH”, “APARCH”, “GJRGARCH”, “ALL- GARCH”. - distribution.mpdel(イノベーションに用いる条件付確率密度)の選択肢: &quot;norm&quot;, &quot;snorm&quot;(skew-normal), &quot;std&quot;(student t), &quot;sstd&quot;(skew-student), &quot;ged&quot;(generalized error), &quot;sged&quot;(skew-ged), &quot;nig&quot;(normal inverse gaussian), &quot;ghyp&quot;(Generalized Hyperbolic), &quot;jsu&quot;(Johnson&#39;s SU). - ugarchfit(): 一変量GARCHモデルの適合 - solverの選択肢: “nlminb”, “solnp”, “lbfgs”, “gosolnp”, “nloptr” or “hybrid” - 注): 本パッケージでは, &quot;NAGARCH (Nonlinear Asymmetric GARCH)&quot;, &quot;NGARCH (Nonlinear GARCH)&quot;である. Tsay, 4.12で紹介されているEngle and Ng (1993)の&quot;NGARCH (Nonsymmetric GARCH)&quot;は, 前者に対応する. https://www.rdocumentation.org/packages/rugarch/versions/1.4-4 データセット: spyreal - SPDR Standard and Poors 500 Open-Close Daily Return and Realized Kernel Volatility - SPDR(スパイダー) S\\&amp;P500インデックス: 始値-終値(open-close)リターン, 実現カーネル(realized kernel)ボラティリティ. - 期間: 2002-01-02 〜 2008-08-29 - Reference: Hansen, P. R., Huang, Z., and Shek, H. H. (2012). Realized GARCH: a joint model for returns and realized measures of volatility. Journal of Applied Econometrics, 27(6), 877–906. library(rugarch) ## Loading required package: parallel ## ## Attaching package: &#39;rugarch&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## sigma data(spyreal) head(spyreal) ## SPY_OC SPY_RK ## 2002-01-02 0.0051151007 0.010044750 ## 2002-01-03 0.0101514981 0.005342828 ## 2002-01-04 0.0009369278 0.007978535 ## 2002-01-07 -0.0097245499 0.005772834 ## 2002-01-08 -0.0033463500 0.006452759 ## 2002-01-09 -0.0078317023 0.007684824 8.3.1 IARCH(1,1) spec1 &lt;- ugarchspec( variance.model = list(model = &quot;iGARCH&quot;, garchOrder = c(1, 1)), mean.model = list(armaOrder = c(0, 0), include.mean = TRUE), distribution.model = &quot;norm&quot;, fixed.pars = list(omega = 0)) # 平均方程式にARMA(1,1)の場合: mean.model=list(armaOrder = c(1, 1) mod_igarch &lt;- ugarchfit(spec = spec1, data = spyreal[, 1], solver = &#39;hybrid&#39;) mod_igarch ## ## *---------------------------------* ## * GARCH Model Fit * ## *---------------------------------* ## ## Conditional Variance Dynamics ## ----------------------------------- ## GARCH Model : iGARCH(1,1) ## Mean Model : ARFIMA(0,0,0) ## Distribution : norm ## ## Optimal Parameters ## ------------------------------------ ## Estimate Std. Error t value Pr(&gt;|t|) ## mu -0.000028 0.000177 -0.15908 0.8736 ## omega 0.000000 NA NA NA ## alpha1 0.043186 0.006677 6.46763 0.0000 ## beta1 0.956814 NA NA NA ## ## Robust Standard Errors: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu -0.000028 0.000212 -0.13345 0.893837 ## omega 0.000000 NA NA NA ## alpha1 0.043186 0.010297 4.19426 0.000027 ## beta1 0.956814 NA NA NA ## ## LogLikelihood : 5630.331 ## ## Information Criteria ## ------------------------------------ ## ## Akaike -6.7730 ## Bayes -6.7664 ## Shibata -6.7730 ## Hannan-Quinn -6.7705 ## ## Weighted Ljung-Box Test on Standardized Residuals ## ------------------------------------ ## statistic p-value ## Lag[1] 5.479 0.019252 ## Lag[2*(p+q)+(p+q)-1][2] 8.207 0.005702 ## Lag[4*(p+q)+(p+q)-1][5] 10.148 0.008436 ## d.o.f=0 ## H0 : No serial correlation ## ## Weighted Ljung-Box Test on Standardized Squared Residuals ## ------------------------------------ ## statistic p-value ## Lag[1] 0.07752 0.7807 ## Lag[2*(p+q)+(p+q)-1][5] 0.87181 0.8880 ## Lag[4*(p+q)+(p+q)-1][9] 1.85043 0.9221 ## d.o.f=2 ## ## Weighted ARCH LM Tests ## ------------------------------------ ## Statistic Shape Scale P-Value ## ARCH Lag[3] 0.9841 0.500 2.000 0.3212 ## ARCH Lag[5] 1.3879 1.440 1.667 0.6223 ## ARCH Lag[7] 2.0139 2.315 1.543 0.7144 ## ## Nyblom stability test ## ------------------------------------ ## Joint Statistic: 0.1404 ## Individual Statistics: ## mu 0.02297 ## alpha1 0.08852 ## ## Asymptotic Critical Values (10% 5% 1%) ## Joint Statistic: 0.61 0.749 1.07 ## Individual Statistic: 0.35 0.47 0.75 ## ## Sign Bias Test ## ------------------------------------ ## t-value prob sig ## Sign Bias 1.24939 0.2117 ## Negative Sign Bias 0.07504 0.9402 ## Positive Sign Bias 0.78468 0.4328 ## Joint Effect 5.84998 0.1191 ## ## ## Adjusted Pearson Goodness-of-Fit Test: ## ------------------------------------ ## group statistic p-value(g-1) ## 1 20 40.09 0.0031807 ## 2 30 58.61 0.0009158 ## 3 40 63.78 0.0073916 ## 4 50 83.13 0.0016808 ## ## ## Elapsed time : 0.01914406 8.3.2 GJR-GARCH(1,1) spec2 &lt;- ugarchspec( variance.model = list(model = &quot;gjrGARCH&quot;, garchOrder = c(1, 1)), mean.model = list(armaOrder = c(0, 0), include.mean = TRUE), distribution.model = &quot;norm&quot;) mod_gjr &lt;- ugarchfit(spec = spec2, data = spyreal[, 1], solver = &#39;hybrid&#39;) mod_gjr ## ## *---------------------------------* ## * GARCH Model Fit * ## *---------------------------------* ## ## Conditional Variance Dynamics ## ----------------------------------- ## GARCH Model : gjrGARCH(1,1) ## Mean Model : ARFIMA(0,0,0) ## Distribution : norm ## ## Optimal Parameters ## ------------------------------------ ## Estimate Std. Error t value Pr(&gt;|t|) ## mu -0.000235 0.000166 -1.410892 0.15828 ## omega 0.000001 0.000001 1.071102 0.28412 ## alpha1 0.000000 0.001536 0.000029 0.99998 ## beta1 0.946145 0.009443 100.195459 0.00000 ## gamma1 0.090962 0.015265 5.958717 0.00000 ## ## Robust Standard Errors: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu -0.000235 0.000398 -0.590324 0.554973 ## omega 0.000001 0.000003 0.176169 0.860161 ## alpha1 0.000000 0.067909 0.000001 0.999999 ## beta1 0.946145 0.079992 11.827974 0.000000 ## gamma1 0.090962 0.024658 3.688997 0.000225 ## ## LogLikelihood : 5665.74 ## ## Information Criteria ## ------------------------------------ ## ## Akaike -6.8120 ## Bayes -6.7957 ## Shibata -6.8120 ## Hannan-Quinn -6.8059 ## ## Weighted Ljung-Box Test on Standardized Residuals ## ------------------------------------ ## statistic p-value ## Lag[1] 5.697 0.016993 ## Lag[2*(p+q)+(p+q)-1][2] 7.483 0.008869 ## Lag[4*(p+q)+(p+q)-1][5] 8.806 0.018531 ## d.o.f=0 ## H0 : No serial correlation ## ## Weighted Ljung-Box Test on Standardized Squared Residuals ## ------------------------------------ ## statistic p-value ## Lag[1] 3.883 0.04878 ## Lag[2*(p+q)+(p+q)-1][5] 5.237 0.13523 ## Lag[4*(p+q)+(p+q)-1][9] 6.736 0.22230 ## d.o.f=2 ## ## Weighted ARCH LM Tests ## ------------------------------------ ## Statistic Shape Scale P-Value ## ARCH Lag[3] 0.1657 0.500 2.000 0.6840 ## ARCH Lag[5] 0.4472 1.440 1.667 0.8991 ## ARCH Lag[7] 1.9375 2.315 1.543 0.7306 ## ## Nyblom stability test ## ------------------------------------ ## Joint Statistic: 292.4172 ## Individual Statistics: ## mu 0.04326 ## omega 55.96148 ## alpha1 0.22053 ## beta1 0.17934 ## gamma1 0.19934 ## ## Asymptotic Critical Values (10% 5% 1%) ## Joint Statistic: 1.28 1.47 1.88 ## Individual Statistic: 0.35 0.47 0.75 ## ## Sign Bias Test ## ------------------------------------ ## t-value prob sig ## Sign Bias 0.9606 0.3369 ## Negative Sign Bias 0.8427 0.3995 ## Positive Sign Bias 0.6544 0.5129 ## Joint Effect 2.4783 0.4792 ## ## ## Adjusted Pearson Goodness-of-Fit Test: ## ------------------------------------ ## group statistic p-value(g-1) ## 1 20 37.13 0.007635 ## 2 30 53.67 0.003532 ## 3 40 68.35 0.002521 ## 4 50 83.07 0.001704 ## ## ## Elapsed time : 0.1131709 8.3.3 APARCH spec3 &lt;- ugarchspec( variance.model = list(model = &quot;apARCH&quot;, garchOrder = c(1, 1)), mean.model = list(armaOrder = c(0, 0), include.mean = TRUE), distribution.model = &quot;std&quot;) # 一般誤差分布使用の場合: distribution.model=&quot;ged&quot;) mod_aparch &lt;- ugarchfit(spec = spec3, data = spyreal[, 1], solver = &#39;hybrid&#39;) mod_aparch ## ## *---------------------------------* ## * GARCH Model Fit * ## *---------------------------------* ## ## Conditional Variance Dynamics ## ----------------------------------- ## GARCH Model : apARCH(1,1) ## Mean Model : ARFIMA(0,0,0) ## Distribution : std ## ## Optimal Parameters ## ------------------------------------ ## Estimate Std. Error t value Pr(&gt;|t|) ## mu -0.000125 0.000172 -0.72685 0.467320 ## omega 0.000027 0.000032 0.84129 0.400187 ## alpha1 0.041590 0.012433 3.34503 0.000823 ## beta1 0.951150 0.008932 106.49292 0.000000 ## gamma1 1.000000 0.000767 1303.38424 0.000000 ## delta 1.226669 0.100403 12.21741 0.000000 ## shape 15.225663 4.931263 3.08758 0.002018 ## ## Robust Standard Errors: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu -0.000125 NaN NaN NaN ## omega 0.000027 NaN NaN NaN ## alpha1 0.041590 NaN NaN NaN ## beta1 0.951150 NaN NaN NaN ## gamma1 1.000000 NaN NaN NaN ## delta 1.226669 NaN NaN NaN ## shape 15.225663 NaN NaN NaN ## ## LogLikelihood : 5675.851 ## ## Information Criteria ## ------------------------------------ ## ## Akaike -6.8217 ## Bayes -6.7989 ## Shibata -6.8218 ## Hannan-Quinn -6.8133 ## ## Weighted Ljung-Box Test on Standardized Residuals ## ------------------------------------ ## statistic p-value ## Lag[1] 5.897 0.015171 ## Lag[2*(p+q)+(p+q)-1][2] 7.942 0.006704 ## Lag[4*(p+q)+(p+q)-1][5] 9.441 0.012796 ## d.o.f=0 ## H0 : No serial correlation ## ## Weighted Ljung-Box Test on Standardized Squared Residuals ## ------------------------------------ ## statistic p-value ## Lag[1] 4.402 0.0359 ## Lag[2*(p+q)+(p+q)-1][5] 5.693 0.1061 ## Lag[4*(p+q)+(p+q)-1][9] 7.269 0.1777 ## d.o.f=2 ## ## Weighted ARCH LM Tests ## ------------------------------------ ## Statistic Shape Scale P-Value ## ARCH Lag[3] 0.03822 0.500 2.000 0.8450 ## ARCH Lag[5] 0.17688 1.440 1.667 0.9709 ## ARCH Lag[7] 1.85908 2.315 1.543 0.7471 ## ## Nyblom stability test ## ------------------------------------ ## Joint Statistic: NaN ## Individual Statistics: ## mu 0.06082 ## omega 0.10137 ## alpha1 0.19391 ## beta1 0.19336 ## gamma1 NaN ## delta 0.12311 ## shape 0.58877 ## ## Asymptotic Critical Values (10% 5% 1%) ## Joint Statistic: 1.69 1.9 2.35 ## Individual Statistic: 0.35 0.47 0.75 ## ## Sign Bias Test ## ------------------------------------ ## t-value prob sig ## Sign Bias 0.9891 0.3227 ## Negative Sign Bias 1.4526 0.1465 ## Positive Sign Bias 0.8096 0.4183 ## Joint Effect 3.4471 0.3277 ## ## ## Adjusted Pearson Goodness-of-Fit Test: ## ------------------------------------ ## group statistic p-value(g-1) ## 1 20 29.34 0.060884 ## 2 30 41.07 0.067923 ## 3 40 46.78 0.183213 ## 4 50 81.80 0.002274 ## ## ## Elapsed time : 0.9073079 係数の推定値 coef(mod_aparch) ## mu omega alpha1 beta1 gamma1 ## -1.252560e-04 2.654268e-05 4.159036e-02 9.511501e-01 1.000000e+00 ## delta shape ## 1.226669e+00 1.522566e+01 #infocriteria(mod_aparch)[&quot;Akaike&quot;,] infocriteria(mod_aparch) ## ## Akaike -6.821722 ## Bayes -6.798912 ## Shibata -6.821757 ## Hannan-Quinn -6.813268 推定されたボラティリティ系列 #dat &lt;- spyreal[, 1] dat &lt;- spyreal dat$GARCH &lt;- sigma(mod_aparch) プロット library(ggplot2) library(xts) #library(zoo) autoplot(dat) # 時系列プロット # ボラティリティ推定値同士の比較 plot(as.vector(sqrt(dat$SPY_RK)), as.vector(dat$GARCH)) #plot(as.vector(dat$SPY_RK), as.vector(dat$GARCH)) Bootstrap法に基づく予測 GARCHモデルによるn期先予測には2種類の不確実性: 予測確率分布に起因するもの &amp; パラメータ推定誤差に起因するもの. Bootstrap法: 適合GARCHモデルの経験分布よりイノベーションをリサンプルすることで, 将来の時系列(series)と標準偏差(sigma)を生成. “full”法(Pascual et al (2006)): パラメータのシミュレーション分布を発生させることで, パラメータ不確実性を考慮(実行時間がかかる). “partial”法: 分布の不確実性のみ考慮 dat.pred &lt;- ugarchboot(mod_aparch, n.ahead = 30, method = &quot;Partial&quot;) #plot(dat.pred, which = &quot;all&quot;) # 時系列(リターン) plot(dat.pred, which = 2) # 標準偏差(ボラティリティ) plot(dat.pred, which = 3) # which=1は, &quot;full&quot;法のみ (Parameter Density Plots生成) dat.pred ## ## *-----------------------------------* ## * GARCH Bootstrap Forecast * ## *-----------------------------------* ## Model : apARCH ## n.ahead : 30 ## Bootstrap method: partial ## Date (T[0]): 2008-08-29 ## ## Series (summary): ## min q.25 mean q.75 max forecast[analytic] ## t+1 -0.038803 -0.007435 -0.000832 0.005447 0.033169 -0.000125 ## t+2 -0.038382 -0.007708 -0.000686 0.006119 0.029359 -0.000125 ## t+3 -0.032202 -0.005537 0.000292 0.006260 0.024769 -0.000125 ## t+4 -0.053668 -0.005972 -0.000486 0.005654 0.029930 -0.000125 ## t+5 -0.054807 -0.006105 -0.000234 0.006056 0.040059 -0.000125 ## t+6 -0.047361 -0.007001 -0.000755 0.005527 0.035188 -0.000125 ## t+7 -0.037725 -0.006071 0.000198 0.006128 0.028826 -0.000125 ## t+8 -0.073513 -0.006736 -0.000595 0.005979 0.024958 -0.000125 ## t+9 -0.042608 -0.005949 -0.000321 0.006382 0.038580 -0.000125 ## t+10 -0.038198 -0.005487 0.000401 0.006646 0.035592 -0.000125 ## ..................... ## ## Sigma (summary): ## min q0.25 mean q0.75 max forecast[analytic] ## t+1 0.010004 0.010004 0.010004 0.010004 0.010004 0.010004 ## t+2 0.009665 0.009665 0.010018 0.010206 0.013695 0.009985 ## t+3 0.009341 0.009341 0.010036 0.010383 0.014279 0.009967 ## t+4 0.009030 0.009184 0.009983 0.010424 0.016638 0.009948 ## t+5 0.008733 0.009056 0.009973 0.010505 0.016028 0.009930 ## t+6 0.008447 0.008974 0.009964 0.010628 0.020381 0.009912 ## t+7 0.008174 0.009015 0.009989 0.010717 0.019688 0.009894 ## t+8 0.007911 0.008887 0.009945 0.010610 0.018981 0.009877 ## t+9 0.007660 0.008828 0.009951 0.010692 0.025926 0.009859 ## t+10 0.007420 0.008720 0.009938 0.010567 0.024939 0.009842 ## ..................... 8.4 GARCHモデル: データ分析例 (Tsay, Ch4) 出所: http://faculty.chicagobooth.edu/ruey.tsay/teaching/introTS/ (一部改変) 8.4.1 必要な関数やデータセットの入手 教科書ホームページからのRコードへの直接の読み込みの方法 # 教科書著者(Tsay)の関数 fctns &lt;- c(&quot;igarch.r&quot;, &quot;garchm.r&quot;, &quot;egarch.r&quot;, &quot;ngarch.r&quot;, &quot;tgarch11.r&quot;, &quot;vold2m.r&quot;) url_home &lt;- &quot;https://faculty.chicagobooth.edu/-/media/faculty/ruey-s-tsay/teaching/introts/&quot; for (fct in fctns) { url_tmp &lt;- file.path(url_home, fct) source(url_tmp) } # データセット # 単一テキストファイルの入手 #library(rio) #url_tmp &lt;- &quot;https://faculty.chicagobooth.edu/-/media/faculty/ruey-s-tsay/teaching/introts/d-spy-0111.txt&quot; #rio::import(url_tmp) # 複数データセットの入った圧縮フォルダ(*.zip)からのデータセット入手 url_tmp &lt;- &quot;https://faculty.chicagobooth.edu/-/media/faculty/ruey-s-tsay/teaching/introts/ch4data.zip&quot; tmp &lt;- tempfile() tmp2 &lt;- tempfile() download.file(url_tmp, tmp) unzip(tmp, exdir = tmp2) dir(tmp2, recursive = T) ## [1] &quot;d-pg-0111.txt&quot; &quot;d-sp58010.txt&quot; &quot;d-spy-0111.txt&quot; &quot;d-useu9910.txt&quot; ## [5] &quot;m-ibmsp6709.txt&quot; &quot;m-intcsp7309.txt&quot; &quot;m-ko-6111.txt&quot; &quot;m-sp56710.txt&quot; setwd(tmp2) unlink(tmp) 8.4.2 Integrated GARCH モデル Tsay 4.7, pp.211–212 Igarch(): Estimation of a Gaussian IGARCH(1,1) model. - Igarch(rtn, include.mean = F, volcnt = F) - rtn: return series - include.mean: flag for the constant in the mean equation. - volcnt: flag for the constant term of the volatility equation. # source(&quot;Igarch.R&quot;) # da &lt;- read.table(&quot;m-intcsp7309.txt&quot;, header = T) head(da) # monthly returns of Intel &amp; S&amp;P, Jan73--Dec09 ## date intc sp ## 1 19730131 0.010050 -0.017111 ## 2 19730228 -0.139303 -0.037490 ## 3 19730330 0.069364 -0.001433 ## 4 19730430 0.086486 -0.040800 ## 5 19730531 -0.104478 -0.018884 ## 6 19730629 0.133333 -0.006575 intc &lt;- log(da$intc + 1) # monthly log-returns of Intel #mm &lt;- Igarch(intc, include.mean = T, volcnt = T) # --&gt; エラー #mm &lt;- Igarch(intc, include.mean = T) # --&gt; mu, beta #mm &lt;- Igarch(intc, volcnt = T) # --&gt; omega, beta mm &lt;- Igarch(intc) # --&gt; beta ## Estimates: 0.9217433 ## Maximized log-likehood: -301.412 ## ## Coefficient(s): ## Estimate Std. Error t value Pr(&gt;|t|) ## beta 0.9217433 0.0155534 59.2633 &lt; 2.22e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 names(mm) ## [1] &quot;par&quot; &quot;volatility&quot; mm$par # --&gt; beta ## beta ## 0.9217433 head(mm$volatility) ## [1] 0.1275742 0.1225127 0.1248833 0.1213562 0.1187993 0.1181597 summary(mm) ## Length Class Mode ## par 1 -none- numeric ## volatility 444 ts numeric –&gt; 教科書の記載と出力が相違(??) plot(mm$vola) 8.4.3 GARCH-M モデル Tsay 4.8, pp.213–214 garchM(): Estimation of a Gaussian GARCH(1, 1)-M model. - The program uses GARCH(1, 1) results as initial values. - garchM(rtn, type = 1) - rtn: return series - type = 1 for Variance-in-mean - = 2 for volatility-in-mean - = 3 for log(variance)-in-mean # source(&quot;garchM.R&quot;) # Compile the script y &lt;- intc * 100 # Intel stock returns in percentages garchM(y) ## Maximized log-likehood: -1731.983 ## ## Coefficient(s): ## Estimate Std. Error t value Pr(&gt;|t|) ## mu 0.07760995 1.33185168 0.05827 0.9535318 ## gamma 0.00794320 0.00925126 0.85861 0.3905577 ## omega 9.45891460 3.94127823 2.39996 0.0163968 * ## alpha 0.08761597 0.02673487 3.27722 0.0010484 ** ## beta 0.84933817 0.03949061 21.50734 &lt; 2.22e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 –&gt; 教科書の記載と出力が相違(??) リスクプレミアム(gamma), 有意でない garchM(y, type = 2) garchM(y, type = 3) ## 注: (最適化にnlminb()使用) 実行時間かかる –&gt; 通常のGARCH(1,1)へ #&gt; library(fGarch) #&gt; fGarch::garchFit(~ garch(1, 1), data = y, trace = F) #sp5 &lt;- scan(file = &quot;sp500.txt&quot;) # &lt;-- データ無. 誤植? da &lt;- read.table(&quot;m-intcsp7309.txt&quot;, header = T) # &lt;-- 代わりに使用. --&gt; 教科書と結果が異なる #head(da) # monthly returns of Intel &amp; S&amp;P, Jan73--Dec09 #da &lt;- read.table(&quot;m-ibmsp-2611.txt&quot;, header = T) #da &lt;- da[da$data&lt; = 20091231, ] #head(da) # monthly returns of IBM &amp; S&amp;P, Jan26--Sep11 sp5 &lt;- log(da$sp + 1) # monthly log-returns of S&amp;P # library(fGarch) sp5 &lt;- sp5 * 100 m2 &lt;- fGarch::garchFit(~ 1 + garch(1, 1), data = sp5, trace = F) summary(m2) ## ## Title: ## GARCH Modelling ## ## Call: ## fGarch::garchFit(formula = ~1 + garch(1, 1), data = sp5, trace = F) ## ## Mean and Variance Equation: ## data ~ 1 + garch(1, 1) ## &lt;environment: 0x10b2af110&gt; ## [data = sp5] ## ## Conditional Distribution: ## norm ## ## Coefficient(s): ## mu omega alpha1 beta1 ## 0.56091 0.72752 0.11733 0.85910 ## ## Std. Errors: ## based on Hessian ## ## Error Analysis: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu 0.56091 0.18951 2.960 0.003078 ** ## omega 0.72752 0.45322 1.605 0.108447 ## alpha1 0.11733 0.03157 3.717 0.000202 *** ## beta1 0.85910 0.03023 28.415 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Log Likelihood: ## -1289.671 normalized: -2.904663 ## ## Description: ## Tue Mar 19 13:23:56 2024 by user: ## ## ## Standardised Residuals Tests: ## Statistic p-Value ## Jarque-Bera Test R Chi^2 175.7289 0 ## Shapiro-Wilk Test R W 0.9655541 1.058946e-08 ## Ljung-Box Test R Q(10) 10.2148 0.4218546 ## Ljung-Box Test R Q(15) 12.76468 0.6204685 ## Ljung-Box Test R Q(20) 15.32494 0.7575226 ## Ljung-Box Test R^2 Q(10) 5.082012 0.8856326 ## Ljung-Box Test R^2 Q(15) 6.778888 0.9634974 ## Ljung-Box Test R^2 Q(20) 7.665347 0.9938604 ## LM Arch Test R TR^2 5.295219 0.9473846 ## ## Information Criterion Statistics: ## AIC BIC SIC HQIC ## 5.827345 5.864244 5.827184 5.841896 Estimate Std. Error t value Pr(&gt;|t|) mu 0.5609132 0.1895067 2.959859 0.0030778 omega 0.7275158 0.4532207 1.605213 0.1084469 alpha1 0.1173334 0.0315668 3.716989 0.0002016 beta1 0.8590999 0.0302342 28.414854 0.0000000 –&gt; GARCH(1,1), \\(\\alpha_1,\\beta_1\\)とも (5%) 有意. plot(m2, which = 1:13) –&gt; モデル診断, 正規性を除き, データによく適合 garchM(sp5) ## Maximized log-likehood: -1289.449 ## ## Coefficient(s): ## Estimate Std. Error t value Pr(&gt;|t|) ## mu 0.3467741 0.3849340 0.90087 0.36765941 ## gamma 0.0122469 0.0188799 0.64867 0.51655173 ## omega 0.7612141 0.4796083 1.58716 0.11247694 ## alpha 0.1163726 0.0317729 3.66264 0.00024963 *** ## beta 0.8581959 0.0308425 27.82511 &lt; 2.22e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 –&gt; リスクプレミアム (gamma), 有意でない (5%水準) –&gt; GARCH(1,1)を選択せよ 8.4.4 Exponential GARCH Model Tsay 4.9, pp.218–220 Egarch(): Estimation of an EGARCH(1, 1) model. Assume normal innovations - Egarch(rtn) # source(&quot;Egarch.R&quot;) # Compile R script da &lt;- read.table(&quot;m-ibmsp6709.txt&quot;, header = T) # Load data dim(da) # Check sample size of the data ## [1] 516 3 ibm &lt;- log(da$ibm + 1) # Take log transformation Box.test(ibm, lag = 12, type = &#39;Ljung&#39;) # Check serial correlations ## ## Box-Ljung test ## ## data: ibm ## X-squared = 7.4042, df = 12, p-value = 0.8298 m1 &lt;- Egarch(ibm) # Model fitting ## ## Estimation results of EGARCH(1,1) model: ## estimates: 0.006732418 -0.5983265 0.2176024 -0.4243194 0.9201499 ## std.errors: 0.002877668 0.2349184 0.05916505 0.1683056 0.03886579 ## t-ratio: 2.339539 -2.546954 3.677888 -2.521125 23.67506 names(m1) ## [1] &quot;residuals&quot; &quot;volatility&quot; 上記出力の見方: Estimation results of EGARCH(1, 1) model: estimates: 0.006732389 -0.5983263 0.217603 -0.4243245 0.92015 std.errors: 0.002877666 0.2349172 0.05916528 0.1683064 0.0388656 t-ratio: 2.339531 -2.546967 3.677882 -2.521144 23.67518 &lt;– mu, omega, alpha1, gamma1, beta1の順に出力 –&gt; 値が教科書(p.220)と若干相違 モデル診断 stresi &lt;- m1$residuals/m1$volatility # Obtain standardized residuals tdx &lt;- c(1:516)/12 + 1967 # Compute time index par(mfcol = c(2, 1)) # Plotting plot(tdx, ibm, xlab = &#39;year&#39;, ylab = &#39;logrtn&#39;, type = &#39;l&#39;) plot(tdx, stresi, xlab = &#39;year&#39;, ylab = &#39;stresi&#39;, type = &#39;l&#39;) Box.test(stresi, lag = 10, type = &#39;Ljung&#39;) # Model checking ## ## Box-Ljung test ## ## data: stresi ## X-squared = 5.2866, df = 10, p-value = 0.8712 Box.test(stresi, lag = 20, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: stresi ## X-squared = 20.983, df = 20, p-value = 0.3981 Box.test(stresi^2, lag = 10, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: stresi^2 ## X-squared = 5.0469, df = 10, p-value = 0.888 Box.test(stresi^2, lag = 20, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: stresi^2 ## X-squared = 14.261, df = 20, p-value = 0.817 –&gt; Tsay, “The model fits the data reasonably well.” 8.4.5 Threshold GARCH モデル Tsay 4.10, pp.222–223 Tgarch(): Estimation of TGARCH(1, 1) model with Gaussian or Student-t innovations - Tgarch11(x, cond.dist = &quot;norm&quot;) da &lt;- read.table(&quot;d-useu9910.txt&quot;, header = T) # daily USD/EUR, Jan/4/99--Aug/20/10 fx &lt;- log(da$rate) eu &lt;- diff(fx) * 100 # # source(&#39;Tgarch11.R&#39;) m1 &lt;- Tgarch11(eu) ## Log likelihood at MLEs: ## [1] -2731.832 ## ## Coefficient(s): ## Estimate Std. Error t value Pr(&gt;|t|) ## mu 0.012242608 0.010727558 1.14123 0.253774 ## omega 0.001275116 0.000618444 2.06181 0.039226 * ## alpha 0.022346602 0.005249249 4.25710 2.0709e-05 *** ## gam1 0.012518109 0.007062079 1.77258 0.076298 . ## beta 0.968719987 0.004357842 222.29351 &lt; 2.22e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 –&gt; muは有意でない volatility方程式の係数は有意 特に, レバレッジ効果 (H0: gamma&lt;=0, H1: gamma&gt;0)は(片側) 5%で有意. t=1.772, p=0.038. # モデル診断 names(m1) ## [1] &quot;residuals&quot; &quot;volatility&quot; &quot;par&quot; at &lt;- m1$residuals sigt &lt;- m1$volatility resi &lt;- at/sigt Box.test(resi, lag = 10, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: resi ## X-squared = 13.382, df = 10, p-value = 0.2031 Box.test(resi, lag = 20, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: resi ## X-squared = 22.873, df = 20, p-value = 0.2951 Box.test(resi^2, lag = 10, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: resi^2 ## X-squared = 12.893, df = 10, p-value = 0.2297 Box.test(resi^2, lag = 20, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: resi^2 ## X-squared = 27.229, df = 20, p-value = 0.1289 # 追加 plot(sigt, xlab = &#39;year&#39;, ylab = &#39;volatility&#39;, type = &#39;l&#39;) plot(resi, xlab = &#39;year&#39;, ylab = &#39;residuals&#39;, type = &#39;l&#39;) → 残差プロット, heavy tailの存在? 8.4.6 Asymmetric Power ARCH モデル Tsay 4.11, pp.224–225 m1 &lt;- fGarch::garchFit(~ 1 + aparch(1, 1), data = eu, trace = F) summary(m1) ## ## Title: ## GARCH Modelling ## ## Call: ## fGarch::garchFit(formula = ~1 + aparch(1, 1), data = eu, trace = F) ## ## Mean and Variance Equation: ## data ~ 1 + aparch(1, 1) ## &lt;environment: 0x11491beb0&gt; ## [data = eu] ## ## Conditional Distribution: ## norm ## ## Coefficient(s): ## mu omega alpha1 gamma1 beta1 delta ## 0.0127648 0.0015919 0.0313680 0.1135337 0.9689156 1.6743076 ## ## Std. Errors: ## based on Hessian ## ## Error Analysis: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu 0.0127648 0.0107626 1.186 0.2356 ## omega 0.0015919 0.0007226 2.203 0.0276 * ## alpha1 0.0313680 0.0053350 5.880 4.11e-09 *** ## gamma1 0.1135337 0.0711912 1.595 0.1108 ## beta1 0.9689156 0.0038404 252.293 &lt; 2e-16 *** ## delta 1.6743076 0.4057123 4.127 3.68e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Log Likelihood: ## -2731.172 normalized: -0.9324587 ## ## Description: ## Tue Mar 19 13:24:01 2024 by user: ## ## ## Standardised Residuals Tests: ## Statistic p-Value ## Jarque-Bera Test R Chi^2 50.2052 1.253364e-11 ## Shapiro-Wilk Test R W 0.9956711 1.608397e-07 ## Ljung-Box Test R Q(10) 13.37689 0.2033562 ## Ljung-Box Test R Q(15) 20.19634 0.1645295 ## Ljung-Box Test R Q(20) 22.84736 0.2963516 ## Ljung-Box Test R^2 Q(10) 13.15609 0.2150749 ## Ljung-Box Test R^2 Q(15) 16.58007 0.3445807 ## Ljung-Box Test R^2 Q(20) 27.44886 0.1231013 ## LM Arch Test R TR^2 14.35737 0.2784718 ## ## Information Criterion Statistics: ## AIC BIC SIC HQIC ## 1.869014 1.881269 1.869006 1.873428 m1 ## ## Title: ## GARCH Modelling ## ## Call: ## fGarch::garchFit(formula = ~1 + aparch(1, 1), data = eu, trace = F) ## ## Mean and Variance Equation: ## data ~ 1 + aparch(1, 1) ## &lt;environment: 0x11491beb0&gt; ## [data = eu] ## ## Conditional Distribution: ## norm ## ## Coefficient(s): ## mu omega alpha1 gamma1 beta1 delta ## 0.0127648 0.0015919 0.0313680 0.1135337 0.9689156 1.6743076 ## ## Std. Errors: ## based on Hessian ## ## Error Analysis: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu 0.0127648 0.0107626 1.186 0.2356 ## omega 0.0015919 0.0007226 2.203 0.0276 * ## alpha1 0.0313680 0.0053350 5.880 4.11e-09 *** ## gamma1 0.1135337 0.0711912 1.595 0.1108 ## beta1 0.9689156 0.0038404 252.293 &lt; 2e-16 *** ## delta 1.6743076 0.4057123 4.127 3.68e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Log Likelihood: ## -2731.172 normalized: -0.9324587 ## ## Description: ## Tue Mar 19 13:24:01 2024 by user: Estimate Std. Error t value Pr(&gt;|t|) mu 0.0127648 0.0107626 1.186042 0.2356059 omega 0.0015919 0.0007226 2.203001 0.0275947 alpha1 0.0313680 0.0053350 5.879685 0.0000000 gamma1 0.1135337 0.0711912 1.594772 0.1107632 beta1 0.9689156 0.0038404 252.292918 0.0000000 delta 1.6743076 0.4057123 4.126835 0.0000368 –&gt; モデル診断, データに良く適合. delta = 1.67の解釈難. –&gt; delta = 2とは、有意に乖離していない(標準誤差0.406) –&gt; delta = 2 (TGARCH(1, 1))でも良い? m2 &lt;- fGarch::garchFit(~ 1 + aparch(1, 1), data = eu, delta = 2, include.delta = F, trace = F) summary(m2) ## ## Title: ## GARCH Modelling ## ## Call: ## fGarch::garchFit(formula = ~1 + aparch(1, 1), data = eu, delta = 2, ## include.delta = F, trace = F) ## ## Mean and Variance Equation: ## data ~ 1 + aparch(1, 1) ## &lt;environment: 0x113335568&gt; ## [data = eu] ## ## Conditional Distribution: ## norm ## ## Coefficient(s): ## mu omega alpha1 gamma1 beta1 ## 0.0122646 0.0012745 0.0282723 0.1100239 0.9687115 ## ## Std. Errors: ## based on Hessian ## ## Error Analysis: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu 0.0122646 0.0107289 1.143 0.2530 ## omega 0.0012745 0.0005752 2.216 0.0267 * ## alpha1 0.0282723 0.0038637 7.317 2.53e-13 *** ## gamma1 0.1100239 0.0649051 1.695 0.0900 . ## beta1 0.9687115 0.0039421 245.735 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Log Likelihood: ## -2731.85 normalized: -0.9326902 ## ## Description: ## Tue Mar 19 13:24:01 2024 by user: ## ## ## Standardised Residuals Tests: ## Statistic p-Value ## Jarque-Bera Test R Chi^2 49.97678 1.405009e-11 ## Shapiro-Wilk Test R W 0.9956803 1.655878e-07 ## Ljung-Box Test R Q(10) 13.38285 0.203047 ## Ljung-Box Test R Q(15) 20.29833 0.1607845 ## Ljung-Box Test R Q(20) 22.87265 0.2950909 ## Ljung-Box Test R^2 Q(10) 12.89586 0.229553 ## Ljung-Box Test R^2 Q(15) 16.55288 0.3462875 ## Ljung-Box Test R^2 Q(20) 27.24037 0.1286359 ## LM Arch Test R TR^2 14.29662 0.2821694 ## ## Information Criterion Statistics: ## AIC BIC SIC HQIC ## 1.868795 1.879007 1.868789 1.872472 plot(m2, which = 1:13) m2 ## ## Title: ## GARCH Modelling ## ## Call: ## fGarch::garchFit(formula = ~1 + aparch(1, 1), data = eu, delta = 2, ## include.delta = F, trace = F) ## ## Mean and Variance Equation: ## data ~ 1 + aparch(1, 1) ## &lt;environment: 0x113335568&gt; ## [data = eu] ## ## Conditional Distribution: ## norm ## ## Coefficient(s): ## mu omega alpha1 gamma1 beta1 ## 0.0122646 0.0012745 0.0282723 0.1100239 0.9687115 ## ## Std. Errors: ## based on Hessian ## ## Error Analysis: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu 0.0122646 0.0107289 1.143 0.2530 ## omega 0.0012745 0.0005752 2.216 0.0267 * ## alpha1 0.0282723 0.0038637 7.317 2.53e-13 *** ## gamma1 0.1100239 0.0649051 1.695 0.0900 . ## beta1 0.9687115 0.0039421 245.735 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Log Likelihood: ## -2731.85 normalized: -0.9326902 ## ## Description: ## Tue Mar 19 13:24:01 2024 by user: Estimate Std. Error t value Pr(&gt;|t|) mu 0.0122646 0.0107289 1.143134 0.2529831 omega 0.0012745 0.0005752 2.215693 0.0267125 alpha1 0.0282723 0.0038637 7.317487 0.0000000 gamma1 0.1100239 0.0649051 1.695150 0.0900469 beta1 0.9687115 0.0039421 245.735369 0.0000000 –&gt; m1と結果類似 8.4.7 Nonsymmetric GARCH モデル Tsay 4.12, pp.227–228 Ngarch(): Estimation of a non-symmertic GARCH, NGARCH(1, 1), model. - Assume normal innovations - Ngarch(rtn) da &lt;- read.table(&quot;d-useu9910.txt&quot;, header = T) fx &lt;- log(da$rate) eu &lt;- diff(fx) * 100 # source(&quot;Ngarch.R&quot;) m1 &lt;- Ngarch(eu) ## ## Estimation results of NGARCH(1,1) model: ## estimates: -0.001094043 0.002366721 0.9618047 0.02118565 0.7309616 ## std.errors: 0.01080893 0.000580552 0.006045803 0.003604727 0.2501548 ## t-ratio: -0.1012166 4.076674 159.0863 5.877186 2.922037 res &lt;- m1$residuals vol &lt;- m1$volatility resi &lt;- res / vol Box.test(resi, lag = 10, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: resi ## X-squared = 14.776, df = 10, p-value = 0.1404 Box.test(resi^2, lag = 10, type = &#39;Ljung&#39;) ## ## Box-Ljung test ## ## data: resi^2 ## X-squared = 12.943, df = 10, p-value = 0.2269 # Estimation results of NGARCH(1, 1) model: # estimates: -0.001094043 0.002366721 0.9618047 0.02118565 0.7309616 #std.errors: 0.01080893 0.000580552 0.006045803 0.003604727 0.2501548 # t-ratio: -0.1012166 4.076674 159.0863 5.877186 2.922037 # &lt;-- mu, beta0, beta1, beta2, thetaの順 –&gt; muを除いて(5%)有意 特に, レバレッジ効果(theta), t=2.92で(5%)有意 –&gt; 上記TGARCH(1, 1)の結果と同様 # 追加 plot(vol, xlab = &#39;year&#39;, ylab = &#39;volatility&#39;, type = &#39;l&#39;) plot(resi, xlab = &#39;year&#39;, ylab = &#39;residuals&#39;, type = &#39;l&#39;) → 両モデルは, 類似のvolatility推定値 8.4.8 代替的アプリーチ間の比較 Tsay 4.15.1, pp.234–235 (日次データから)月次ボラティリティの推定 “ルートT・ルール”の適用 da &lt;- read.table(&quot;d-sp58010.txt&quot;, header = T) x &lt;- da[, c(1:3, 9)] dim(x) ## [1] 7737 4 方法1: 日次対数リターン使用 (white noiseを仮定) # source(&quot;vold2m.R&quot;) ## Compile the script m1 &lt;- vold2m(x) names(m1) ## [1] &quot;volatility&quot; &quot;ndays&quot; v1 &lt;- m1$volatility cnt &lt;- m1$ndays cnt[1:5] ## [1] 20 20 21 21 21 方法2: 日次対数リターン使用 (MA過程を仮定) m2 &lt;- vold2m(x, ma = 1) # Use MA(1) dependence names(m2) ## [1] &quot;volatility&quot; &quot;ndays&quot; v2 &lt;- m2$volatility 月次データの使用 da1 &lt;- read.table(&quot;m-sp56710.txt&quot;, header = T) sp &lt;- log(da1[, 9]) sp5 &lt;- diff(sp) 方法3: GARCH(1,1)を月次対数リターンに適用 # library(fGarch) m3 &lt;- fGarch::garchFit(~ 1 + garch(1, 1), data = sp5, trace = F) summary(m3) ## ## Title: ## GARCH Modelling ## ## Call: ## fGarch::garchFit(formula = ~1 + garch(1, 1), data = sp5, trace = F) ## ## Mean and Variance Equation: ## data ~ 1 + garch(1, 1) ## &lt;environment: 0x10f231120&gt; ## [data = sp5] ## ## Conditional Distribution: ## norm ## ## Coefficient(s): ## mu omega alpha1 beta1 ## 5.3471e-03 9.3263e-05 1.1422e-01 8.4864e-01 ## ## Std. Errors: ## based on Hessian ## ## Error Analysis: ## Estimate Std. Error t value Pr(&gt;|t|) ## mu 5.347e-03 1.742e-03 3.069 0.002149 ** ## omega 9.326e-05 4.859e-05 1.919 0.054942 . ## alpha1 1.142e-01 3.003e-02 3.804 0.000142 *** ## beta1 8.486e-01 3.186e-02 26.634 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Log Likelihood: ## 899.7817 normalized: 1.717141 ## ## Description: ## Tue Mar 19 13:24:19 2024 by user: ## ## ## Standardised Residuals Tests: ## Statistic p-Value ## Jarque-Bera Test R Chi^2 172.5211 0 ## Shapiro-Wilk Test R W 0.9690782 4.639274e-09 ## Ljung-Box Test R Q(10) 11.17329 0.3441774 ## Ljung-Box Test R Q(15) 15.451 0.4194449 ## Ljung-Box Test R Q(20) 17.56469 0.61606 ## Ljung-Box Test R^2 Q(10) 5.466795 0.8578981 ## Ljung-Box Test R^2 Q(15) 7.031543 0.9567685 ## Ljung-Box Test R^2 Q(20) 8.200425 0.9904566 ## LM Arch Test R TR^2 5.62988 0.9335791 ## ## Information Criterion Statistics: ## AIC BIC SIC HQIC ## -3.419014 -3.386484 -3.419129 -3.406275 v3 &lt;- volatility(m3) v3 &lt;- v3[158:524] Estimate Std. Error t value Pr(&gt;|t|) mu 0.0053471 0.0017424 3.068779 0.0021494 omega 0.0000933 0.0000486 1.919333 0.0549423 alpha1 0.1142231 0.0300281 3.803878 0.0001424 beta1 0.8486414 0.0318635 26.633652 0.0000000 3つの方法の比較 v1 &lt;- ts(v1, frequency = 12, start = c(1980, 1)) v2 &lt;- ts(v2, frequency = 12, start = c(1980, 1)) v3 &lt;- ts(v3, frequency = 12, start = c(1980, 1)) max(v1, v2, v3) ## [1] 0.2870294 # # par(mfcol=c(3,1)) # plot(v1, xlab=&#39;year&#39;, ylab=&#39;vol&#39;, type=&#39;l&#39;, ylim=c(0,.3)) # title(main=&#39;(a) No correlations&#39;) # plot(v2, xlab=&#39;year&#39;, ylab=&#39;vol&#39;, type=&#39;l&#39;, ylim=c(0,.3)) # title(main=&#39;(b) Lag-1 correlation&#39;) # plot(v3, xlab=&#39;year&#39;, ylab=&#39;vol&#39;, type=&#39;l&#39;, ylim=c(0,.3)) # title(main=&#39;(c) GARCH(1,1)&#39;) plot(ts.intersect(v1, v2, v3)) "],["varモデル.html", "9 VARモデル 9.1 VARモデル 9.2 VAR解析 9.3 VAR解析 (データ分析例) 9.4 補足: 分散共分散行列のコレスキー分解", " 9 VARモデル 9.1 VARモデル 以下では, MTSパッケージ, varsパッケージを利用 https://www.rdocumentation.org/packages/MTS/versions/1.0 https://www.rdocumentation.org/packages/vars/versions/1.5-3 9.1.1 VAR(\\(p\\))モデルのシミュレーション MTS::VARMAsim()関数 (VARMA(\\(p,q\\))モデルのパス生成) VAR(2)モデル例: \\[Y_{1,t}=0.3 + 0.2 Y_{1,t-1} + 0.3 Y_{2,t-1} - 0.5 Y_{1,t-2} (+0 \\cdot Y_{2,t-2}) + \\epsilon_{1,t}\\] \\[Y_{2,t}=-0.3 -0.6 Y_{1,t-1} + 1.1 Y_{2,t-1} (+0 \\cdot Y_{1,t-2}) - 0.6 Y_{2,t-2} + \\epsilon_{2,t}\\] \\[ \\left[ \\begin{array}{r} \\epsilon_{1,t} \\\\ \\epsilon_{2,t} \\end{array} \\right] \\sim_{\\it i.i.d.} N \\Big(\\left[ \\begin{array}{r} 0 \\\\ 0 \\end{array} \\right], \\left[ \\begin{array}{rr} 4 &amp; 0.8 \\\\ 0.8 &amp; 1 \\end{array} \\right]\\Big) \\] 上記VAR(2)モデルのサンプルパスの生成 library(MTS) Nlen &lt;- 300 Seedv &lt;- 1 set.seed(Seedv) p0 &lt;- c(0.3, -0.3) # Phi0 (定数項) p1 &lt;- matrix(c(0.2, -0.6, 0.3, 1.1), 2, 2) # Phi1 (ラグ1のVAR係数行列) p2 &lt;- matrix(c(-0.5, 0, 0, -0.6), 2, 2) # Phi2 (ラグ2のVAR係数行列) Pmat &lt;- cbind(p1, p2) # VAR係数行列を重ねた行列 Sig &lt;- matrix(c(4, 0.8, 0.8, 1), 2, 2) # イノベーションの分散共分散行列 (正値定符号) Pmat; Sig ## [,1] [,2] [,3] [,4] ## [1,] 0.2 0.3 -0.5 0.0 ## [2,] -0.6 1.1 0.0 -0.6 ## [,1] [,2] ## [1,] 4.0 0.8 ## [2,] 0.8 1.0 ysim &lt;- VARMAsim(Nlen, arlags = 2, cnst = p0, phi = Pmat, sigma = Sig) Yt &lt;- ysim$series MTSplot(Yt) # 時系列プロット 生成パス\\(y_t\\)の標本自己共分散行列 対角成分: 各成分の自己相関 \\(\\hat{\\rho}_1(h), \\hat{\\rho}_2(h)\\) 非対角成分: \\(y^1_t,y^2_t\\)間のクロス相関 行列の(1,2)成分: \\(\\hat{\\rho}_{1,2}(h),\\,h\\ge0\\) 行列の(2,1)成分: \\(\\hat{\\rho}_{1,2}(h)\\equiv\\hat{\\rho}_{2,1}(-h), \\,h\\le0\\) acf(Yt) # 標本自己共分散行列 (2x2-行列) # acf()の出力結果の非対角成分の確認 # cor(Y1(t+h), Y2(t)) # h&gt;0 cor(Yt[2:Nlen, 1], Yt[1:(Nlen-1), 2]) # Y1(t+1) vs Y2(t) ## [1] -0.2491788 cor(Yt[3:Nlen, 1], Yt[1:(Nlen-2), 2]) # Y1(t+2) vs Y2(t) ## [1] 0.5855889 # h&lt;0 cor(Yt[1:(Nlen-1), 1], Yt[2:Nlen, 2]) # Y1(t) vs Y2(t+1) ## [1] -0.2269957 cor(Yt[1:(Nlen-2), 1], Yt[3:Nlen, 2]) # y1(t) vs Y2(t+2) ## [1] 0.2156902 9.1.2 VAR(\\(p\\))モデルの次数同定 分析者による最適なラグ次数の選択を支援 - MTS::VARorder()関数 - maxp: ラグ次数の最大値 (デフォルト=13) - 出力: BIC, HQ (Hannan and Quinn情報量規準), M(p), p-value (カイ二乗検定統計量 &amp; p値) VARorder(Yt, maxp = 10, output = T) ## selected order: aic = 2 ## selected order: bic = 2 ## selected order: hq = 2 ## Summary table: ## p AIC BIC HQ M(p) p-value ## [1,] 0 4.2159 4.2159 4.2159 0.0000 0.0000 ## [2,] 1 3.8924 3.9418 3.9122 100.3170 0.0000 ## [3,] 2 1.5169 1.6157 1.5564 683.4158 0.0000 ## [4,] 3 1.5299 1.6781 1.5892 3.8619 0.4250 ## [5,] 4 1.5434 1.7409 1.6224 3.6978 0.4484 ## [6,] 5 1.5325 1.7794 1.6313 10.4626 0.0333 ## [7,] 6 1.5548 1.8511 1.6734 1.2025 0.8777 ## [8,] 7 1.5575 1.9032 1.6958 6.5850 0.1595 ## [9,] 8 1.5799 1.9750 1.7381 1.1470 0.8867 ## [10,] 9 1.5896 2.0340 1.7674 4.6092 0.3298 ## [11,] 10 1.6099 2.1037 1.8075 1.7109 0.7887 - vars::VARselect()関数 - lag.max: ラグ次数の最大値 (デフォルト=10) - type: 確定的な(定数・トレンド)項の種類 &quot;const&quot;(定数項有), &quot;trend&quot;(トレンド有), &quot;both&quot;(定数項・トレンド共有), &quot;none&quot;(両方無) - 出力: AIC, HQ, SC (Schwarz情報量規準), FPE (forecast prediction error) library(vars) vars::VARselect(Yt, lag.max = 10, type = &quot;const&quot;) ## $selection ## AIC(n) HQ(n) SC(n) FPE(n) ## 2 2 2 2 ## ## $criteria ## 1 2 3 4 5 6 7 8 ## AIC(n) 3.907125 1.532547 1.546463 1.560866 1.550885 1.574122 1.577719 1.601096 ## HQ(n) 3.937546 1.583248 1.617444 1.652128 1.662427 1.705945 1.729823 1.773480 ## SC(n) 3.983054 1.659094 1.723629 1.788652 1.829289 1.903146 1.957362 2.031358 ## FPE(n) 49.755778 4.629985 4.694921 4.763133 4.715983 4.827081 4.844789 4.959798 ## 9 10 ## AIC(n) 1.611643 1.632857 ## HQ(n) 1.804307 1.845802 ## SC(n) 2.092524 2.164357 ## FPE(n) 5.012920 5.121076 9.1.3 VAR(\\(p\\))モデルの推定 最小2乗法によるパラメータ推定 - MTS::VAR()関数 - p: ラグ次数 - include.mean: 平均ベクトルを加える(推定する)か (デフォルト=T) - fixed: パラメータに制約を付与する論理値行列. 制約付推定 (主に有意でない推定値の除去) に使用 est.VAR1 &lt;- MTS::VAR(Yt, p = 2, output = T, include.mean = T, fixed = NULL) ## Constant term: ## Estimates: 0.7010694 -0.4390955 ## Std.Error: 0.2935926 0.1458662 ## AR coefficient matrix ## AR( 1 )-matrix ## [,1] [,2] ## [1,] -0.0928 0.0954 ## [2,] -0.0197 -0.0286 ## standard error ## [,1] [,2] ## [1,] 0.0575 0.0462 ## [2,] 0.0286 0.0230 ## AR( 2 )-matrix ## [,1] [,2] ## [1,] 0.105 0.402 ## [2,] -0.616 1.117 ## standard error ## [,1] [,2] ## [1,] 0.0575 0.0465 ## [2,] 0.0285 0.0231 ## ## Residuals cov-mtx: ## [,1] [,2] ## [1,] 4.4990390 0.8786783 ## [2,] 0.8786783 1.1105526 ## ## det(SSE) = 4.224344 ## AIC = 1.494197 ## BIC = 1.592965 ## HQ = 1.533724 - vars::VAR()関数 - p: ラグ次数 - type: 確定的な(定数・トレンド)項の種類 &quot;const&quot;(定数項有), &quot;trend&quot;(トレンド有), &quot;both&quot;(定数項・トレンド共有), &quot;none&quot;(両方無) - season: 中心化済の季節性ダミー変数の追加 (frequencyを表す整数を指定) - exogen: 外生変数の追加 - lag.max: ラグ次数の最大値 (ラグ次数選択において) - in: 情報量規準 (lag.maxを指定している場合) est.VAR2 &lt;- vars::VAR(Yt, p = 2, type = &quot;const&quot;) # 最小2乗法によるパラメータ推定 # type: &quot;const&quot;(定数項有), trend:(&quot;トレンド有&quot;), &quot;both&quot;, &quot;none&quot; summary(est.VAR2) ## ## VAR Estimation Results: ## ========================= ## Endogenous variables: y1, y2 ## Deterministic variables: const ## Sample size: 298 ## Log Likelihood: -1060.376 ## Roots of the characteristic polynomial: ## 0.9308 0.7541 0.7541 0.6891 ## Call: ## vars::VAR(y = Yt, p = 2, type = &quot;const&quot;) ## ## ## Estimation results for equation y1: ## =================================== ## y1 = y1.l1 + y2.l1 + y1.l2 + y2.l2 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## y1.l1 -0.09285 0.05751 -1.614 0.1075 ## y2.l1 0.09536 0.04624 2.062 0.0401 * ## y1.l2 0.10498 0.05745 1.827 0.0687 . ## y2.l2 0.40175 0.04645 8.648 3.49e-16 *** ## const 0.70107 0.29359 2.388 0.0176 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Residual standard error: 2.139 on 293 degrees of freedom ## Multiple R-Squared: 0.3636, Adjusted R-squared: 0.3549 ## F-statistic: 41.86 on 4 and 293 DF, p-value: &lt; 2.2e-16 ## ## ## Estimation results for equation y2: ## =================================== ## y2 = y1.l1 + y2.l1 + y1.l2 + y2.l2 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## y1.l1 -0.01967 0.02857 -0.688 0.49185 ## y2.l1 -0.02859 0.02297 -1.244 0.21435 ## y1.l2 -0.61604 0.02854 -21.583 &lt; 2e-16 *** ## y2.l2 1.11695 0.02308 48.395 &lt; 2e-16 *** ## const -0.43910 0.14587 -3.010 0.00284 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Residual standard error: 1.063 on 293 degrees of freedom ## Multiple R-Squared: 0.9232, Adjusted R-squared: 0.9222 ## F-statistic: 880.9 on 4 and 293 DF, p-value: &lt; 2.2e-16 ## ## ## ## Covariance matrix of residuals: ## y1 y2 ## y1 4.5758 0.8937 ## y2 0.8937 1.1295 ## ## Correlation matrix of residuals: ## y1 y2 ## y1 1.0000 0.3931 ## y2 0.3931 1.0000 9.1.4 VAR(\\(p\\))モデル予測 - MTS::VARpred()関数 - h: 予測期間の長さ - orig: 予測の起点 (デフォルト=0, 最終のデータ点) - Out.level: 出力の詳細のコントロール (T/F) pred.VAR1 = VARpred(est.VAR1, h = 20, orig = 0, Out.level = F, output = T) ## orig 300 ## Forecasts at origin: 300 ## [,1] [,2] ## [1,] -1.6935 -4.659 ## [2,] -1.5588 -2.224 ## [3,] -1.4159 -4.506 ## [4,] -0.6541 -1.806 ## [5,] -1.3692 -4.535 ## [6,] -0.3984 -1.896 ## [7,] -1.4084 -4.599 ## [8,] -0.4105 -2.153 ## [9,] -1.4616 -4.638 ## [10,] -0.5135 -2.429 ## [11,] -1.4999 -4.640 ## [12,] -0.6321 -2.674 ## [13,] -1.5169 -4.609 ## [14,] -0.7383 -2.875 ## [15,] -1.5155 -4.556 ## [16,] -0.8252 -3.035 ## [17,] -1.5012 -4.491 ## [18,] -0.8939 -3.163 ## [19,] -1.4795 -4.423 ## [20,] -0.9480 -3.266 ## Standard Errors of predictions: ## [,1] [,2] ## [1,] 2.121 1.054 ## [2,] 2.129 1.056 ## [3,] 2.199 1.729 ## [4,] 2.205 1.734 ## [5,] 2.269 2.315 ## [6,] 2.270 2.333 ## [7,] 2.357 2.728 ## [8,] 2.358 2.760 ## [9,] 2.432 3.010 ## [10,] 2.435 3.050 ## [11,] 2.488 3.207 ## [12,] 2.493 3.249 ## [13,] 2.528 3.349 ## [14,] 2.535 3.388 ## [15,] 2.557 3.453 ## [16,] 2.564 3.486 ## [17,] 2.579 3.530 ## [18,] 2.586 3.557 ## [19,] 2.596 3.588 ## [20,] 2.602 3.609 ## Root mean square errors of predictions: ## [,1] [,2] ## [1,] 2.139 1.063 ## [2,] 2.154 1.061 ## [3,] 2.408 2.994 ## [4,] 2.226 1.751 ## [5,] 2.460 3.586 ## [6,] 2.275 2.391 ## [7,] 2.616 3.717 ## [8,] 2.359 2.859 ## [9,] 2.656 3.698 ## [10,] 2.444 3.174 ## [11,] 2.649 3.664 ## [12,] 2.510 3.378 ## [13,] 2.636 3.650 ## [14,] 2.557 3.508 ## [15,] 2.628 3.653 ## [16,] 2.587 3.591 ## [17,] 2.626 3.667 ## [18,] 2.607 3.643 ## [19,] 2.627 3.683 ## [20,] 2.620 3.678 - predict()関数 (vars::VARの出力に対して適用) - n.ahead: 予測期間の長さ - ci: 予測信頼区間 pred.VAR2 = predict(est.VAR2, n.ahead = 10) plot(pred.VAR2) pred.VAR2$fcst ## $y1 ## fcst lower upper CI ## [1,] -1.6935489 -5.886138 2.499040 4.192589 ## [2,] -1.5588289 -5.766916 2.649258 4.208087 ## [3,] -1.4158594 -5.761805 2.930087 4.345946 ## [4,] -0.6541053 -5.012838 3.704628 4.358733 ## [5,] -1.3691744 -5.853357 3.115008 4.484182 ## [6,] -0.3983955 -4.885523 4.088732 4.487127 ## [7,] -1.4084408 -6.067917 3.251035 4.659476 ## [8,] -0.4104564 -5.070912 4.250000 4.660456 ## [9,] -1.4615648 -6.269351 3.346221 4.807786 ## [10,] -0.5135316 -5.326625 4.299561 4.813093 ## ## $y2 ## fcst lower upper CI ## [1,] -4.659151 -6.742164 -2.57613758 2.083013 ## [2,] -2.223532 -4.309952 -0.13711248 2.086420 ## [3,] -4.505606 -7.922276 -1.08893531 3.416670 ## [4,] -1.805711 -5.233098 1.62167648 3.427387 ## [5,] -4.534908 -9.110020 0.04020335 4.575112 ## [6,] -1.896451 -6.507997 2.71509585 4.611547 ## [7,] -4.598833 -9.990735 0.79306982 5.391903 ## [8,] -2.152730 -7.607556 3.30209602 5.454826 ## [9,] -4.638479 -10.588832 1.31187382 5.950353 ## [10,] -2.429372 -8.458542 3.59979824 6.029170 MTSパッケージは, 外生変数有りのVARXモデル, VMAモデル, さらには, 一般のVARMAモデルに対しても, 次数同定, モデル推定, 予測のための関数を用意. 9.2 VAR解析 VARモデルによる変数間の動学的関係性の分析 以下, MTSパッケージ, varsパッケージを利用 https://www.rdocumentation.org/packages/MTS/versions/1.0 https://www.rdocumentation.org/packages/vars/versions/1.5-3 9.2.1 VAR(\\(p\\))モデルの推定(復習) 以下では, シミュレーションデータを使用 MTSパッケージのVARsim関数でパスを生成 varパッケージのVARselect,VAR関数を使って, 次数同定およびモデル推定 \\[Y_{1,t}=1.0 + 0.6 Y_{1,t-1} + 0.1 Y_{2,t-1} + \\epsilon_{1,t}\\] \\[Y_{2,t}=-1.0 +0.5 Y_{1,t-1} + 0.7 Y_{2,t-1} + \\epsilon_{2,t}\\] \\[ \\left[ \\begin{array}{r} \\epsilon_{1,t} \\\\ \\epsilon_{2,t} \\end{array} \\right] \\sim_{\\it i.i.d.} N \\Big(\\left[ \\begin{array}{r} 0 \\\\ 0 \\end{array} \\right], \\left[ \\begin{array}{rr} 4 &amp; 1 \\\\ 1 &amp; 1 \\end{array} \\right]\\Big) \\] library(MTS) Nlen &lt;- 300 Seedv &lt;- 1 set.seed(Seedv) p0 &lt;- c(1, -1) # Phi0 (定数項) Pmat &lt;- matrix(c(0.6, 0.5, 0.1, 0.7), 2, 2) # Phi1 (ラグ1のVAR係数行列) Sig &lt;- matrix(c(4, 1, 1, 1), 2, 2) # イノベーションの分散共分散行列 (正値定符号) Pmat; Sig ## [,1] [,2] ## [1,] 0.6 0.1 ## [2,] 0.5 0.7 ## [,1] [,2] ## [1,] 4 1 ## [2,] 1 1 ysim &lt;- VARMAsim(Nlen, arlags = 1, cnst = p0, phi = Pmat, sigma = Sig) Yt &lt;- ysim$series acf(Yt) # クロス相関 MTSplot(Yt) # 時系列プロット VAR(\\(p\\))モデルの次数同定 vars::VARselect()関数 library(vars) ## Loading required package: MASS ## Loading required package: strucchange ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric ## Loading required package: sandwich ## Loading required package: urca ## Loading required package: lmtest ## ## Attaching package: &#39;vars&#39; ## The following object is masked from &#39;package:MTS&#39;: ## ## VAR Yt &lt;- data.frame(Y1 = Yt[,1], Y2 = Yt[,2]) VARselect(Yt, lag.max = 5, type = &quot;const&quot;) ## $selection ## AIC(n) HQ(n) SC(n) FPE(n) ## 1 1 1 1 ## ## $criteria ## 1 2 3 4 5 ## AIC(n) 1.417189 1.432965 1.454790 1.471126 1.460469 ## HQ(n) 1.447216 1.483011 1.524855 1.561208 1.570570 ## SC(n) 1.492178 1.557947 1.629765 1.696094 1.735430 ## FPE(n) 4.125512 4.191134 4.283662 4.354299 4.308277 VAR(\\(p\\))モデルの推定 vars::VAR()関数 est_VAR1 &lt;- vars::VAR(Yt, p = 1, type = &quot;const&quot;) summary(est_VAR1) ## ## VAR Estimation Results: ## ========================= ## Endogenous variables: Y1, Y2 ## Deterministic variables: const ## Sample size: 299 ## Log Likelihood: -1051.693 ## Roots of the characteristic polynomial: ## 0.8123 0.3886 ## Call: ## vars::VAR(y = Yt, p = 1, type = &quot;const&quot;) ## ## ## Estimation results for equation Y1: ## =================================== ## Y1 = Y1.l1 + Y2.l1 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## Y1.l1 0.50728 0.06004 8.449 1.35e-15 *** ## Y2.l1 0.07759 0.04514 1.719 0.0866 . ## const 1.08864 0.17861 6.095 3.40e-09 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Residual standard error: 2.133 on 296 degrees of freedom ## Multiple R-Squared: 0.3322, Adjusted R-squared: 0.3277 ## F-statistic: 73.64 on 2 and 296 DF, p-value: &lt; 2.2e-16 ## ## ## Estimation results for equation Y2: ## =================================== ## Y2 = Y1.l1 + Y2.l1 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## Y1.l1 0.46669 0.03001 15.55 &lt;2e-16 *** ## Y2.l1 0.69357 0.02256 30.74 &lt;2e-16 *** ## const -0.97716 0.08928 -10.95 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Residual standard error: 1.066 on 296 degrees of freedom ## Multiple R-Squared: 0.9054, Adjusted R-squared: 0.9048 ## F-statistic: 1417 on 2 and 296 DF, p-value: &lt; 2.2e-16 ## ## ## ## Covariance matrix of residuals: ## Y1 Y2 ## Y1 4.551 1.096 ## Y2 1.096 1.137 ## ## Correlation matrix of residuals: ## Y1 Y2 ## Y1 1.000 0.482 ## Y2 0.482 1.000 上で推定されたVAR(1)モデルを使用して, VARモデルによる変数間の動学的関係性の分析を行う. 9.2.2 グレンジャーの因果性検定 - vars::causality()関数 - x: VAR()関数により生成された&#39;varest&#39;クラスのオブジェクト - cause: cause変数 (デフォルトは入力x$yの第1列の変数) - vcov.: 推定係数の共分散行列の指定 - boot: 棄却点を計算する際にwildブートストラップを使用するか否か(T/F) - boot.runs: boot=TRUEの場合のブートストラップの反復数 vars::causality(est_VAR1, cause = &quot;Y1&quot;) ## $Granger ## ## Granger causality H0: Y1 do not Granger-cause Y2 ## ## data: VAR object est_VAR1 ## F-Test = 241.8, df1 = 1, df2 = 592, p-value &lt; 2.2e-16 ## ## ## $Instant ## ## H0: No instantaneous causality between: Y1 and Y2 ## ## data: VAR object est_VAR1 ## Chi-squared = 56.374, df = 1, p-value = 5.995e-14 # VAR(1)の推定結果var1を用い, Y1に関するGranger因果性検定 vars::causality(est_VAR1, cause = &quot;Y2&quot;) ## $Granger ## ## Granger causality H0: Y2 do not Granger-cause Y1 ## ## data: VAR object est_VAR1 ## F-Test = 2.9555, df1 = 1, df2 = 592, p-value = 0.08611 ## ## ## $Instant ## ## H0: No instantaneous causality between: Y2 and Y1 ## ## data: VAR object est_VAR1 ## Chi-squared = 56.374, df = 1, p-value = 5.995e-14 # 同, Y2に関するGranger因果性検定 9.2.3 インパルス応答 直交インパルス応答 - vars::irf()関数 - x: VAR()関数により生成された&#39;varest&#39;クラスのオブジェクト等 - impulse: インパルス変数 (デフォルト=全変数) - response: 応答変数 (デフォルト=全変数) - n.ahead: 将来区間の長さ - ortho: 直交インパルス応答か (デフォルト=T) - cumulative: 累積インパルス応答か (デフォルト=F) - boot: インパルス応答係数のブートストラップ誤差バンド計算の有無 (T/F) - ci: bootstrap誤差バンドの信頼区間 - runs: bootstrap回数 # vars::irf()関数 (ortho = T (デフォルト)) ip1 &lt;- vars::irf(est_VAR1, impulse = c(&quot;Y1&quot;), response = c(&quot;Y1&quot;, &quot;Y2&quot;), n.ahead = 5, boot = T) ip2 &lt;- vars::irf(est_VAR1, impulse = c(&quot;Y2&quot;), response = c(&quot;Y1&quot;, &quot;Y2&quot;), n.ahead = 5, boot = T) plot(ip1) plot(ip2) # 破線は信頼区間 # ip1; ip2 非直交インパルス応答 # vars::irf()関数 (ortho = F) ip1 &lt;- vars::irf(est_VAR1, impulse = c(&quot;Y1&quot;), response = c(&quot;Y1&quot;, &quot;Y2&quot;), ortho = F, n.ahead = 5, boot = T) ip2 &lt;- vars::irf(est_VAR1, impulse = c(&quot;Y2&quot;), response = c(&quot;Y1&quot;, &quot;Y2&quot;), ortho = F, n.ahead = 5, boot = T) plot(ip1) plot(ip2) # ip1; ip2 累積インパルス応答 ip1_cum &lt;- vars::irf(est_VAR1, impulse = c(&quot;Y1&quot;), response = c(&quot;Y1&quot;,&quot;Y2&quot;), n.ahead = 5, boot = TRUE, cumulative=T) ip2_cum &lt;- vars::irf(est_VAR1, impulse = c(&quot;Y2&quot;), response = c(&quot;Y2&quot;,&quot;Y1&quot;), n.ahead = 5, boot = TRUE, cumulative=T) plot(ip1_cum) plot(ip2_cum) 9.2.4 予測誤差分散分解 (forecast error variance decomposition) - vars::fevd()関数 - x: VAR()関数により生成された&#39;varest&#39;クラスのオブジェクト等 - n.ahead: 予測区間の長さ 直交化インパルス応答関数を使い, 第\\(j(=1,2)\\)変数の第\\(k(=1,2)\\)変数の\\(h(=1,\\ldots,10)\\)先予測誤差分散への寄与を評価 res_fevd &lt;- vars::fevd(est_VAR1, n.ahead = 10) # 10期先まで評価する plot(res_fevd) 9.3 VAR解析 (データ分析例) VARモデルによる変数間の動学的関係性の分析 事例1: ソフトバンク(9434) vs ソフトバンクグループ(9984) ソフトバンク(9434): 上場日 2018年12月19日 親会社ソフトバンクG (9984) 保有比率(%): 66.49 (2019.03), 67.13 (2020.03), 40.86 (2021.03), 40.68 (2022.03), 40.47 (2023.03) cf. https://www.buffett-code.com/company/9434/mainshareholder データをYahoo!ファイナンスより入手 library(quantmod) ## Loading required package: xts ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric ## Loading required package: TTR ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo s9984 &lt;- getSymbols(&#39;9984.T&#39;, from = &#39;2018-12-19&#39;, auto.assign = FALSE) s9434 &lt;- getSymbols(&#39;9434.T&#39;, from = &#39;2018-12-19&#39;, auto.assign = FALSE) s9984ret &lt;- diff(log(s9984$`9984.T.Adjusted`))[-1] s9434ret &lt;- diff(log(s9434$`9434.T.Adjusted`))[-1] sb &lt;- merge.xts(s9984ret, s9434ret, join = &quot;inner&quot;) colnames(sb) &lt;- c(&quot;s9984&quot;, &quot;s9434&quot;) 各変数の単位根検定 library(fUnitRoots) #unitrootTest(s9984, type = &quot;c&quot;, lags = 1) # type: &quot;nc&quot;, &quot;c&quot;, &quot;ct&quot; unitrootTest(s9984ret, type = &quot;c&quot;, lags = 1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## DF: -24.1724 ## P VALUE: ## t: &lt; 2.2e-16 ## n: 0.004015 ## ## Description: ## Tue Mar 19 13:24:26 2024 by user: unitrootTest(s9434ret, type = &quot;c&quot;, lags = 1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## DF: -26.8626 ## P VALUE: ## t: &lt; 2.2e-16 ## n: 0.002043 ## ## Description: ## Tue Mar 19 13:24:26 2024 by user: –&gt; 帰無仮説(\\(\\phi_1 = 1\\))を棄却 (単位根なし) 標本自己共分散行列 acf(sb) VARモデルの推定 以下, パッケージvarsを利用 VAR(p)モデルの次数の決定 library(vars) ## Loading required package: MASS ## Loading required package: strucchange ## Loading required package: sandwich ## Loading required package: urca ## ## Attaching package: &#39;urca&#39; ## The following objects are masked from &#39;package:fUnitRoots&#39;: ## ## punitroot, qunitroot, unitrootTable ## Loading required package: lmtest vars::VARselect(sb, lag.max = 5, type = &quot;const&quot;) # &quot;const&quot;(定数項有), trend:(&quot;トレンド有&quot;), &quot;both&quot;, &quot;none&quot; ## $selection ## AIC(n) HQ(n) SC(n) FPE(n) ## 3 1 1 3 ## ## $criteria ## 1 2 3 4 5 ## AIC(n) -1.643869e+01 -1.643943e+01 -1.644225e+01 -1.643847e+01 -1.643377e+01 ## HQ(n) -1.642957e+01 -1.642423e+01 -1.642096e+01 -1.641111e+01 -1.640032e+01 ## SC(n) -1.641440e+01 -1.639896e+01 -1.638558e+01 -1.636562e+01 -1.634472e+01 ## FPE(n) 7.257189e-08 7.251791e-08 7.231421e-08 7.258771e-08 7.292995e-08 –&gt; AIC, FPEでは3, HQ, SCでは1が最適 VAR(1)モデルの推定 (OLS推定) var1 &lt;- vars::VAR(sb, p = 1, type = &quot;const&quot;) summary(var1) ## ## VAR Estimation Results: ## ========================= ## Endogenous variables: s9984, s9434 ## Deterministic variables: const ## Sample size: 1276 ## Log Likelihood: 6862.691 ## Roots of the characteristic polynomial: ## 0.05326 0.02519 ## Call: ## vars::VAR(y = sb, p = 1, type = &quot;const&quot;) ## ## ## Estimation results for equation s9984: ## ====================================== ## s9984 = s9984.l1 + s9434.l1 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## s9984.l1 0.0496790 0.0283889 1.750 0.080369 . ## s9434.l1 -0.2628371 0.0769794 -3.414 0.000659 *** ## const 0.0007830 0.0007646 1.024 0.305972 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Residual standard error: 0.02727 on 1273 degrees of freedom ## Multiple R-Squared: 0.01002, Adjusted R-squared: 0.008469 ## F-statistic: 6.445 on 2 and 1273 DF, p-value: 0.001641 ## ## ## Estimation results for equation s9434: ## ====================================== ## s9434 = s9984.l1 + s9434.l1 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## s9984.l1 -0.0010189 0.0105446 -0.097 0.9230 ## s9434.l1 -0.0216096 0.0285928 -0.756 0.4499 ## const 0.0005877 0.0002840 2.069 0.0387 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Residual standard error: 0.01013 on 1273 degrees of freedom ## Multiple R-Squared: 0.0004966, Adjusted R-squared: -0.001074 ## F-statistic: 0.3162 on 2 and 1273 DF, p-value: 0.7289 ## ## ## ## Covariance matrix of residuals: ## s9984 s9434 ## s9984 7.434e-04 5.359e-05 ## s9434 5.359e-05 1.026e-04 ## ## Correlation matrix of residuals: ## s9984 s9434 ## s9984 1.0000 0.1941 ## s9434 0.1941 1.0000 –&gt; 2式とも, 9984_{t-1}の係数, 有意でない. 一方, 9434_{t-1} → 9984_tの係数, 有意 インパルス応答 直交化インパルス応答 # s9434 --&gt; 将来のs9434, s9984の変動を調べる ip &lt;- vars::irf(var1, impulse = c(&quot;s9434&quot;), response = c(&quot;s9434&quot;, &quot;s9984&quot;), n.ahead = 5, boot = TRUE) #ip &lt;- vars::irf(var1, impulse = c(&quot;s9984&quot;), response = c(&quot;s9984&quot;, &quot;s9434&quot;), # n.ahead = 5, boot = TRUE) # ortho = T (デフォルト): 直交化インパルス応答; ortho = F: 非直交化インパルス応答 # boot = T: ブートストラップ法により, 信頼区間計算 # cumulative = T: 累積インパルス応答. デフォルトはF. plot(ip) # 破線は信頼区間 ip ## ## Impulse response coefficients ## $s9434 ## s9984 s9434 ## [1,] 0.000000e+00 9.934972e-03 ## [2,] -2.611279e-03 -2.146906e-04 ## [3,] -7.329705e-05 7.299999e-06 ## [4,] -5.560034e-06 -8.306776e-08 ## [5,] -2.543836e-07 7.460163e-09 ## [6,] -1.459833e-08 9.797972e-11 ## ## ## Lower Band, CI= 0.95 ## $s9434 ## s9984 s9434 ## [1,] 0.000000e+00 9.047026e-03 ## [2,] -4.097388e-03 -8.047203e-04 ## [3,] -3.571343e-04 -3.789797e-05 ## [4,] -4.534169e-05 -1.010509e-05 ## [5,] -5.041347e-06 -3.345487e-08 ## [6,] -6.671873e-07 -1.447435e-07 ## ## ## Upper Band, CI= 0.95 ## $s9434 ## s9984 s9434 ## [1,] 0.000000e+00 1.051754e-02 ## [2,] -1.192981e-03 2.542106e-04 ## [3,] 1.804617e-04 1.109926e-04 ## [4,] 8.330418e-06 5.170280e-06 ## [5,] 2.751357e-06 1.352219e-06 ## [6,] 6.816589e-09 1.071261e-07 ip_2 &lt;- vars::irf(var1, impulse = c(&quot;s9984&quot;), response = c(&quot;s9984&quot;, &quot;s9434&quot;), n.ahead = 5, boot = TRUE) plot(ip_2) ip_2 ## ## Impulse response coefficients ## $s9984 ## s9984 s9434 ## [1,] 2.726604e-02 1.965598e-03 ## [2,] 8.379176e-04 -7.025704e-05 ## [3,] 6.009305e-05 6.644732e-07 ## [4,] 2.810714e-06 -7.558764e-08 ## [5,] 1.595007e-07 -1.230412e-09 ## [6,] 8.247229e-09 -1.359261e-10 ## ## ## Lower Band, CI= 0.95 ## $s9984 ## s9984 s9434 ## [1,] 2.561755e-02 1.164346e-03 ## [2,] -3.310400e-04 -6.023888e-04 ## [3,] -1.301899e-04 -2.775886e-05 ## [4,] -6.945228e-06 -4.470805e-06 ## [5,] -3.291207e-07 -3.428406e-07 ## [6,] -1.715936e-08 -4.074790e-08 ## ## ## Upper Band, CI= 0.95 ## $s9984 ## s9984 s9434 ## [1,] 2.936719e-02 2.772684e-03 ## [2,] 2.291153e-03 4.995545e-04 ## [3,] 2.692598e-04 2.512513e-05 ## [4,] 2.655630e-05 1.233068e-06 ## [5,] 3.277015e-06 1.484908e-07 ## [6,] 3.592029e-07 9.431941e-09 非直交化インパルス応答 ip_3 &lt;- vars::irf(var1, impulse = c(&quot;s9434&quot;), response = c(&quot;s9434&quot;, &quot;s9984&quot;), ortho = F, n.ahead = 5, boot = TRUE) plot(ip_3) ip_3 ## ## Impulse response coefficients ## $s9434 ## s9984 s9434 ## [1,] 0.000000e+00 1.000000e+00 ## [2,] -2.628371e-01 -2.160958e-02 ## [3,] -7.377680e-03 7.347780e-04 ## [4,] -5.596426e-04 -8.361147e-06 ## [5,] -2.560486e-05 7.508992e-07 ## [6,] -1.469388e-06 9.862103e-09 ## ## ## Lower Band, CI= 0.95 ## $s9434 ## s9984 s9434 ## [1,] 0.000000e+00 1.000000e+00 ## [2,] -4.398348e-01 -7.540637e-02 ## [3,] -3.000567e-02 -3.584218e-03 ## [4,] -4.144245e-03 -5.697960e-04 ## [5,] -4.355755e-04 -1.273188e-05 ## [6,] -5.799975e-05 -4.352428e-06 ## ## ## Upper Band, CI= 0.95 ## $s9434 ## s9984 s9434 ## [1,] 0.000000e+00 1.000000e+00 ## [2,] -1.310726e-01 3.797626e-02 ## [3,] 1.100301e-02 8.635003e-03 ## [4,] 4.578820e-04 3.804945e-04 ## [5,] 9.836484e-05 9.292837e-05 ## [6,] 6.906692e-07 9.447104e-06 累積インパルス応答 ip_cum &lt;- vars::irf(var1, impulse = c(&quot;s9434&quot;), response = c(&quot;s9434&quot;, &quot;s9984&quot;), n.ahead = 5, boot = TRUE, cumulative = T) plot(ip_cum) Grangerの因果性検定 vars::causality(var1, cause = &quot;s9434&quot;) # VAR(1)の推定結果var1を用い, 9434をcauseとするGranger因果性検定 ## $Granger ## ## Granger causality H0: s9434 do not Granger-cause s9984 ## ## data: VAR object var1 ## F-Test = 11.658, df1 = 1, df2 = 2546, p-value = 0.0006493 ## ## ## $Instant ## ## H0: No instantaneous causality between: s9434 and s9984 ## ## data: VAR object var1 ## Chi-squared = 46.32, df = 1, p-value = 1.004e-11 –&gt; 帰無仮説(因果性なし)棄却 → 9434をcauseとするGranger因果性の存在を示唆 vars::causality(var1, cause = &quot;s9984&quot;) ## $Granger ## ## Granger causality H0: s9984 do not Granger-cause s9434 ## ## data: VAR object var1 ## F-Test = 0.0093368, df1 = 1, df2 = 2546, p-value = 0.923 ## ## ## $Instant ## ## H0: No instantaneous causality between: s9984 and s9434 ## ## data: VAR object var1 ## Chi-squared = 46.32, df = 1, p-value = 1.004e-11 –&gt; 帰無仮説(因果性なし)棄却できず → 9984をcauseとするGranger因果性存在せず 一方、Grangerの瞬時因果性, 9984, 9434, いずれの方向も棄却できず → 存在を示唆 事例2: 米英日3株式市場 (S&amp;P500, FTSE, 日経平均) データをYahoo!ファイナンスより入手 library(vars) gspc &lt;- getSymbols(&#39;^GSPC&#39;, periodicity = &quot;monthly&quot;, from = &#39;1999-12-31&#39;, auto.assign = FALSE) ftse &lt;- getSymbols(&#39;^FTSE&#39;, periodicity = &quot;monthly&quot;, from = &#39;1999-12-31&#39;, auto.assign = FALSE) n225 &lt;- getSymbols(&#39;^N225&#39;, periodicity = &quot;monthly&quot;, from = &#39;1999-12-31&#39;, auto.assign = FALSE) us &lt;- diff(log(gspc$GSPC.Adjusted))[-1] uk &lt;- diff(log(ftse$FTSE.Adjusted))[-1] jp &lt;- diff(log(n225$N225.Adjusted))[-1] mkt &lt;- cbind(us, uk, jp) idx &lt;- complete.cases(mkt) # 欠損値(NA)のあるレコードの除去 mkt &lt;- mkt[idx] colnames(mkt) &lt;- c(&quot;us&quot;, &quot;uk&quot;, &quot;jp&quot;) #plot(cumsum(mkt), type = &quot;l&quot;, col = c(&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;), # main = &quot;Market indices: S&amp;P500 (black), FTSE (blue), NK225 (red)&quot;) VARモデルの推定 以下, 引き続きパッケージvarsを利用 3変量VAR(2)モデルを仮定した場合の推定 usukjp &lt;- data.frame(mkt$us, mkt$uk, mkt$jp) head(usukjp, 5) ## us uk jp ## 2000-02-01 -0.02031300 -0.005743495 0.02125795 ## 2000-03-01 0.09232375 0.048174179 0.01875144 ## 2000-04-01 -0.03127991 -0.033078382 -0.12354810 ## 2000-05-01 -0.02215875 0.005044624 -0.09575560 ## 2000-06-01 0.02365163 -0.007370510 0.06395117 var2usukjp &lt;- vars::VAR(usukjp, p = 2, type = &quot;const&quot;) #summary(var2usukjp) # 係数推定値 (値のみ） coef(var2usukjp) ## $us ## Estimate Std. Error t value Pr(&gt;|t|) ## us.l1 -0.090341857 0.106571856 -0.8477084 0.39732185 ## uk.l1 0.040663287 0.112961271 0.3599755 0.71913588 ## jp.l1 0.111782076 0.064612084 1.7300491 0.08471949 ## us.l2 -0.122579280 0.106949820 -1.1461383 0.25271303 ## uk.l2 0.017844501 0.113327245 0.1574599 0.87499546 ## jp.l2 0.045248516 0.064542508 0.7010653 0.48384237 ## const 0.004829407 0.002695441 1.7916946 0.07425782 ## ## $uk ## Estimate Std. Error t value Pr(&gt;|t|) ## us.l1 0.091258027 0.092783916 0.9835544 0.32618075 ## uk.l1 -0.147276479 0.098346688 -1.4975235 0.13537951 ## jp.l1 0.072261990 0.056252770 1.2845943 0.19999205 ## us.l2 -0.159359268 0.093112980 -1.7114614 0.08809941 ## uk.l2 0.098411558 0.098665313 0.9974281 0.31941487 ## jp.l2 -0.006916330 0.056192196 -0.1230835 0.90212899 ## const 0.000731126 0.002346713 0.3115532 0.75561112 ## ## $jp ## Estimate Std. Error t value Pr(&gt;|t|) ## us.l1 -0.029046164 0.131443516 -0.2209783 0.8252698 ## uk.l1 0.114126137 0.139324088 0.8191415 0.4133999 ## jp.l1 0.078003509 0.079691204 0.9788221 0.3285098 ## us.l2 -0.174284283 0.131909689 -1.3212394 0.1874964 ## uk.l2 0.069170348 0.139775473 0.4948676 0.6210803 ## jp.l2 0.078285957 0.079605390 0.9834253 0.3262441 ## const 0.002734374 0.003324501 0.8224914 0.4114946 # 係数推定値の行列表示 (t値や標準誤差は非表示) vars::Acoef(var2usukjp) # as a list of matrices ## [[1]] ## us.l1 uk.l1 jp.l1 ## us -0.09034186 0.04066329 0.11178208 ## uk 0.09125803 -0.14727648 0.07226199 ## jp -0.02904616 0.11412614 0.07800351 ## ## [[2]] ## us.l2 uk.l2 jp.l2 ## us -0.1225793 0.01784450 0.04524852 ## uk -0.1593593 0.09841156 -0.00691633 ## jp -0.1742843 0.06917035 0.07828596 vars::Bcoef(var2usukjp) # as a matrix ## us.l1 uk.l1 jp.l1 us.l2 uk.l2 jp.l2 ## us -0.09034186 0.04066329 0.11178208 -0.1225793 0.01784450 0.04524852 ## uk 0.09125803 -0.14727648 0.07226199 -0.1593593 0.09841156 -0.00691633 ## jp -0.02904616 0.11412614 0.07800351 -0.1742843 0.06917035 0.07828596 ## const ## us 0.004829407 ## uk 0.000731126 ## jp 0.002734374 次数\\(p\\)を選択する場合 VAR()関数によって, 情報量規準により最適な次数を選択 最大次数lag.max と採用する情報量規準icを指定 varusukjp &lt;- vars::VAR(usukjp, type = &quot;const&quot;, lag.max = 5, ic = &quot;AIC&quot;) summary(varusukjp) ## ## VAR Estimation Results: ## ========================= ## Endogenous variables: us, uk, jp ## Deterministic variables: const ## Sample size: 289 ## Log Likelihood: 1678.987 ## Roots of the characteristic polynomial: ## 0.1896 0.1151 0.1073 ## Call: ## vars::VAR(y = usukjp, type = &quot;const&quot;, lag.max = 5, ic = &quot;AIC&quot;) ## ## ## Estimation results for equation us: ## =================================== ## us = us.l1 + uk.l1 + jp.l1 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## us.l1 -0.085282 0.105258 -0.810 0.4185 ## uk.l1 0.033577 0.110884 0.303 0.7623 ## jp.l1 0.110404 0.064259 1.718 0.0869 . ## const 0.004685 0.002664 1.759 0.0797 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Residual standard error: 0.04482 on 285 degrees of freedom ## Multiple R-Squared: 0.01188, Adjusted R-squared: 0.00148 ## F-statistic: 1.142 on 3 and 285 DF, p-value: 0.3323 ## ## ## Estimation results for equation uk: ## =================================== ## uk = us.l1 + uk.l1 + jp.l1 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## us.l1 0.1065192 0.0917015 1.162 0.2464 ## uk.l1 -0.1706412 0.0966030 -1.766 0.0784 . ## jp.l1 0.0687816 0.0559827 1.229 0.2202 ## const 0.0002146 0.0023206 0.092 0.9264 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Residual standard error: 0.03905 on 285 degrees of freedom ## Multiple R-Squared: 0.01698, Adjusted R-squared: 0.006635 ## F-statistic: 1.641 on 3 and 285 DF, p-value: 0.18 ## ## ## Estimation results for equation jp: ## =================================== ## jp = us.l1 + uk.l1 + jp.l1 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## us.l1 -0.004337 0.129035 -0.034 0.973 ## uk.l1 0.091973 0.135932 0.677 0.499 ## jp.l1 0.074123 0.078774 0.941 0.348 ## const 0.002161 0.003265 0.662 0.509 ## ## ## Residual standard error: 0.05495 on 285 degrees of freedom ## Multiple R-Squared: 0.01467, Adjusted R-squared: 0.004295 ## F-statistic: 1.414 on 3 and 285 DF, p-value: 0.2388 ## ## ## ## Covariance matrix of residuals: ## us uk jp ## us 0.002009 0.001394 0.001625 ## uk 0.001394 0.001525 0.001247 ## jp 0.001625 0.001247 0.003019 ## ## Correlation matrix of residuals: ## us uk jp ## us 1.0000 0.7964 0.6598 ## uk 0.7964 1.0000 0.5813 ## jp 0.6598 0.5813 1.0000 # ic = AIC, HQ, SC, FPE # HQ: Hannan-Quinn 情報量規準, FPE: forecast prediction error 規準 –&gt; \\(p=1\\)を選択 推定されたVARモデルによる予測 predict(var2usukjp, n.ahead = 10, ci = 0.95) # 95%区間予測を 10期先まで ## $us ## fcst lower upper CI ## [1,] 0.003282172 -0.08432008 0.09088442 0.08760225 ## [2,] 0.004063165 -0.08408731 0.09221364 0.08815047 ## [3,] 0.004326015 -0.08408000 0.09273203 0.08840602 ## [4,] 0.004283614 -0.08412345 0.09269068 0.08840706 ## [5,] 0.004291569 -0.08411610 0.09269924 0.08840767 ## [6,] 0.004307492 -0.08410018 0.09271516 0.08840767 ## [7,] 0.004309571 -0.08409810 0.09271725 0.08840768 ## [8,] 0.004309751 -0.08409792 0.09271743 0.08840768 ## [9,] 0.004309633 -0.08409804 0.09271731 0.08840768 ## [10,] 0.004309696 -0.08409798 0.09271737 0.08840768 ## ## $uk ## fcst lower upper CI ## [1,] -0.0076188676 -0.08388741 0.06864967 0.07626854 ## [2,] 0.0017396953 -0.07510767 0.07858707 0.07684737 ## [3,] -0.0002900056 -0.07780745 0.07722744 0.07751744 ## [4,] 0.0008256711 -0.07670939 0.07836074 0.07753506 ## [5,] 0.0004354193 -0.07710552 0.07797636 0.07754094 ## [6,] 0.0006053572 -0.07693624 0.07814696 0.07754160 ## [7,] 0.0005465396 -0.07699517 0.07808825 0.07754171 ## [8,] 0.0005685887 -0.07697314 0.07811031 0.07754173 ## [9,] 0.0005597326 -0.07698200 0.07810146 0.07754173 ## [10,] 0.0005629745 -0.07697875 0.07810470 0.07754173 ## ## $jp ## fcst lower upper CI ## [1,] 0.002129055 -0.1059177 0.1101759 0.1080468 ## [2,] 0.002101278 -0.1067521 0.1109546 0.1088533 ## [3,] 0.002046450 -0.1071907 0.1112836 0.1092371 ## [4,] 0.002311943 -0.1069275 0.1115514 0.1092395 ## [5,] 0.002270713 -0.1069692 0.1115106 0.1092399 ## [6,] 0.002328074 -0.1069119 0.1115680 0.1092400 ## [7,] 0.002319872 -0.1069201 0.1115598 0.1092400 ## [8,] 0.002325930 -0.1069140 0.1115659 0.1092400 ## [9,] 0.002323840 -0.1069161 0.1115638 0.1092400 ## [10,] 0.002324638 -0.1069153 0.1115646 0.1092400 Granger因果性の検定 日本をcauseとする因果性 var3usukjp &lt;- vars::VAR(usukjp, p = 3, type = &quot;const&quot;) head(var3usukjp$y) # ## us uk jp ## 2000-02-01 -0.02031300 -0.005743495 0.02125795 ## 2000-03-01 0.09232375 0.048174179 0.01875144 ## 2000-04-01 -0.03127991 -0.033078382 -0.12354810 ## 2000-05-01 -0.02215875 0.005044624 -0.09575560 ## 2000-06-01 0.02365163 -0.007370510 0.06395117 ## 2000-07-01 -0.01647627 0.008297825 -0.10169496 vars::causality(var3usukjp, cause = &quot;jp&quot;) # jp --&gt; us, uk ## $Granger ## ## Granger causality H0: jp do not Granger-cause us uk ## ## data: VAR object var3usukjp ## F-Test = 0.78924, df1 = 6, df2 = 831, p-value = 0.5784 ## ## ## $Instant ## ## H0: No instantaneous causality between: jp and us uk ## ## data: VAR object var3usukjp ## Chi-squared = 87.861, df = 2, p-value &lt; 2.2e-16 –&gt; Gragnerの意味での因果性なし. 同時因果性あり 日英をcauseとする因果性 vars::causality(var3usukjp, cause = c(&quot;jp&quot;, &quot;uk&quot;)) # jp, uk --&gt; us ## $Granger ## ## Granger causality H0: uk jp do not Granger-cause us ## ## data: VAR object var3usukjp ## F-Test = 0.6525, df1 = 6, df2 = 831, p-value = 0.6881 ## ## ## $Instant ## ## H0: No instantaneous causality between: uk jp and us ## ## data: VAR object var3usukjp ## Chi-squared = 117.41, df = 2, p-value &lt; 2.2e-16 –&gt; Grangerの意味での因果性なし. 同時因果性あり - vars::causality() - causeを指定なし (デフォルト) では, 第1列の変数がcause - K変量VARモデルに対する因果性検定 (対応する係数にゼロ制約を課す) - ← 特定の2変量のみの因果性を調べる検定ではない 予測誤差分散分解 (forecast error variance decomposition) 直交化インパルス応答関数を使い, 第j変数の第k変数のh先予測誤差分散への寄与 # library(vars) var3_fevd &lt;- vars::fevd(var3usukjp, n.ahead = 10) # 10期先まで評価する plot(var3_fevd) varmkt &lt;- vars::VAR(mkt, p = 3, type = &quot;const&quot;) varmkt_fevd &lt;- vars::fevd(varmkt, n.ahead = 10) # 10期先まで評価する plot(varmkt_fevd) 変数の順番の影響の確認 分散分解 (変数の順序入れ替え) usjpuk &lt;- data.frame(mkt$us, mkt$jp, mkt$uk) cov(usukjp) ## us uk jp ## us 0.002007377 0.001385517 0.001624878 ## uk 0.001385517 0.001530028 0.001239255 ## jp 0.001624878 0.001239255 0.003023253 cov(usjpuk) ## us jp uk ## us 0.002007377 0.001624878 0.001385517 ## jp 0.001624878 0.003023253 0.001239255 ## uk 0.001385517 0.001239255 0.001530028 var3usjpuk &lt;- vars::VAR(usjpuk, p = 3, type = &quot;const&quot;) var3_fevd_2 &lt;- vars::fevd(var3usjpuk, n.ahead = 10) # 10期先まで評価する plot(var3_fevd_2) 直交インパルス応答 米国 → 他市場 (米国, 英国, 日本)の順序 vs (米国, 日本, 英国)の順序 # (us, uk, jp) ip1 &lt;- vars::irf(var3usukjp, impulse = c(&quot;us&quot;), n.ahead = 5, boot = TRUE) # ortho = T (デフォルト): 直交化インパルス応答; ortho = F: 非直交化インパルス応答 # boot = T: ブートストラップ法により, 信頼区間計算 # cumulative = T: 累積インパルス応答. デフォルトはF. plot(ip1) # # (us, jp, uk) ip2 &lt;- vars::irf(var3usjpuk, impulse = c(&quot;us&quot;), n.ahead = 5, boot = TRUE) plot(ip2) 日本 → 他市場 # (us, uk, jp) #ip3 &lt;- vars::irf(var3usukjp, impulse = c(&quot;uk&quot;), n.ahead = 5, boot = TRUE) ip3 &lt;- vars::irf(var3usukjp, impulse = c(&quot;jp&quot;), n.ahead = 5, boot = TRUE) plot(ip3) # (us, jp, uk) ip4 &lt;- vars::irf(var3usjpuk, impulse = c(&quot;jp&quot;), n.ahead = 5, boot = TRUE) plot(ip4) 確認: Choleski分解: \\(\\Sigma = P P&#39;\\) #chol(cov(usjpuk)) # 上三角行列P&#39; # (us, uk, jp) t(chol(cov(usukjp))) # 下三角行列P&#39; ## us uk jp ## us 0.04480376 0.000000000 0.00000000 ## uk 0.03092414 0.023952566 0.00000000 ## jp 0.03626655 0.004915674 0.04103445 # (us, jp, uk) t(chol(cov(usjpuk))) # 下三角行列P&#39; ## us jp uk ## us 0.04480376 0.00000000 0.00000000 ## jp 0.03626655 0.04132783 0.00000000 ## uk 0.03092414 0.00284900 0.02378253 (参考) Tsay氏作成パッケージMTS library(MTS) # &#39;vars&#39;との同時使用は避ける (VAR()関数が重複) var3 &lt;- MTS::VAR(usukjp, p = 3) # include.mean = T (デフォルト), VAR係数の最小2乗推定 MTS::GrangerTest(usukjp, p = 3) # include.mean = T (デフォルト) MTS::VARMAirf(Phi = var3$Phi, Sigma = var3$Sigma) # Theta = NULL (デフォルト): VMA係数行列 その他: Granger因果性検定の関数 パッケージlmtest - grangertest(): 2変量間のGranger因果性検定 - usage: grangertest(x, y, order = 1, na.action = na.omit, ...) #library(lmtest) data(ChickEgg) # mts, tsクラス plot(ChickEgg) lmtest::grangertest(egg ~ chicken, order = 3, data = ChickEgg) # → 有意でない ## Granger causality test ## ## Model 1: egg ~ Lags(egg, 1:3) + Lags(chicken, 1:3) ## Model 2: egg ~ Lags(egg, 1:3) ## Res.Df Df F Pr(&gt;F) ## 1 44 ## 2 47 -3 0.5916 0.6238 lmtest::grangertest(chicken ~ egg, order = 3, data = ChickEgg) # → 有意(1%) ## Granger causality test ## ## Model 1: chicken ~ Lags(chicken, 1:3) + Lags(egg, 1:3) ## Model 2: chicken ~ Lags(chicken, 1:3) ## Res.Df Df F Pr(&gt;F) ## 1 44 ## 2 47 -3 5.405 0.002966 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ccf(ChickEgg[, &quot;chicken&quot;], ChickEgg[, &quot;egg&quot;]) # 1: chicken, 2: egg パッケージNlinTS: 非線形時系列解析, 因果性検出 - causality.test(): 2変量間のGranger因果性検定 - usage: causality.test(ts1, ts2, lag, diff = FALSE) library (NlinTS) # 非線形時系列解析, 因果性検出. causality.test() ## Loading required package: Rcpp res1 &lt;- NlinTS::causality.test(ChickEgg[, &quot;egg&quot;], ChickEgg[, &quot;chicken&quot;], lag = 3) res2 &lt;- NlinTS::causality.test(ChickEgg[, &quot;chicken&quot;], ChickEgg[, &quot;egg&quot;], lag = 3) res1$summary() ## -------------------- ## Test summary ## -------------------- ## The lag parameter: p = 3 ## The Granger causality Index: GCI = 0.0395451 ## The value of the F-test: 0.591615 ## The p_value of the F-test: 0.623786 ## The critical value with 5% of risk:: 2.822 res2$summary() ## -------------------- ## Test summary ## -------------------- ## The lag parameter: p = 3 ## The Granger causality Index: GCI = 0.313731 ## The value of the F-test: 5.40498 ## The p_value of the F-test: 0.0029664 ## The critical value with 5% of risk:: 2.822 –&gt; 上のgrangertst()の結果と同一 パッケージMTS - GrangerTest(): p変量のGranger因果性検定 - usage: GrangerTest(X,p=1,include.mean=T,locInput=c(1)) library(MTS) ## ## Attaching package: &#39;MTS&#39; ## The following object is masked from &#39;package:vars&#39;: ## ## VAR ## The following object is masked from &#39;package:TTR&#39;: ## ## VMA EggChick &lt;- data.frame(egg = ChickEgg[, &quot;egg&quot;], chicken = ChickEgg[, &quot;chicken&quot;]) MTS::GrangerTest(EggChick, p = 3) # カイ2乗検定 (F値x3 〜 (漸近的に)Chisq(3)) ## Number of targeted zero parameters: 3 ## Chi-square test for Granger Causality and p-value: 1.774846 0.620424 ## Constant term: ## Estimates: 306.1473 133544.6 ## Std.Error: 132.5194 41073.51 ## AR coefficient matrix ## AR( 1 )-matrix ## [,1] [,2] ## [1,] 1.3 0.000 ## [2,] 76.6 0.292 ## standard error ## [,1] [,2] ## [1,] 0.143 0.000 ## [2,] 25.279 0.184 ## AR( 2 )-matrix ## [,1] [,2] ## [1,] -0.361 0.000 ## [2,] -47.078 0.445 ## standard error ## [,1] [,2] ## [1,] 0.234 0.000 ## [2,] 39.387 0.186 ## AR( 3 )-matrix ## [,1] [,2] ## [1,] 0.0042 0.00000 ## [2,] -35.9327 0.00407 ## standard error ## [,1] [,2] ## [1,] 0.141 0.000 ## [2,] 28.538 0.174 ## ## Residuals cov-mtx: ## [,1] [,2] ## [1,] 22800.12 1843210 ## [2,] 1843210.37 412998788 ## ## det(SSE) = 6.018998e+12 ## AIC = 29.75928 ## BIC = 30.09077 ## HQ = 29.88712 # MTS::GrangerTest(ChickEgg, p = 3) –&gt; 上のgrangertst()の結果とやや異なる 9.4 補足: 分散共分散行列のコレスキー分解 直交化インパルス応答や予測誤差分散分解では, 事前に外生性の高い順に変数を配置しておく必要がある. 直交化する際には, VAR(p)モデルの撹乱項の分散共分散行列に対してCholeskey分解が利用される. 分散共分散行列に対するコレスキー (Choleskey) 分解の計算例 以下, 簡単のため, VAR(p)モデルは使わない library(vars) ## Loading required package: MASS ## Loading required package: strucchange ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric ## Loading required package: sandwich ## Loading required package: urca ## Loading required package: lmtest library(quantmod) ## Loading required package: xts ## Loading required package: TTR ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.2 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.2 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.2 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.2 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ stringr::boundary() masks strucchange::boundary() ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::first() masks xts::first() ## ✖ dplyr::lag() masks stats::lag() ## ✖ dplyr::last() masks xts::last() ## ✖ dplyr::select() masks MASS::select() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors gspc &lt;- getSymbols(&#39;^GSPC&#39;, periodicity = &quot;monthly&quot;, from = &#39;1999-12-31&#39;, auto.assign = FALSE) ftse &lt;- getSymbols(&#39;^FTSE&#39;, periodicity = &quot;monthly&quot;, from = &#39;1999-12-31&#39;, auto.assign = FALSE) n225 &lt;- getSymbols(&#39;^N225&#39;, periodicity = &quot;monthly&quot;, from = &#39;1999-12-31&#39;, auto.assign = FALSE) us &lt;- diff(log(gspc$GSPC.Adjusted))[-1] uk &lt;- diff(log(ftse$FTSE.Adjusted))[-1] jp &lt;- diff(log(n225$N225.Adjusted))[-1] mkt &lt;- merge.xts(us, uk, jp, all = T) idx &lt;- complete.cases(mkt) # 欠損値(NA)のあるレコードの除去 mkt &lt;- mkt[idx] colnames(mkt) &lt;- c(&quot;us&quot;, &quot;uk&quot;, &quot;jp&quot;) plot(cumsum(mkt), type = &quot;l&quot;, col = c(&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;), main = &quot;Market indices: S&amp;P500 (black), FTSE (blue), NK225 (red)&quot;) 分散共分散行列\\({\\bf \\Sigma}\\)のCholeskey分解 \\[ {\\bf \\Sigma} = {\\bf P}{\\bf P&#39;} \\] 但し, \\({\\bf P}\\)は下三角行列. 米英日の日次収益率に対して分散共分散行列を計算 → Choleskey分解 # アメリカ、イギリス、日本市場 usukjp &lt;- data.frame(mkt$us, mkt$uk, mkt$jp) head(usukjp, 5) ## us uk jp ## 2000-02-01 -0.02031300 -0.005743495 0.02125795 ## 2000-03-01 0.09232375 0.048174179 0.01875144 ## 2000-04-01 -0.03127991 -0.033078382 -0.12354810 ## 2000-05-01 -0.02215875 0.005044624 -0.09575560 ## 2000-06-01 0.02365163 -0.007370510 0.06395117 # 分散共分散行列: Sigma cov_usukjp &lt;- cov(usukjp) %&gt;% print(digits = 4) ## us uk jp ## us 0.002007 0.001386 0.001625 ## uk 0.001386 0.001530 0.001239 ## jp 0.001625 0.001239 0.003023 # Choleskey分解: Sigma = PP&#39; P &lt;- chol(cov_usukjp) %&gt;% t() %&gt;% print(digits = 4) # 下三角行列P ## us uk jp ## us 0.04480 0.000000 0.00000 ## uk 0.03092 0.023953 0.00000 ## jp 0.03627 0.004916 0.04103 # Sigmaの復元 (確認用) P %*% t(P) %&gt;% print(digits = 4) ## us uk jp ## us 0.002007 0.001386 0.001625 ## uk 0.001386 0.001530 0.001239 ## jp 0.001625 0.001239 0.003023 米日英の分散共分散行列を計算 → Choleskey分解 # アメリカ、日本, 英国市場 usjpuk &lt;- data.frame(mkt$us, mkt$jp, mkt$uk) head(usjpuk, 5) ## us jp uk ## 2000-02-01 -0.02031300 0.02125795 -0.005743495 ## 2000-03-01 0.09232375 0.01875144 0.048174179 ## 2000-04-01 -0.03127991 -0.12354810 -0.033078382 ## 2000-05-01 -0.02215875 -0.09575560 0.005044624 ## 2000-06-01 0.02365163 0.06395117 -0.007370510 # 分散共分散行列: Sigma cov_usjpuk &lt;- cov(usjpuk) %&gt;% print(digits = 4) ## us jp uk ## us 0.002007 0.001625 0.001386 ## jp 0.001625 0.003023 0.001239 ## uk 0.001386 0.001239 0.001530 # Choleskey分解: Sigma = PP&#39; P &lt;- chol(cov_usjpuk) %&gt;% t() %&gt;% print(digits = 4) # 下三角行列P ## us jp uk ## us 0.04480 0.000000 0.00000 ## jp 0.03627 0.041328 0.00000 ## uk 0.03092 0.002849 0.02378 # Sigmaの復元 (確認用) P %*% t(P) %&gt;% print(digits = 4) ## us jp uk ## us 0.002007 0.001625 0.001386 ## jp 0.001625 0.003023 0.001239 ## uk 0.001386 0.001239 0.001530 "],["共和分分析誤差修正モデル.html", "10 共和分分析・誤差修正モデル 10.1 見せかけの回帰 10.2 共和分検定 10.3 誤差修正モデル: データ分析例 (Tsay, MTS, Ch5)", " 10 共和分分析・誤差修正モデル 10.1 見せかけの回帰 単位根検定で扱った内容の再掲 参考: 福地・伊藤, 10.1 Tlen &lt;- 300 Seedv &lt;- 1 set.seed(Seedv) w1 &lt;- rnorm(Tlen) w2 &lt;- rnorm(Tlen) x &lt;- cumsum(w1) y &lt;- cumsum(w2) matplot(cbind(x,y), type = &quot;l&quot;) reslm &lt;- lm(y ~ x) summary(reslm) ## ## Call: ## lm(formula = y ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -8.0778 -3.6190 0.0812 3.9438 8.6039 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.13230 0.55381 0.239 0.8114 ## x 0.16810 0.06713 2.504 0.0128 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 4.284 on 298 degrees of freedom ## Multiple R-squared: 0.02061, Adjusted R-squared: 0.01733 ## F-statistic: 6.272 on 1 and 298 DF, p-value: 0.0128 plot(x, y); abline(reslm, col = &quot;red&quot;) 残差に自己相関が残ることの確認 reslm_resid = resid(reslm) plot(reslm_resid, type = &quot;l&quot;) acf(reslm_resid) Durbin-Watson検定 Durbin-Watson統計量 回帰残差の系列相関の有無を検定 \\(DW \\approx 2(1-\\rho)\\). \\(0&lt;DW&lt;4\\). 無相関⇔ \\(DW=2\\) 見せかけの回帰の場合. \\(DW\\)が小さい傾向(正の系列相関) library(lmtest) ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric dwtest(reslm) ## ## Durbin-Watson test ## ## data: reslm ## DW = 0.060411, p-value &lt; 2.2e-16 ## alternative hypothesis: true autocorrelation is greater than 0 単位根検定のためのR関数 ADF検定: “tseries”内, adf.test(); “fUnitRoots”内, unitrootTest(), adfTest() Phillips-Perron検定: “urca”内, ur.pp(); “tseries”内, pp.test() KPSS検定: “urca”内, ur.kpss(); “tseries”内, kpss.test() 10.2 共和分検定 沖本, 問題6.3, p.144, を参考に4系列 \\({\\bf y}_t=(y_{1,t},y_{2,t},y_{3,t},y_{4,t})&#39;\\) を生成 \\(w_{1,t},w_{2,t}\\)は, 互いに独立な単位根過程 \\(u_{1,t},u_{2,t},u_{3,t},u_{4,t}\\)は互いに独立な定常過程. \\(w_{1,t},w_{2,t}\\)とも独立 \\[ \\left\\{ \\begin{split} y_{1,t} &amp;= w_{1,t}+u_{1,t} \\\\ y_{2,t} &amp;= 2 w_{1,t} + u_{1,t} \\\\ y_{3,t} &amp;= w_{2,t} + u_{3,t} \\\\ y_{4,t} &amp;= w_{1,t}+ 2 w_{2,t} + u_{4,t} \\end{split} \\right. \\] この時, 線形独立な共和分ベクトル \\(\\beta_1 = (1,-0.5,0,0)\\), \\(\\beta_2 = (1,0,2,-1)\\). それ以外の共和分ベクトルは\\(\\beta_1,\\beta_2\\)の線形和で表現される. 以下では, 全て正規乱数によりサンプルパス生成 (長さ=300) Tlen &lt;- 300 # 任意に変更可 Seedv &lt;- 10 # 任意に変更可 set.seed(Seedv) w1 &lt;- cumsum(rnorm(Tlen)) w2 &lt;- cumsum(rnorm(Tlen)) u1 &lt;- rnorm(Tlen); u2 &lt;- rnorm(Tlen) u3 &lt;- rnorm(Tlen); u4 &lt;- rnorm(Tlen) # y1 &lt;- w1 + u1 y2 &lt;- 2 * w1 + u2 y3 &lt;- w2 + u3 y4 &lt;- w1 + 2 * w2 + u4 # # beta1 = (1, -0.5, 0, 0) # beta2 = (1, 0, 2, -1) # ymat &lt;- cbind(y1, y2, y3, y4) matplot(ymat, type = &quot;l&quot;) 各成分が単位根過程 \\(I(1)\\) であることを確認 fUnitRoots::adfTest(y1) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -0.1277 ## P VALUE: ## 0.5756 ## ## Description: ## Tue Mar 19 13:24:36 2024 by user: fUnitRoots::adfTest(y2) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: 0.1048 ## P VALUE: ## 0.6497 ## ## Description: ## Tue Mar 19 13:24:36 2024 by user: fUnitRoots::adfTest(y3) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -0.1246 ## P VALUE: ## 0.5766 ## ## Description: ## Tue Mar 19 13:24:36 2024 by user: fUnitRoots::adfTest(y4) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -0.7516 ## P VALUE: ## 0.3768 ## ## Description: ## Tue Mar 19 13:24:36 2024 by user: 10.2.1 Engle-Grangerの方法 共和分検定 Philips-Ouliaris検定 - &#39;urca&#39;パッケージ内, ca.po関数 - demean (使用するランダムウォーク・モデルのトレンドの指定): &quot;none&quot;, &quot;const&quot;(定数項), &quot;trend&quot;(定数項+時間トレンド) - type (検定種類): &quot;Pu&quot;(デフォルト), &quot;Pz&quot; library(urca) test_po &lt;- ca.po(ymat[, 1:2], demean = &quot;const&quot;) summary(test_po) ## ## ######################################## ## # Phillips and Ouliaris Unit Root Test # ## ######################################## ## ## Test of type Pu ## detrending of series with constant only ## ## ## Call: ## lm(formula = z[, 1] ~ z[, -1]) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.6576 -0.7442 -0.0535 0.7229 3.7571 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.552717 0.180515 -3.062 0.0024 ** ## z[, -1] 0.485335 0.004978 97.500 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.114 on 298 degrees of freedom ## Multiple R-squared: 0.9696, Adjusted R-squared: 0.9695 ## F-statistic: 9506 on 1 and 298 DF, p-value: &lt; 2.2e-16 ## ## ## Value of test-statistic is: 250.2856 ## ## Critical values of Pu are: ## 10pct 5pct 1pct ## critical values 27.8536 33.713 48.0021 → 帰無仮説棄却. y1とy2には共和分関係あり test_po &lt;- ca.po(ymat[, c(1, 3)], demean = &quot;const&quot;) summary(test_po) ## ## ######################################## ## # Phillips and Ouliaris Unit Root Test # ## ######################################## ## ## Test of type Pu ## detrending of series with constant only ## ## ## Call: ## lm(formula = z[, 1] ~ z[, -1]) ## ## Residuals: ## Min 1Q Median 3Q Max ## -15.706 -3.851 1.099 4.190 11.736 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -5.79847 1.11523 -5.199 3.72e-07 *** ## z[, -1] -0.63880 0.06101 -10.470 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.463 on 298 degrees of freedom ## Multiple R-squared: 0.2689, Adjusted R-squared: 0.2665 ## F-statistic: 109.6 on 1 and 298 DF, p-value: &lt; 2.2e-16 ## ## ## Value of test-statistic is: 17.1324 ## ## Critical values of Pu are: ## 10pct 5pct 1pct ## critical values 27.8536 33.713 48.0021 → 帰無仮説棄却されず. y1とy3には共和分関係なし 10.2.2 Johansenの方法 観測時系列がGaussian VAR(p)に従う場合 (1) 最大固有値検定 \\(H_0\\): 共和分ランク\\(=r\\), \\(H_1\\): 共和分ランク\\(=r+1\\) - &#39;urca&#39;パッケージ内, ca.jo関数: - type (検定の種類): ‘eigen’(最大固有値検定) or ‘trace’(トレース検定) - ecdet (トレンド種類): ‘none’(切片項なし), ‘const’(定数項あり),‘trend’(トレンド項あり) - K (時系列(水準)のVAR表現におけるラグ次数) - spec (VECMの定式化の2つの方法の一つを選択): &quot;longrun&quot;(デフォルト), or &quot;transitory&quot; - season (季節ダミー): データの頻度を指定(例, 四半期の場合は4) 全変数に対して実行 result_e1 &lt;- ca.jo(ymat, ecdet = &quot;none&quot;, type = &quot;eigen&quot;, spec = &quot;longrun&quot;) summary(result_e1) ## ## ###################### ## # Johansen-Procedure # ## ###################### ## ## Test type: maximal eigenvalue statistic (lambda max) , with linear trend ## ## Eigenvalues (lambda): ## [1] 0.39399267 0.35373609 0.04001843 0.01669478 ## ## Values of teststatistic and critical values of test: ## ## test 10pct 5pct 1pct ## r &lt;= 3 | 5.02 6.50 8.18 11.65 ## r &lt;= 2 | 12.17 12.91 14.90 19.19 ## r &lt;= 1 | 130.09 18.90 21.07 25.75 ## r = 0 | 149.26 24.78 27.14 32.14 ## ## Eigenvectors, normalised to first column: ## (These are the cointegration relations) ## ## y1.l2 y2.l2 y3.l2 y4.l2 ## y1.l2 1.0000000 1.0000000 1.00000000 1.000000 ## y2.l2 -0.6347789 -0.1341194 0.74761830 24.357249 ## y3.l2 -0.5785340 1.4100169 -0.01803175 -6.710469 ## y4.l2 0.2788528 -0.6893143 -1.62504044 48.535783 ## ## Weights W: ## (This is the loading matrix) ## ## y1.l2 y2.l2 y3.l2 y4.l2 ## y1.d -0.51186630 -0.320181456 -0.00621887 -2.424265e-04 ## y2.d 0.63903190 0.008777047 -0.01134031 -4.269731e-04 ## y3.d 0.44326372 -0.453798733 0.01223929 -9.786591e-05 ## y4.d -0.06251362 0.124762555 0.01714466 -5.047995e-04 \\(r=0\\)棄却. \\(r \\le 1\\)棄却, \\(r \\le 2\\)棄却されず. → 共和分ベクトルの個数\\(=2\\) (2) トレース検定 \\(H_0\\): 共和分ランク\\(=r\\), \\(H_1\\): 共和分ランク\\(=m\\) (原系列は定常) result_t1 &lt;- ca.jo(ymat, ecdet = &quot;none&quot;, type = &quot;trace&quot;, spec = &quot;longrun&quot;) #result_t1 &lt;- ca.jo(ymat, ecdet = &quot;const&quot;, type = &quot;trace&quot;, spec = &quot;longrun&quot;) summary(result_t1) ## ## ###################### ## # Johansen-Procedure # ## ###################### ## ## Test type: trace statistic , with linear trend ## ## Eigenvalues (lambda): ## [1] 0.39399267 0.35373609 0.04001843 0.01669478 ## ## Values of teststatistic and critical values of test: ## ## test 10pct 5pct 1pct ## r &lt;= 3 | 5.02 6.50 8.18 11.65 ## r &lt;= 2 | 17.19 15.66 17.95 23.52 ## r &lt;= 1 | 147.28 28.71 31.52 37.22 ## r = 0 | 296.54 45.23 48.28 55.43 ## ## Eigenvectors, normalised to first column: ## (These are the cointegration relations) ## ## y1.l2 y2.l2 y3.l2 y4.l2 ## y1.l2 1.0000000 1.0000000 1.00000000 1.000000 ## y2.l2 -0.6347789 -0.1341194 0.74761830 24.357249 ## y3.l2 -0.5785340 1.4100169 -0.01803175 -6.710469 ## y4.l2 0.2788528 -0.6893143 -1.62504044 48.535783 ## ## Weights W: ## (This is the loading matrix) ## ## y1.l2 y2.l2 y3.l2 y4.l2 ## y1.d -0.51186630 -0.320181456 -0.00621887 -2.424265e-04 ## y2.d 0.63903190 0.008777047 -0.01134031 -4.269731e-04 ## y3.d 0.44326372 -0.453798733 0.01223929 -9.786591e-05 ## y4.d -0.06251362 0.124762555 0.01714466 -5.047995e-04 \\(r=0\\)棄却. \\(r \\le 1\\)棄却, \\(r \\le 2\\)棄却されず. → 共和分ベクトルの個数\\(=2\\) 共和分ベクトルをウェイトとする\\(Yt\\)の各成分の線形和計算 → 定常性の確認 ts_new &lt;- ymat %*% summary(result_t1)@V fUnitRoots::adfTest(ts_new[, 1]) ## Warning in fUnitRoots::adfTest(ts_new[, 1]): p-value smaller than printed ## p-value ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -10.3616 ## P VALUE: ## 0.01 ## ## Description: ## Tue Mar 19 13:24:36 2024 by user: fUnitRoots::adfTest(ts_new[, 2]) ## Warning in fUnitRoots::adfTest(ts_new[, 2]): p-value smaller than printed ## p-value ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 1 ## STATISTIC: ## Dickey-Fuller: -12.4858 ## P VALUE: ## 0.01 ## ## Description: ## Tue Mar 19 13:24:36 2024 by user: ##fUnitRoots::adfTest(ts_new[, 3]) ##fUnitRoots::adfTest(ts_new[, 4]) 10.3 誤差修正モデル: データ分析例 (Tsay, MTS, Ch5) 出所: Tsay, MTS, Ch5より抜粋（適宜, 補足説明挿入, または修正) https://faculty.chicagobooth.edu/ruey-s-tsay/research/multivariate-time-series-analysis-with-r-and-financial-applications 10.3.1 共和分検定 Tsay, 5.9, pp.310– require(fUnitRoots) # adfTest ## Loading required package: fUnitRoots require(urca) # ca.jo ## Loading required package: urca ## ## Attaching package: &#39;urca&#39; ## The following objects are masked from &#39;package:fUnitRoots&#39;: ## ## punitroot, qunitroot, unitrootTable require(MTS) # VARorder() ## Loading required package: MTS 分析に使用するデータ 月次社債イールド, 1954.7–2005.3 FRB St. Louisのデータ 系列(Aaa, Baa)が2変量VAR(\\(p\\))モデルに従うと仮定し. 次数\\(p\\)を決定: ifl &lt;- file.path(dir_MTS, &quot;m-bnd.txt&quot;) # dir_MTS: m-bnd.txtを格納しているディレクトリ da &lt;- read.table(ifl) head(da) ## V1 V2 V3 V4 V5 ## 1 1954 7 1 2.89 3.50 ## 2 1954 8 1 2.87 3.49 ## 3 1954 9 1 2.89 3.47 ## 4 1954 10 1 2.87 3.46 ## 5 1954 11 1 2.89 3.45 ## 6 1954 12 1 2.90 3.45 bnd &lt;- da[, 4:5] colnames(bnd) &lt;- c(&quot;Aaa&quot;, &quot;Baa&quot;) m1 &lt;- MTS::VARorder(bnd) # original function, now in &#39;MTS&#39; ## selected order: aic = 11 ## selected order: bic = 3 ## selected order: hq = 3 ## Summary table: ## p AIC BIC HQ M(p) p-value ## [1,] 0 -0.5697 -0.5697 -0.5697 0.0000 0.0000 ## [2,] 1 -7.8664 -7.8374 -7.8551 4331.0806 0.0000 ## [3,] 2 -8.1844 -8.1264 -8.1618 195.5266 0.0000 ## [4,] 3 -8.2589 -8.1720 -8.2251 51.6109 0.0000 ## [5,] 4 -8.2552 -8.1393 -8.2101 5.5112 0.2387 ## [6,] 5 -8.2481 -8.1032 -8.1917 3.5073 0.4768 ## [7,] 6 -8.2751 -8.1013 -8.2075 23.4161 0.0001 ## [8,] 7 -8.2803 -8.0775 -8.2014 10.6262 0.0311 ## [9,] 8 -8.2826 -8.0507 -8.1924 8.9080 0.0634 ## [10,] 9 -8.2784 -8.0176 -8.1769 5.1613 0.2711 ## [11,] 10 -8.2775 -7.9877 -8.1648 7.0457 0.1335 ## [12,] 11 -8.2840 -7.9652 -8.1600 11.2224 0.0242 ## [13,] 12 -8.2812 -7.9334 -8.1459 5.8956 0.2071 ## [14,] 13 -8.2716 -7.8949 -8.1251 2.0355 0.7292 → BIC, HQ(Nannan-Quinn情報量規準), \\(p=3\\)を選択 次に, 各系列の単位根検定 (ADF検定) \\(H_0\\): 単位根有り pacf(bnd[, 1]) pacf(bnd[, 2]) # または, # ar(bnd[, 1]) # --&gt; AIC, p = 3 # ar(bnd[, 2]) # --&gt; AIC, p = 2 # fUnitRoots::adfTest(bnd[, 1], lags = 3, type = &quot;c&quot;) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 3 ## STATISTIC: ## Dickey-Fuller: -1.7007 ## P VALUE: ## 0.425 ## ## Description: ## Tue Mar 19 13:24:38 2024 by user: fUnitRoots::adfTest(bnd[, 2], lags = 2, type = &quot;c&quot;) ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 2 ## STATISTIC: ## Dickey-Fuller: -1.6221 ## P VALUE: ## 0.4544 ## ## Description: ## Tue Mar 19 13:24:38 2024 by user: –&gt; Aaa, Baa系列のADF検定、棄却されない (H0: 単位根非定常) matplot(bnd, type=&quot;l&quot;) # Tsay本の内容に沿って, 以下を挿入 apply(apply(bnd, 2, diff), 2, mean)/ apply(apply(bnd, 2, diff), 2, sd) ## Aaa Baa ## 0.01862195 0.02077461 #apply(apply(bnd, 2, diff), 2, fBasics::stdev) 階階差列の平均値ベクトルは, ゼロから有意に離れていない → 共和分検定に, 定数項入れない (Tsay, p.310) 共和分検定におけるトレンドの指定. Tsay, p.304を参照 10.3.2 Johansenの方法 (Johansen-Procedure) Johansenの方法 → 共和分関係の検定, 共和分ベクトルや共和分ランク(個数)の推定 最大固有値法 \\(H_0\\): 多くても\\(r\\)個の共和分関係しか存在しない vs \\(H_1\\): \\((r+1)\\)個の共和分関係が存在する (\\(H_0\\): 共和分ランク\\(=r\\) vs \\(H_1\\): 共和分ランク\\(=r+1\\)) - urca::ca.jp関数 - x: 共和分を調べたいデータ行列 (原系列) - type: 検定方法の種類. &#39;eigen&#39;(最大固有値法), &#39;trace&#39; (トレース法) - ecdet: トレンド指定. &#39;none&#39; (なし), &#39;const&#39; (定数項有), &#39;trend&#39; (線形トレンド有) - $\\Delta {\\bf y}_t = {\\bf \\mu}_0 + {\\bf \\mu}_1 t+\\cdots$ - (→ 共和分関係にも定数項や線形トレンドが含まれる) - K: 系列(水準)のVARラグ次数 - spec: VECMの特定化. &quot;longrun&quot; ($ {\\bf Γ}_i , 長期的(累積)インパクト), &quot;transitory&quot; ((${\\bf Γ}_i$, 一時的インパクト) ) m2 &lt;- urca::ca.jo(bnd, K = 2, ecdet = c(&quot;none&quot;)) # spec = &quot;longrun&quot; (デフォルト) summary(m2) ## ## ###################### ## # Johansen-Procedure # ## ###################### ## ## Test type: maximal eigenvalue statistic (lambda max) , with linear trend ## ## Eigenvalues (lambda): ## [1] 0.054773196 0.004665298 ## ## Values of teststatistic and critical values of test: ## ## test 10pct 5pct 1pct ## r &lt;= 1 | 2.84 6.50 8.18 11.65 ## r = 0 | 34.19 12.91 14.90 19.19 ## ## Eigenvectors, normalised to first column: ## (These are the cointegration relations) ## ## Aaa.l2 Baa.l2 ## Aaa.l2 1.0000000 1.000000 ## Baa.l2 -0.8856789 -2.723912 ## ## Weights W: ## (This is the loading matrix) ## ## Aaa.l2 Baa.l2 ## Aaa.d -0.04696894 0.002477064 ## Baa.d 0.04046524 0.002139536 → \\(r=0\\)は棄却. \\(r=1\\)は棄却されず → \\(r=1\\) (共和分有. 共和分ベクトルの個数 (\\(\\Pi\\) 行列のランク)) #m3 &lt;- urca::ca.jo(bnd, K = 2, ecdet = c(&quot;none&quot;), spec = c(&quot;transitory&quot;)) #summary(m3) # 定数項有のケース m3 &lt;- urca::ca.jo(bnd, K = 2, ecdet = c(&quot;const&quot;), spec = c(&quot;longrun&quot;)) summary(m3) ## ## ###################### ## # Johansen-Procedure # ## ###################### ## ## Test type: maximal eigenvalue statistic (lambda max) , without linear trend and constant in cointegration ## ## Eigenvalues (lambda): ## [1] 5.477346e-02 4.878009e-03 6.308723e-20 ## ## Values of teststatistic and critical values of test: ## ## test 10pct 5pct 1pct ## r &lt;= 1 | 2.97 7.52 9.24 12.97 ## r = 0 | 34.19 13.75 15.67 20.20 ## ## Eigenvectors, normalised to first column: ## (These are the cointegration relations) ## ## Aaa.l2 Baa.l2 constant ## Aaa.l2 1.000000000 1.000000 1.000000 ## Baa.l2 -0.885675435 -2.701784 -3.315369 ## constant -0.003491742 16.399576 -13.776952 ## ## Weights W: ## (This is the loading matrix) ## ## Aaa.l2 Baa.l2 constant ## Aaa.d -0.04699903 0.002507156 1.086407e-18 ## Baa.d 0.04043910 0.002165681 -1.197343e-18 トレース法 \\(H_0\\): 多くても\\(r\\)個の共和分関係しか存在しない vs \\(H_1\\): 全ての変数が定常 (\\(H_0\\): 共和分ランク\\(=r\\) vs \\(H_1\\): 共和分ランク\\(=m\\) (原系列は定常)) m4 &lt;- urca::ca.jo(bnd, K = 2, ecdet = c(&quot;none&quot;), type = c(&quot;trace&quot;), spec = c(&quot;transitory&quot;)) summary(m4) ## ## ###################### ## # Johansen-Procedure # ## ###################### ## ## Test type: trace statistic , with linear trend ## ## Eigenvalues (lambda): ## [1] 0.054773196 0.004665298 ## ## Values of teststatistic and critical values of test: ## ## test 10pct 5pct 1pct ## r &lt;= 1 | 2.84 6.50 8.18 11.65 ## r = 0 | 37.03 15.66 17.95 23.52 ## ## Eigenvectors, normalised to first column: ## (These are the cointegration relations) ## ## Aaa.l1 Baa.l1 ## Aaa.l1 1.0000000 1.000000 ## Baa.l1 -0.8856789 -2.723912 ## ## Weights W: ## (This is the loading matrix) ## ## Aaa.l1 Baa.l1 ## Aaa.d -0.04696894 0.002477064 ## Baa.d 0.04046524 0.002139536 → \\(r=0\\)は棄却. \\(r=1\\)は棄却されず → \\(r=1\\) (同) (coint_vec &lt;- summary(m4)@V) ## Aaa.l1 Baa.l1 ## Aaa.l1 1.0000000 1.000000 ## Baa.l1 -0.8856789 -2.723912 → 共和分ベクトル: \\((1, -0.886)\\) 得られた``cointegration’’系列 \\(w_t=1 \\cdot Aaa_t - 0.886 \\cdot Baa_t\\)に対して単位根検定 # wt &lt;- bnd[, 1] - 0.886 * bnd[, 2] wt &lt;- as.matrix(bnd) %*% coint_vec[, 1] # fUnitRoots::adfTest(wt, lags = 3, type = &quot;c&quot;) ## Warning in fUnitRoots::adfTest(wt, lags = 3, type = &quot;c&quot;): p-value smaller than ## printed p-value ## ## Title: ## Augmented Dickey-Fuller Test ## ## Test Results: ## PARAMETER: ## Lag Order: 3 ## STATISTIC: ## Dickey-Fuller: -4.6052 ## P VALUE: ## 0.01 ## ## Description: ## Tue Mar 19 13:24:38 2024 by user: → \\(p\\)値\\(=0.01\\) (単位根無) plot(wt, type = &quot;l&quot;) → ``定常時系列の特徴を示す’’ 10.3.3 誤差修正モデル(ECM)の推定 前提: VARモデルの次数\\(p\\),共和分ベクトルの数は既知 (上で得られた) ECMのOLS推定 共和分ベクトル\\(\\beta_t\\)が既知の場合: 上で得られた ``cointegrating系列’’wt=bnd[,1]-0.886*bnd[,2] を所与として \\((p=3, r=1)\\), ECMをOLS推定 - MTS::ECMvar1(x, p, wt=wt, include.const = FALSE, fixed = NULL, output = TRUE) - ECM VAR(p)モデルのOLS推定 (wtが既知の場合) - x: (Txk), k次元共和分VAR過程 - wt: (Txm), m次元共和分過程 - include.const: 定数項の有無 (デフォルト=F) m1 &lt;- MTS::ECMvar1(bnd, 3, wt) ## Given the co-integrated vector ## alpha: ## Aaa Baa ## [1,] -0.00122 0.0634 ## standard error ## [,1] [,2] ## [1,] 0.0347 0.0306 ## AR coefficient matrix ## AR( 1 )-matrix ## Aaa Baa ## Aaa 0.452 -0.00149 ## Baa 0.293 0.20380 ## standard error ## [,1] [,2] ## [1,] 0.0879 0.1008 ## [2,] 0.0774 0.0887 ## AR( 2 )-matrix ## Aaa Baa ## Aaa -0.300 0.0535 ## Baa -0.151 0.0274 ## standard error ## [,1] [,2] ## [1,] 0.0860 0.0940 ## [2,] 0.0757 0.0827 ## ----- ## Residuals cov-mtx: ## Aaa Baa ## Aaa 0.0400851 0.03167180 ## Baa 0.0316718 0.03105888 ## ## det(sse) = 0.0002418953 ## AIC = -8.294165 ## BIC = -8.221721 m1$coef # 表示の向きに注意 (xmtx調整行列, 左辺の各成分が列方向に, 右辺のARラグ項が行方向に) ## Aaa Baa ## xmtx -0.001217005 0.06339082 ## Aaa 0.451993390 0.29303941 ## Baa -0.001491101 0.20379673 ## Aaa -0.299907502 -0.15075817 ## Baa 0.053499341 0.02742606 m1$secoef # 同 ## [,1] [,2] ## [1,] 0.03471368 0.03055639 ## [2,] 0.08790257 0.07737541 ## [3,] 0.10080919 0.08873634 ## [4,] 0.08600254 0.07570293 ## [5,] 0.09396739 0.08271391 m1$coef / m1$secoef # 同 ## Aaa Baa ## xmtx -0.03505836 2.0745518 ## Aaa 5.14198170 3.7872419 ## Baa -0.01479132 2.2966546 ## Aaa -3.48719367 -1.9914443 ## Baa 0.56933946 0.3315773 推定されたECM (\\(w_t=\\beta&#39;{\\bf y}_t=(1,- 0.886){\\bf y}_t\\)) \\[ \\Delta {\\bf y}_t = \\left[\\begin{array}{r} -0.001 \\\\ 0.064 \\end{array}\\right] w_t + \\left[\\begin{array}{rr} 0.452 &amp; -0.001 \\\\ 0.293 &amp; 0.204 \\end{array} \\right] \\Delta {\\bf y}_{t-1} \\] \\[ +\\left[\\begin{array}{rr} -0.300 &amp; 0.054 \\\\ -0.151 &amp; 0.028 \\end{array} \\right] \\Delta {\\bf y}_{t-2} + \\epsilon_t,\\quad \\hat{\\Sigma}= \\frac{1}{100} \\left[\\begin{array}{rr} 4.01 &amp; 3.17 \\\\ 3.17 &amp; 3.11 \\end{array} \\right] \\] OLS推定されたECMの修正 ECMの修正 (パラメータ数削減) 有意でない係数を0に置く - MTS::refECMvar1(m1, thres = 1) - ECM VAR(p)モデルの制約付きOLS推定 (wtが既知の場合) - thres: t-ratioの閾値(デフォルト=1) - |t-ratio| &lt; thres の推定係数を0に置き換える m2 &lt;- MTS::refECMvar1(m1) ####### Refine the model fit ## Equation: 1 npar = 2 ## Equation: 2 npar = 4 ## alpha: ## [,1] [,2] ## [1,] 0 0.0625 ## standard error ## [,1] [,2] ## [1,] 1 0.0304 ## AR coefficient matrix ## AR( 1 )-matrix ## [,1] [,2] ## [1,] 0.448 0.000 ## [2,] 0.286 0.212 ## standard error ## [,1] [,2] ## [1,] 0.0393 1.0000 ## [2,] 0.0746 0.0855 ## AR( 2 )-matrix ## [,1] [,2] ## [1,] -0.256 0 ## [2,] -0.129 0 ## standard error ## [,1] [,2] ## [1,] 0.0393 1 ## [2,] 0.0382 1 ## ----- ## Residuals cov-mtx: ## [,1] [,2] ## [1,] 0.04010853 0.03168277 ## [2,] 0.03168277 0.03106450 ## ## det(sse) = 0.0002421536 ## AIC = -8.306234 ## BIC = -8.262768 推定されたECM (修正後) \\[ \\Delta {\\bf y}_t = \\left[\\begin{array}{r} 0.000 \\\\ 0.063 \\end{array}\\right] w_t + \\left[\\begin{array}{rr} 0.448 &amp; 0.000 \\\\ 0.286 &amp; 0.212 \\end{array} \\right] \\Delta {\\bf y}_{t-1} \\] \\[ +\\left[\\begin{array}{rr} -0.256 &amp; 0.000 \\\\ -0.129 &amp; 0.000 \\end{array} \\right] \\Delta {\\bf y}_{t-2} + \\epsilon_t,\\quad \\hat{\\Sigma}= \\frac{1}{100} \\left[\\begin{array}{rr} 4.01 &amp; 3.17 \\\\ 3.17 &amp; 3.11 \\end{array} \\right] \\] # pacf(m2$residuals) # --&gt; model checking, 若干の系列相関, 相互相関有り(教科書の記述と齟齬?) # --&gt; alpha(1,1)=0 &lt;-- Aaa系列の1階階差系列は定常 m2$coef ## [,1] [,2] ## [1,] 0.0000000 0.06250339 ## [2,] 0.4484522 0.28620026 ## [3,] 0.0000000 0.21172072 ## [4,] -0.2559947 -0.12908889 ## [5,] 0.0000000 0.00000000 m2$secoef ## [,1] [,2] ## [1,] 1.00000000 0.03044171 ## [2,] 0.03929053 0.07458234 ## [3,] 1.00000000 0.08546551 ## [4,] 0.03930742 0.03821387 ## [5,] 1.00000000 1.00000000 m2$coef / m1$secoef ## [,1] [,2] ## [1,] 0.000000 2.045509 ## [2,] 5.101696 3.698853 ## [3,] 0.000000 2.385953 ## [4,] -2.976594 -1.705203 ## [5,] 0.000000 0.000000 ECMのQML推定 共和分ベクトル\\(\\beta_t\\)が未知の場合: 仮定:イノベーション系列 \\({\\epsilon_t}\\) がGaussian - MTS::ECMvar(x,p,ibeta) - ECM VAR(p)モデルのQML推定 (wtが未知の場合) - ibeta: co-integrating matrix初期値 - alpha: alpha行列の初期値 (デフォルト=NULL) # beta &lt;- c(1, -0.886) ### Initial value of co-integration beta &lt;- coint_vec[, 1] m3 &lt;- MTS::ECMvar(bnd, p = 3, ibeta = beta, include.const = F) #### Joint estimation ## Order p: 3 Co-integrating rank: 1 ## Number of parameters: 11 ## initial estimates: -0.001217005 0.06339082 -0.8856789 0.4519934 -0.001491101 -0.2999075 0.05349934 0.2930394 0.2037967 -0.1507582 0.02742606 ## Par. Lower-bounds: -0.05328753 0.01755623 -0.9464619 0.3201395 -0.1527049 -0.4289113 -0.08745174 0.1769763 0.07069222 -0.2643126 -0.09664481 ## Par. Upper-bounds: 0.05085352 0.1092254 -0.8248958 0.5838472 0.1497227 -0.1709037 0.1944504 0.4091025 0.3369012 -0.03720378 0.1514969 ## Final Estimates: -0.0007844935 0.06377964 -0.8865271 0.451819 -0.001406126 -0.3000979 0.05359478 0.2928488 0.2039182 -0.150974 0.02759907 ## ## Coefficient(s): ## Estimate Std. Error t value Pr(&gt;|t|) ## -0.0007845 0.0359051 -0.022 0.982568 ## 0.0637796 0.0314069 2.031 0.042280 * ## Baa.l1 -0.8865271 0.0055004 -161.176 &lt; 2e-16 *** ## 0.4518190 0.0878174 5.145 2.68e-07 *** ## -0.0014061 0.1022704 -0.014 0.989030 ## -0.3000979 0.0864320 -3.472 0.000516 *** ## 0.0535948 0.0948894 0.565 0.572201 ## 0.2928488 0.0772944 3.789 0.000151 *** ## 0.2039182 0.0897482 2.272 0.023080 * ## -0.1509740 0.0760263 -1.986 0.047054 * ## 0.0275991 0.0833998 0.331 0.740701 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## alpha: ## [,1] ## [1,] -0.000784 ## [2,] 0.063780 ## standard error ## [,1] ## [1,] 0.0359 ## [2,] 0.0314 ## beta: ## [,1] ## [1,] 1.000 ## [2,] -0.887 ## standard error ## [,1] ## [1,] 1.0000 ## [2,] 0.0055 ## AR coefficient matrix ## AR( 1 )-matrix ## [,1] [,2] ## [1,] 0.452 -0.00141 ## [2,] 0.293 0.20392 ## standard error ## [,1] [,2] ## [1,] 0.0878 0.1023 ## [2,] 0.0773 0.0897 ## AR( 2 )-matrix ## [,1] [,2] ## [1,] -0.300 0.0536 ## [2,] -0.151 0.0276 ## standard error ## [,1] [,2] ## [1,] 0.0864 0.0949 ## [2,] 0.0760 0.0834 ## ----- ## Residuals cov-mtx: ## Aaa Baa ## Aaa 0.0399535 0.03156630 ## Baa 0.0315663 0.03095427 ## ## det(sse) = 0.0002403005 ## AIC = -8.297496 ## BIC = -8.217807 # m3$ncoint # 共和分ベクトル数 ## [1] 1 m3$alpha # 調整行列 ## [,1] ## [1,] -0.0007844935 ## [2,] 0.0637796425 m3$beta # 共和分行列 ## [,1] ## [1,] 1.0000000 ## [2,] -0.8865271 m3$Phip ## [,1] [,2] ## [1,] 0.451818972 0.29284885 ## [2,] -0.001406126 0.20391818 ## [3,] -0.300097916 -0.15097397 ## [4,] 0.053594777 0.02759907 m3$se.Phip ## [,1] [,2] ## [1,] 0.08781738 0.07729435 ## [2,] 0.10227039 0.08974821 ## [3,] 0.08643197 0.07602634 ## [4,] 0.09488937 0.08339984 推定されたECM (修正後) \\[ \\Delta {\\bf y}_t = \\left[\\begin{array}{r} -0.001 \\\\ 0.064 \\end{array}\\right] [1,-0.887] {\\bf y}_t + \\left[\\begin{array}{rr} 0.452 &amp; -0.001 \\\\ 0.293 &amp; 0.204 \\end{array} \\right] \\Delta {\\bf y}_{t-1} \\] \\[ +\\left[\\begin{array}{rr} -0.300 &amp; 0.054 \\\\ -0.151 &amp; 0.028 \\end{array} \\right] \\Delta {\\bf y}_{t-2} + \\epsilon_t,\\quad \\hat{\\Sigma}= \\frac{1}{100} \\left[\\begin{array}{rr} 4.00 &amp; 3.16 \\\\ 3.16 &amp; 3.10 \\end{array} \\right] \\] → 初期モデル(m1)と近い結果 ``サンプルサイズが比較的大きい一方で低次元であり, 驚くことでない’’ (補足): \\(w_t=1 \\cdot Aaa_t - 0.887 \\cdot Baa_t\\)が定常過程 \\(w_t&gt;0\\) → Aaa_tのイールドが相対高, Baa_tが相対安 → スプレッド”縮小”時 → \\({\\bf y}_t\\)への影響; \\([-0.001,0.064]&#39;w_t\\) 翌月のAaa_tイールドを\\(0.001\\cdot w_t\\)押し下げる 翌月のBaa_tイールドを\\(0.064\\cdot w_t\\)押し上げる → 翌月のスプレッドが”拡大”する方向に作用 "],["多変量ボラティリティモデル.html", "11 多変量ボラティリティ・モデル 11.1 多変量時系列データの条件付不均一分散性の検定 11.2 指数加重移動平均法 (EWMA) 11.3 BEKK(1, 1)モデル 11.4 Cholesky分解を利用したボラティリティ推定 11.5 DCC (Dynamic Conditional Correlation) モデル 11.6 Go-GARCHモデル 11.7 コピュラに基づくアプローチ 11.8 主成分分析に基づくアプローチ (PVC)", " 11 多変量ボラティリティ・モデル 出所: Tsay, Ch.7 (http://faculty.chicagobooth.edu/ruey.tsay/teaching/introTS/) (一部改変) 11.1 多変量時系列データの条件付不均一分散性の検定 Tsay, pp.406– シミュレーション系列の生成 library(MTS) zt = matrix(rnorm(2000), 400, 5) ### Another set of random noises - 複数の検定方法 - (1)Ljung-Box検定 (1変量の標準化残差に変換した系列に対して) - Q(m) of squared series(LM test) - (2)順位自己相関 (rank autocorrelation) を用いた検定 - Rank-based Test - (3)多変量Ljung-Box検定 - Q_k(m) of squared series - (4)同, 上位5%のデータを刈込み (trim) - Robust Test(5%) - MTS::MarchTest MarchTest(zt) #### Multivariate volatility tests ## Q(m) of squared series(LM test): ## Test statistic: 10.8256 p-value: 0.3712657 ## Rank-based Test: ## Test statistic: 17.98655 p-value: 0.05519091 ## Q_k(m) of squared series: ## Test statistic: 264.3044 p-value: 0.2554033 ## Robust Test(5%) : 258.2484 p-value: 0.3465555 分析例 Tsay, pp.415– IBM and SP log returns ifl &lt;- file.path(dir_MTS, &quot;m-ibmsp-6111.txt&quot;) da &lt;- read.table(ifl, header = T) rtn &lt;- log(da[, 2:3] + 1) at &lt;- scale(rtn, scale = F) ## Remove sample means MarchTest(at) ## Q(m) of squared series(LM test): ## Test statistic: 38.06663 p-value: 3.695138e-05 ## Rank-based Test: ## Test statistic: 108.3798 p-value: 0 ## Q_k(m) of squared series: ## Test statistic: 109.4194 p-value: 2.276873e-08 ## Robust Test(5%) : 118.7134 p-value: 9.894441e-10 11.2 指数加重移動平均法 (EWMA) Exponentially Weighted Moving Average Approach ifl &lt;- file.path(dir_MTS, &quot;m-dec125910-6111.txt&quot;) da &lt;- read.table(ifl, header = T) # CRSP(1, 2, 5, 9, 10十分位ポートフォリオ)の月次対数収益率 head(da) ## date dec1 dec2 dec5 dec9 dec10 ## 1 19610131 0.058011 0.067392 0.081767 0.096754 0.087207 ## 2 19610228 0.029241 0.042784 0.055524 0.056564 0.060245 ## 3 19610330 0.025896 0.025474 0.041304 0.060563 0.071875 ## 4 19610428 0.005667 0.001365 0.000780 0.011911 0.023328 ## 5 19610531 0.019208 0.036852 0.049590 0.046248 0.050362 ## 6 19610630 -0.024670 -0.025225 -0.040046 -0.050651 -0.051434 rtn &lt;- log(da[, 2:4] + 1) m1 &lt;- VAR(rtn, 1) ## Fit VAR(1) model to remove serial correlations ## Constant term: ## Estimates: 0.006376978 0.007034631 0.007342962 ## Std.Error: 0.001759562 0.001950008 0.002237004 ## AR coefficient matrix ## AR( 1 )-matrix ## [,1] [,2] [,3] ## [1,] -0.194 0.224 0.00836 ## [2,] -0.232 0.366 -0.04186 ## [3,] -0.313 0.452 0.00238 ## standard error ## [,1] [,2] [,3] ## [1,] 0.108 0.160 0.101 ## [2,] 0.120 0.177 0.111 ## [3,] 0.138 0.204 0.128 ## ## Residuals cov-mtx: ## [,1] [,2] [,3] ## [1,] 0.001814678 0.001859113 0.001962277 ## [2,] 0.001859113 0.002228760 0.002420858 ## [3,] 0.001962277 0.002420858 0.002933081 ## ## det(SSE) = 1.712927e-10 ## AIC = -22.45809 ## BIC = -22.39289 ## HQ = -22.43273 at &lt;- m1$residuals ## ARCH test # MarchTest(at) - MTS::EWMAvol(rtn, lambda = 0.96) # lambda: 減衰率 - lambda = 正値 --&gt; 固定値を指定して実行 (lambdaの推定なし) - lambda = 負値 --&gt; lambda推定 m2 = EWMAvol(at, lambda = -0.1) ### Estimation of decaying rate Sigma.t = m2$Sigma.t ### Volatility matrices m3 = MCHdiag(at, Sigma.t) # モデル診断 - MTS::MCHdiag - Apply four portmanteau test statistics to check the validity of a fitted multivariate volatility model - at: A T-by-k matrix of residuals for a k-dimensional asset return series - Sigma.t: The fitted volatility matrices. The dimension is T-by-k^2 matrix - m: The number of lags used in the tests. Default is 10. ※ 以下を挿入: m2_2 &lt;- EWMAvol(at, lambda = 0.9) ### 減衰率 = 0.9に設定 matplot(m2$Sigma.t, type = &quot;l&quot;) matplot(m2_2$Sigma.t, type = &quot;l&quot;) CRSP(1, 2, 5十分位ポートフォリオ)の月次対数収益率のボラティリティ行列の各要素の時系列プロット p.415– par(mfcol = c(3, 2)) ### Create Figure 7.3 of the text tdx &lt;- c(2:609)/12+1961 plot(tdx, Sigma.t[, 1], xlab = &#39;Year&#39;, ylab = &quot;Variance&quot;, type = &#39;l&#39;) title(main = &quot;(a) Dec 1&quot;) plot(tdx, Sigma.t[, 5], xlab = &#39;Year&#39;, ylab = &quot;Variance&quot;, type = &#39;l&#39;) title(main = &quot;(b) Dec 2&quot;) plot(tdx, Sigma.t[, 9], xlab = &#39;Year&#39;, ylab = &quot;Variance&quot;, type = &#39;l&#39;) title(main = &quot;(c) Dec 5&quot;) plot(tdx, Sigma.t[, 2], xlab = &#39;Year&#39;, ylab = &quot;Covariance&quot;, type = &#39;l&#39;) title(main = &quot;(d) Dec 1 vs Dec 2&quot;) plot(tdx, Sigma.t[, 3], xlab = &#39;Year&#39;, ylab = &quot;Covariance&quot;, type = &#39;l&#39;) title(main = &quot;(e) Dec 1 vs Dec 5&quot;) plot(tdx, Sigma.t[, 6], xlab = &#39;Year&#39;, ylab = &quot;Covariance&quot;, type = &#39;l&#39;) title(main = &quot;(f) Dec 2 vs Dec 5&quot;) 11.3 BEKK(1, 1)モデル p.417– - MTS::BEKK11 - 注) 実行時間を要する (ここでは不実行) ifl &lt;- file.path(dir_MTS, &quot;m-ibmsp-6111.txt&quot;) da &lt;- read.table(ifl, header = T) # IBM株, S&amp;P, 月次収益率, 1961年1月--2011年12月 rtn &lt;- log(da[, 2:3] + 1) m1a &lt;- BEKK11(rtn) # 時間かかる names(m1a) Sigma_t &lt;- m1a$Sigma.t at &lt;- cbind(rtn[, 1] - - m1a$estimates[1], rtn[, 2] - - m1a$estimates[2]) MCHdiag(at, Sigma_t) 11.4 Cholesky分解を利用したボラティリティ推定 Cholesky Decomposition Tsay, p.426– ifl &lt;- file.path(dir_MTS, &quot;m-ibmspko-6111.txt&quot;) da &lt;- read.table(ifl, header = T) # IBM株, S&amp;P指数, コカコーラ株 # 月次リターン, 1961年1月--2011年12月 rtn &lt;- log(da[, 2:4] + 1) # 多変量Choleskyボラティリティ・モデル - MTS::MCholV - Use recursive least squares to perform the time-varying Cholesky decomposition. The least squares estimates are then smoothed via the exponentially weighted moving-average method with decaying rate 0.96. University GARCH(1, 1) model is used for the innovations of each linear regression. #library(fGarch) m3 &lt;- MCholV(rtn) ## Sample means: 0.007728 0.005024 0.010595 ## Estimation of the first component ## Estimate (alpha0, alpha1, beta1): 0.000356 0.117515 0.810288 ## s.e. : 0.000157 0.037004 0.057991 ## t-value : 2.262897 3.175772 13.97261 ## Component 2 Estimation Results (residual series): ## Estimate (alpha0, alpha1, beta1): 6.4e-05 0.099156 0.858354 ## s.e. : 3.1e-05 0.027785 0.037238 ## t-value : 2.034528 3.568616 23.05076 ## Component 3 Estimation Results (residual series): ## Estimate (alpha0, alpha1, beta1): 0.000173 0.117506 0.818722 ## s.e. : 6.2e-05 0.028651 0.038664 ## t-value : 2.808075 4.101297 21.17521 names(m3) ## [1] &quot;betat&quot; &quot;bt&quot; &quot;Vol&quot; &quot;Sigma.t&quot; # betat: Recursive least squares estimates of the linear transformations in Cholesky decomposition # bt: The transformation residual series # Vol: The volatility series of individual innovations # Sigma.t: Volatility matrices at &lt;- scale(rtn[-(1:36), ], center = T, scale = F) Sigma_t &lt;- m3$Sigma.t MCHdiag(at, Sigma_t) ## Test results: ## Q(m) of et: ## Test and p-value: 15.94978 0.1010791 ## Rank-based test: ## Test and p-value: 21.99727 0.01511849 ## Qk(m) of epsilon_t: ## Test and p-value: 123.7687 0.01057302 ## Robust Qk(m): ## Test and p-value: 95.49626 0.3259654 MCHdiag(at, Sigma_t, m = 5) ## Test results: ## Q(m) of et: ## Test and p-value: 5.717035 0.3347333 ## Rank-based test: ## Test and p-value: 5.579834 0.3492711 ## Qk(m) of epsilon_t: ## Test and p-value: 59.837 0.06842123 ## Robust Qk(m): ## Test and p-value: 58.97874 0.07891472 matplot(Sigma_t, type = &quot;l&quot;) matplot(m3$Vol, type = &quot;l&quot;) matplot(m3$betat, type = &quot;l&quot;) matplot(m3$bt, type = &quot;l&quot;) 11.5 DCC (Dynamic Conditional Correlation) モデル MTS, p.432– (引き続き) IBM, SP, KO 対数収益率の使用 ** 事前フィッティング** - 各成分に単変量GARCHを適合 - → DCC推定のための標準化残差系列の生成 - MTS::dccPre - 注) 実行時間ややかかる m1 &lt;- dccPre(rtn, include.mean = T, p = 0) ## Sample mean of the returns: 0.00772774 0.005023909 0.01059521 ## Component: 1 ## Estimates: 0.000419 0.126739 0.788307 ## se.coef : 0.000162 0.035405 0.055645 ## t-value : 2.593448 3.57973 14.16662 ## Component: 2 ## Estimates: 9e-05 0.127725 0.836053 ## se.coef : 4.1e-05 0.03084 0.031723 ## t-value : 2.20126 4.141592 26.35486 ## Component: 3 ## Estimates: 0.000256 0.098705 0.830358 ## se.coef : 8.5e-05 0.022361 0.033441 ## t-value : 3.015321 4.414112 24.83088 names(m1) ## [1] &quot;marVol&quot; &quot;sresi&quot; &quot;est&quot; &quot;se.coef&quot; rtn1 &lt;- m1$sresi # 標準化残差系列 Vol &lt;- m1$marVol Tse and Tsui (2002) モデル - MTS::docFit (rt, type = &quot;TseTsui&quot;) (デフォルト) - 標準化残差系列に対してDCCモデルを適合 m2 &lt;- dccFit(rtn1) ### Use Tse and Tsui model ## Estimates: 0.8087994 0.04027416 7.959064 ## st.errors: 0.1491731 0.02259899 1.135874 ## t-values: 5.421885 1.782122 7.006998 names(m2) ## [1] &quot;estimates&quot; &quot;Hessian&quot; &quot;rho.t&quot; S2_t &lt;- m2$rho.t Engle (2002) モデル - MTS::docFit (rt, type = &quot;Engle&quot;) (デフォルト) - 注) 実行時間ややかかる m3 = dccFit(rtn1, type = &quot;Engle&quot;) ## Use Engle model ## Estimates: 0.9126534 0.04531519 8.624321 ## st.errors: 0.02947897 0.01274031 1.332704 ## t-values: 30.95947 3.556835 6.471295 S3_t = m3$rho.t 以下を追加: 時点\\(t\\)の相関行列\\(R_t\\) (Tsay本では\\(\\rho_t\\)) ← 3x3 対称行列 head(S2_t) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## [1,] 1 0.5842955 0.2772491 0.5842955 1 0.5600389 0.2772491 0.5600389 1 ## [2,] 1 0.5842955 0.2772491 0.5842955 1 0.5600389 0.2772491 0.5600389 1 ## [3,] 1 0.5842955 0.2772491 0.5842955 1 0.5600389 0.2772491 0.5600389 1 ## [4,] 1 0.5842955 0.2772491 0.5842955 1 0.5600389 0.2772491 0.5600389 1 ## [5,] 1 0.5930112 0.2898027 0.5930112 1 0.5485945 0.2898027 0.5485945 1 ## [6,] 1 0.5867309 0.3016936 0.5867309 1 0.5596515 0.3016936 0.5596515 1 head(S3_t) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## [1,] 1 0.5842955 0.2772491 0.5842955 1 0.5600389 0.2772491 0.5600389 1 ## [2,] 1 0.6037264 0.2712637 0.6037264 1 0.5383299 0.2712637 0.5383299 1 ## [3,] 1 0.6081221 0.3065183 0.6081221 1 0.5405505 0.3065183 0.5405505 1 ## [4,] 1 0.6095527 0.3048562 0.6095527 1 0.5392283 0.3048562 0.5392283 1 ## [5,] 1 0.6065274 0.2795197 0.6065274 1 0.5274868 0.2795197 0.5274868 1 ## [6,] 1 0.6077643 0.2881606 0.6077643 1 0.5297445 0.2881606 0.5297445 1 matplot(S2_t[, c(2, 3, 6)], type = &quot;l&quot;, main = &quot;Tse and Tsui model&quot;) matplot(S3_t[, c(2, 3, 6)], type = &quot;l&quot;, main = &quot;Engle model&quot;) MCHdiag(rtn1, S2_t) ### Model checking ## Test results: ## Q(m) of et: ## Test and p-value: 20.74249 0.02296253 ## Rank-based test: ## Test and p-value: 30.20662 0.0007924436 ## Qk(m) of epsilon_t: ## Test and p-value: 132.4228 0.002425954 ## Robust Qk(m): ## Test and p-value: 109.9671 0.07501572 MCHdiag(rtn1, S3_t) ## Test results: ## Q(m) of et: ## Test and p-value: 20.02928 0.02897696 ## Rank-based test: ## Test and p-value: 27.60836 0.002084952 ## Qk(m) of epsilon_t: ## Test and p-value: 131.9812 0.002626131 ## Robust Qk(m): ## Test and p-value: 111.3537 0.06306805 11.6 Go-GARCHモデル - gogarch::gogarch - estby: &quot;ica&quot;(Independent Component Analysis), &quot;mm&quot; (モーメント法), &quot;ml&quot; (最尤法), &quot;nls&quot; (非線形最小二乗法) Tsay, p.437– library(gogarch) ## Loading required package: fGarch ## NOTE: Packages &#39;fBasics&#39;, &#39;timeDate&#39;, and &#39;timeSeries&#39; are no longer ## attached to the search() path when &#39;fGarch&#39; is attached. ## ## If needed attach them yourself in your R script by e.g., ## require(&quot;timeSeries&quot;) ## Loading required package: fastICA crtn &lt;- scale(rtn, center = T, scale = F) m1 &lt;- gogarch::gogarch(crtn, ~garch(1, 1), estby = &quot;ica&quot;) # &quot;ica&quot;: Independent Component Analysisx (非正規データの場合) m1 ## ## **************** ## *** GO-GARCH *** ## **************** ## ## Components estimated by: fast ICA ## Dimension of data matrix: (612 x 3). ## Formula for component GARCH models: ~ garch(1, 1) ## ## Orthogonal Matrix U: ## [,1] [,2] [,3] ## [1,] 0.3723521 0.4868387 0.7901531 ## [2,] -0.7627857 -0.3244553 0.5593628 ## [3,] -0.5286889 0.8109974 -0.2505419 ## ## Linear Map Z: ## [,1] [,2] [,3] ## [1,] 0.008734527 0.033243928 0.060657687 ## [2,] -0.030424067 0.007321814 0.030683719 ## [3,] -0.039763962 0.047132422 -0.001258101 ## ## Estimated GARCH coefficients: ## omega alpha1 beta1 ## y1 0.32201849 0.13518846 0.7163263 ## y2 0.21617656 0.09057087 0.8579026 ## y3 0.01843957 0.09210997 0.8475311 ## ## Convergence codes of component GARCH models: ## y1 y2 y3 ## 1 1 1 # Convergence codes of component GARCH models: Sigma_t &lt;- NULL ### obtain the volatility matrix for (i in 1:612){ Sigma_t &lt;- rbind(Sigma_t, c(m1@H[[i]])) } MCHdiag(crtn, Sigma_t) ### Model checking ## Test results: ## Q(m) of et: ## Test and p-value: 18.07075 0.05378186 ## Rank-based test: ## Test and p-value: 17.50057 0.0639958 ## Qk(m) of epsilon_t: ## Test and p-value: 140.6839 0.0005098065 ## Robust Qk(m): ## Test and p-value: 122.2434 0.01345344 M &lt;- m1@Z Minv &lt;- solve(M) # 逆行列 bt &lt;- crtn %*% t(Minv) cor(bt^2) ## [,1] [,2] [,3] ## [1,] 1.0000000 0.1744159 0.3425388 ## [2,] 0.1744159 1.0000000 0.1063770 ## [3,] 0.3425388 0.1063770 1.0000000 matplot(Sigma_t[, c(1, 5, 9)], type = &quot;l&quot;) # 追加 11.7 コピュラに基づくアプローチ Tsay, p.452– ifl &lt;- file.path(dir_MTS, &quot;m-ibmspko-6111.txt&quot;) da = read.table(ifl, header = T) rtn &lt;- log(da[, -1] + 1) m1 &lt;- dccPre(rtn, cond.dist = &quot;std&quot;) ## Sample mean of the returns: 0.00772774 0.005023909 0.01059521 ## Component: 1 ## Estimates: 0.000388 0.115626 0.805129 9.209269 ## se.coef : 0.000177 0.036827 0.059471 3.054817 ## t-value : 2.195398 3.139719 13.5382 3.014671 ## Component: 2 ## Estimates: 0.00012 0.130898 0.814531 7.274928 ## se.coef : 5.7e-05 0.037012 0.046044 1.913333 ## t-value : 2.102768 3.536655 17.69028 3.802228 ## Component: 3 ## Estimates: 0.000216 0.104706 0.837217 7.077137 ## se.coef : 8.9e-05 0.028107 0.037157 1.847525 ## t-value : 2.437323 3.725341 22.53208 3.830605 names(m1) ## [1] &quot;marVol&quot; &quot;sresi&quot; &quot;est&quot; &quot;se.coef&quot; Vol &lt;- m1$marVol; eta = m1$sresi matplot(Vol, type = &quot;l&quot;) # 追加 多変量 t-Copula ボラティリティ・モデル - MTS::mtCopula - Fits a t-copula to a k-dimensional standardized return series. The correlation matrices are parameterized by angles and the angles evolve over time via a DCC-type equation. - 注) 実行時間ややかかる m2 &lt;- mtCopula(eta, g1 = 0.8, g2 = 0.04) # -&gt; 時間ややかかる names(m2) MCHdiag(eta, m2$rho.t) m3 &lt;- mtCopula(eta, g1 = 0.8, g2 = 0.04, include.th0 = F) Example 7.6 ifl &lt;- file.path(dir_MTS, &quot;d-xomspaapl.txt&quot;) da &lt;- read.table(ifl, header = T) head(da) rtn &lt;- log(da[, -1] + 1) * 100 # 日次リターン, 2007.9--2012.9, Exxon Mobil, S&amp;P, Apple mm1 &lt;- dccPre(rtn, cond.dist = &quot;std&quot;) rtn1 &lt;- mm1$sresi Vol &lt;- mm1$marVol dim(rtn1) matplot(Vol, type = &quot;l&quot;) # 追加 mm2 &lt;- mtCopula(rtn1, 0.8, 0.04) # -&gt; 時間ややかかる MCHdiag(rtn1, mm2$rho.t) 11.8 主成分分析に基づくアプローチ (PVC) Tsay, p.460– “Principal volatility component analysis” (Hu and Tsay, 2014) - MTS::comVol - Compute the principal volatility components based on the residuals of a VAR(p) model. ifl &lt;- file.path(dir_MTS, &quot;w-fx7.txt&quot;) da = read.table(ifl, header = T) head(da) ## Mon day year GBPUSD NOKUSD SEKUSD CHFUSD CADUSD SGDUSD AUDUSD ## 1 3 22 2000 0.63397 8.4066 8.6470 1.6560 1.4691 1.7156 1.6480 ## 2 3 29 2000 0.62935 8.4148 8.6232 1.6595 1.4556 1.7152 1.6354 ## 3 4 5 2000 0.62890 8.4670 8.6555 1.6435 1.4543 1.7160 1.6563 ## 4 4 12 2000 0.63029 8.5327 8.6773 1.6450 1.4659 1.7161 1.6744 ## 5 4 19 2000 0.63290 8.6515 8.7601 1.6646 1.4793 1.6999 1.6837 ## 6 4 26 2000 0.63519 8.8426 8.8844 1.7064 1.4763 1.7047 1.6940 dim(da) ## [1] 606 10 fx &lt;- log(da[, 4:10]) rtn &lt;- diffM(fx) # 週次為替データ, 2000.3.2--2011.10.26 # GBPUSD NOKUSD SEKUSD CHFUSD CADUSD SGDUSD AUDUSD m1 &lt;- comVol(rtn, p = 5) ## eigen-values: 4.07592 1.906457 1.646785 1.199888 1.081506 0.7761643 0.4490305 ## proportion: 0.3660211 0.1712015 0.1478827 0.107751 0.09712014 0.06970022 0.04032333 ## Checking: ## Results of individual F-test for ARCH effect ## Numbers of lags used: 10, 20, 30 ## Component,(F-ratio P-val) (F-ratio P-val) (F-ratio P-Val) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] 1 21.66 0.00e+00 11.421 0.00e+00 7.725 0.00e+00 ## [2,] 2 5.78 2.54e-08 4.114 8.66e-09 3.169 7.06e-08 ## [3,] 3 7.24 7.95e-11 3.804 7.17e-08 2.659 6.66e-06 ## [4,] 4 4.58 2.76e-06 2.859 3.70e-05 2.279 1.63e-04 ## [5,] 5 1.49 1.38e-01 0.824 6.85e-01 0.776 7.99e-01 ## [6,] 6 2.38 9.18e-03 1.872 1.23e-02 1.271 1.55e-01 ## [7,] 7 1.42 1.68e-01 1.121 3.23e-01 1.126 2.96e-01 # 使用するラグ本数=10, 20, 30本に対する, (F比, p値)の各ペア # Compute the principal volatility components based on the residuals of a VAR(p) model. names(m1) ## [1] &quot;residuals&quot; &quot;values&quot; &quot;vectors&quot; &quot;M&quot; print(round(m1$M, 4)) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] -0.1965 -0.2139 -0.0020 0.6560 0.1648 0.3660 -0.2319 ## [2,] -0.3089 0.0292 -0.1021 0.1588 0.1776 -0.7538 -0.1865 ## [3,] -0.2351 0.3511 -0.3311 -0.3132 -0.3295 0.5094 -0.2157 ## [4,] 0.6307 -0.1982 0.1428 -0.0160 -0.2357 -0.0725 -0.2187 ## [5,] -0.0375 0.0600 0.6978 0.2937 -0.3994 -0.0540 0.5686 ## [6,] 0.6409 0.8503 -0.0782 0.3649 0.7624 0.1732 0.6629 ## [7,] 0.0279 -0.2534 0.6055 -0.4761 0.1910 0.0124 -0.2332 rt &lt;- m1$residuals %*% m1$M # obtain PVCs # 追加 head(rt) ## [,1] [,2] [,3] [,4] [,5] ## [1,] -0.0005443728 0.007231997 0.0035809562 0.011902447 0.0013887967 ## [2,] -0.0091648754 -0.001250578 -0.0005656099 0.002735395 0.0065290543 ## [3,] -0.0008562153 -0.003833748 0.0079452277 0.001723361 0.0012852971 ## [4,] -0.0050102372 0.002552756 0.0053976258 0.007384312 -0.0000975068 ## [5,] 0.0057846902 -0.001636014 -0.0007673213 -0.007862622 0.0061655758 ## [6,] -0.0020099186 -0.001653639 -0.0072930663 0.004103353 0.0051016169 ## [,6] [,7] ## [1,] -0.001718935 -0.0017096491 ## [2,] 0.005899341 0.0006295078 ## [3,] 0.004559308 -0.0032395258 ## [4,] 0.004915362 0.0044671253 ## [5,] -0.002378963 0.0068035867 ## [6,] 0.002806629 0.0089839116 par(mfcol = c(2, 2)) plot(rt[, 1], type = &quot;l&quot;, ylab = &quot;pvc1&quot;); plot(rt[, 7], type = &quot;l&quot;, ylab = &quot;pvc7&quot;) acf(rt[, 1]^2, main = &quot;pvc1-square&quot;); acf(rt[, 7]^2, main = &quot;pvc7-square&quot;) "],["高頻度データ分析.html", "12 高頻度データ分析 12.1 ボラティリティ推定 12.2 共分散・相関の推定 12.3 ACDモデル", " 12 高頻度データ分析 12.1 ボラティリティ推定 一日内の取引データ (高頻度データ) を使って, 日次ボラティリティを推定したい. データセット1: TOPIX指数データ 1日分 (2018年2月5日), 1秒間隔の東証株価指数 (TOPIX) データ. require(zoo) # TOPIX指数データ. 2018年2月5日前場・後場. 1秒間隔 # 各8998件 (共通) # 9:00:05 -- 11:30:02, 12:30:05--15:00:02 idir &lt;- file.path(&quot;./&quot;) # TOPIX指数 ifl1 &lt;- file.path(idir, &quot;topix1s_20180205_1.csv&quot;) topix1s_1 &lt;- read.csv(ifl1) ifl2 &lt;- file.path(idir, &quot;topix1s_20180205_2.csv&quot;) topix1s_2 &lt;- read.csv(ifl2) topix_1 &lt;- zoo(topix1s_1$price, topix1s_1$sec) topix_2 &lt;- zoo(topix1s_2$price, topix1s_2$sec) par(mfrow = c(1,2)) plot(topix_1, xlab = &quot;sec&quot;, ylab = &quot;TOPIX&quot;) plot(topix_2, xlab = &quot;sec&quot;, ylab = &quot;TOPIX&quot;) 株価指数そのものは取引されていないが, 現実に取引されている証券の高頻度データを使ってボラティリティを推定する場合には, マイクロストラクチャノイズに対する対応が必要となる. 簡便法としては, 実現ボラティリティの代わりに始値と終値のみや, 四本値のみを使う推定法 (例, Parkinsonボラティリティ) を用いる, 実現ボラティリティの計算に 用いる取引データの間隔を間引き (5分間隔程度) するやり方がある. さらには, 実現ボラティリティを改良し, マイクロストラクチャノイズに対応したより”精緻な”推定法が 数多く提案されている. これらは, yuimaパッケージの中で cce()関数として実装されている (以下の「共分散・相関の推定」パート参照). 実現ボラティリティの計算 真の価格系列が連続時間の拡散過程 (伊藤過程) に従っていて それが離散時間で観測されていると仮定. # 実現ボラティリティの計算 # 分散ではなく標準偏差表示. 年率換算せず # prcvec: (対数を取る前の) 価格系列 calc_RV &lt;- function(prcvec, dgts = 6){ prcvec2 &lt;- na.omit(prcvec) if(length(prcvec2) == 0 || any(prcvec &lt;= 0)) return(NA) # -Infを回避 rv &lt;- sum(diff(log(prcvec2))^2) ** 0.5 return(round(rv, dgts)) } (RV_1 &lt;- calc_RV(topix_1)) #&gt; [1] 0.004188 (RV_2 &lt;- calc_RV(topix_2)) #&gt; [1] 0.002204 #(RV.1 &lt;- calc_RV(topix1s_1$price)) #(RV.2 &lt;- calc_RV(topix1s_2$price)) Parkinsonボラティリティの計算 # Parkionsonボラティリティの計算 # 分散ではなく標準偏差表示. 年率換算せず calc_vParkinson &lt;- function(prcvec, freq = 1){ prcvec2 &lt;- na.omit(prcvec) if(length(prcvec2) == 0) return(NA) # -Infを回避 LH &lt;- range(prcvec2) if (LH[1] * LH[2] &lt;= 0) return(F) vola &lt;- abs(log(LH[2] / LH[1])) / sqrt(4 * freq * log(2)) return(vola) } (vPark_1 &lt;- calc_vParkinson(topix_1)) #&gt; [1] 0.006450344 (vPark_2 &lt;- calc_vParkinson(topix_2)) #&gt; [1] 0.002763914 #(vPark_1 &lt;- calc_vParkinson(topix1s_1$price)) #(vPark_2 &lt;- calc_vParkinson(topix1s_2$price)) HAR-RVモデルによる予測 HAR-RVモデルは, 日次RV時系列の示す長期記憶性をうまく近似し, ボラティリティ予測性能が高いとされるモデルである. highfrequencyパッケージの関数HARmodel()により, HARモデルの推定, ボラティリティの予測が可能である. パラメータ指定により, HARモデルのバリエーションの指定や, 説明変数に使う日次・週次・月次の合算日数の変更, RV以外の有用な実現測度 (realized measures) の推定・予測も可能である. ジャンプ検定も可能である. HARmodel(): HARモデルの推定. 過去の高頻度データより1日先のボラティリティ予測 - usage: HARmodel( data, # xtsオブジェクト. 日内対数リターン, または計算済の実現測度 (realized measures) periods = c(1, 5, 22), # 実現測度の合算 (集約) 日数のベクトル (1 day, 1 week, 1 monthに対応) periodsJ = c(1, 5, 22), # ジャンプ項の合算日数のベクトル periodsQ = c(1), # 実現4乗量 (quarticity) の合算日数のベクトル leverage = NULL, # 負のリターンを合算する日数のベクトル RVest = c(&quot;rCov&quot;, &quot;rBPCov&quot;, &quot;rQuar&quot;), # 出力の種類: デフォルトは, 日次累積分散 (ジャンプ-robust), 実現bi-power変動, 実現4乗量. それ以外の指定はマニュアルを見よ. inputType = &quot;RM&quot;, # 入力dataの形式]: realized measure (デフォルト). それ以外は, リターン jumpTest = &quot;ABDJumptest&quot;, # ジャンプ検定 alpha = 0.05, # ジャンプ検定の有意水準 h = 1, # 従属変数を合算する日数 transform = NULL, # 従属変数や説明変数を(同時に)変換する関数. 典型例, &quot;log&quot;, &quot;sqrt&quot; externalRegressor = NULL, # 外部説明変数 periodsExternal = c(1), # 外部説明変数を合算する日数 ... library(highfrequency) library(xts) # Forecasting daily Realized volatility for the S&amp;P 500 using the basic HARmodel: HAR str(SPYRM) # S&amp;P500 (SPY) ETFの各種実現測度 (１分, 5分) #&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;: 1495 obs. of 14 variables: #&gt; $ DT : Date, format: &quot;2014-01-02&quot; &quot;2014-01-03&quot; ... #&gt; $ RV1 : num 2.68e-05 1.58e-05 2.72e-05 1.08e-05 3.11e-05 ... #&gt; $ RV5 : num 2.57e-05 1.78e-05 2.56e-05 9.95e-06 2.68e-05 ... #&gt; $ BPV1 : num 2.54e-05 1.55e-05 2.18e-05 1.00e-05 2.58e-05 ... #&gt; $ BPV5 : num 2.37e-05 1.67e-05 1.89e-05 9.75e-06 2.35e-05 ... #&gt; $ medRV1: num 2.45e-05 1.54e-05 2.24e-05 1.06e-05 2.64e-05 ... #&gt; $ medRV5: num 1.93e-05 1.63e-05 1.64e-05 9.32e-06 2.32e-05 ... #&gt; $ RK1 : num 2.59e-05 1.60e-05 3.20e-05 9.42e-06 1.98e-05 ... #&gt; $ RK5 : num 2.64e-05 1.63e-05 2.59e-05 9.96e-06 1.94e-05 ... #&gt; $ RQ1 : num 0.0534 0.0302 0.0621 0.0213 0.0889 ... #&gt; $ RQ5 : num 0.0543 0.0304 0.05 0.017 0.0538 ... #&gt; $ medRQ1: num 0.0473 0.0296 0.0419 0.0207 0.0823 ... #&gt; $ medRQ5: num 0.0473 0.0296 0.0419 0.0207 0.0823 ... #&gt; $ CLOSE : num 183 183 182 183 184 ... #&gt; - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; #&gt; - attr(*, &quot;sorted&quot;)= chr &quot;DT&quot; RVSPY &lt;- as.xts(SPYRM$RV5, order.by = SPYRM$DT) x &lt;- highfrequency::HARmodel(data = RVSPY, periods = c(1,5,22), RVest = c(&quot;rCov&quot;), type = &quot;HAR&quot;, h = 1, transform = NULL, inputType = &quot;RM&quot;) class(x) #&gt; [1] &quot;HARmodel&quot; &quot;lm&quot; plot(x) # Estimate the HAR model of type HARQ dat &lt;- as.xts(sampleOneMinuteData[, makeReturns(STOCK), by = list(DATE = as.Date(DT))]) x &lt;- highfrequency::HARmodel(dat, periods = c(1,5,10), periodsJ = c(1,5,10), periodsQ = c(1), RVest = c(&quot;rCov&quot;, &quot;rQuar&quot;), type=&quot;HARQ&quot;, inputType = &quot;returns&quot;) class(x) #&gt; [1] &quot;HARmodel&quot; &quot;lm&quot; x #&gt; #&gt; Model: #&gt; RV1 = beta0 + beta1 * RV1 + beta2 * RV5 + beta3 * RV10 + beta4 * RQ1 #&gt; #&gt; Coefficients: #&gt; beta0 beta1 beta2 beta3 beta4 #&gt; 7.046e-05 -1.545e-01 1.686e-01 3.025e-01 1.023e+03 #&gt; Newey-West Standard Errors: #&gt; beta0 beta1 beta2 beta3 beta4 #&gt; 1.471e-05 9.588e-02 1.061e-01 9.461e-02 2.886e+02 #&gt; #&gt; #&gt; r.squared adj.r.squared #&gt; 0.6944 0.5198 plot(x) predict(x) #&gt; [1] 0.0001071019 12.2 共分散・相関の推定 2つの証券の一日内の取引データを使って, 両者の共分散や相関係数を推定したい. しかし, 個別取引のデータは等間隔に並んでないことから, データが同時観測されていない (非同期) 点を考慮する必要がある. 上記, highfrequencyパッケージの他, yuimaパッケージも利用可能である. データセット2: 株価指数先物データ 1日分 (2018年2月5日)のTOPIX, 日経平均それぞれの株価指数先物データ (中心限月, ラージサイズ). 時間解像度は1ミリ秒. 同時点タイムスタンプを持つ複数レコードが存在する. ここでは, 1タイムスタンプ1レコードに集約. 価格はVWAPを使用. library(yuima) yyyymmdd &lt;- 20180205 ifl1_0 &lt;- paste0(&quot;TXFTL-&quot;, yyyymmdd, &quot;-D.csv&quot;) ifl1 &lt;- file.path(idir, ifl1_0) TXFTL &lt;- read.csv(ifl1, header = F) ifl2_0 &lt;- paste0(&quot;NKFTL-&quot;, yyyymmdd, &quot;-D.csv&quot;) ifl2 &lt;- file.path(idir, ifl2_0) NKFTL &lt;- read.csv(ifl2, header = F) # zooクラス化 tx_zoo &lt;- zoo(TXFTL$V2, TXFTL$V1 / 1000) # Warning: uniqueでない nk_zoo &lt;- zoo(NKFTL$V2, NKFTL$V1 / 1000) # 1タイムスタンプ1レコード化 topixFTL &lt;- aggregate(tx_zoo, index(tx_zoo), mean) # unique timestamp nk225FTL &lt;- aggregate(nk_zoo, index(nk_zoo), mean) # unique timestamp # par(mfrow = c(2,1)) plot(topixFTL) plot(nk225FTL) # 対数リターン化 topixFTL_ret &lt;- diff(log(topixFTL)) nk225FTL_ret &lt;- diff(log(nk225FTL)) # 関数に入力する系列が, 価格か対数リターンかに注意すること 高頻度の価格時系列データの特徴 (stylized facts) ティック単位での動きが観察される 値段が動かない時間も散発的に発生 ジャンプ? (ティックデータの場合) 1変量は非等間隔観察. 2変量間では非同期観察 → “連続拡散過程”の実現値の特徴から乖離 “マーケット・マイクロストラクチャ・ノイズ”への対応 ジャンプへの対応 共分散・相関の推定 highfrequency::rHYCov(): Hayashi-Yoshida共分散推定量の計算 - 用法: rHYCov( rData, cor = FALSE, period = 1, alignBy = &quot;seconds&quot;, alignPeriod = 1, makeReturns = FALSE, makePsd = TRUE, ... ) - rData: (複数日・複数銘柄の) リターンまたは価格系列 (xts, またはdata.frame) - cor: 返す値は, 相関か共分散か - period: サンプル期間 - alignBy: alignPeriodの時間スケール. &quot;ticks&quot;, &quot;secs&quot;, &quot;seconds&quot;, &quot;mins&quot;, &quot;minutes&quot;, &quot;hours&quot; - alignPeriod: 合算する期間長. 例えば, alighnPeriod = 5, alighBy = &quot;mins&quot;なら５分間隔に集約 - makeReturns: リターンに変換するか. rDataが価格系列ならTを指定のこと. デフォルトはF - makePsd: Tならば, 正定値行列に修正. デフォルトはF ※ rHYCov()を実行する場合には, あらかじめ異なるタイムスタンプを持つ非同期のxtsオブジェクトを一つ (共通のタイムスタンプを持つ) オブジェクトにマージしておく必要. xtsは日付/時間のクラス (POSIXct等) に変換しておいたタイムスタンプをorder.byで指定する必要. library(lubridate) ftl2_zoo &lt;- merge(topixFTL_ret, nk225FTL_ret, all = T) # error! # Error: attempt to use zero-length variable name ymdhms_vec &lt;- lubridate::ymd_hms(paste(&quot;2018-02-05&quot;, hms::as.hms(index(ftl2_zoo)))) ftl2_xts &lt;- xts(ftl2_zoo, order.by = ymdhms_vec) hy &lt;- highfrequency::rHYCov(ftl2_xts, period = 5, alignBy = &quot;minutes&quot;, alignPeriod = 5, makeReturns = F) hy #&gt; [,1] [,2] #&gt; [1,] 0.0006409965 0.0001789956 #&gt; [2,] 0.0001789956 0.0019398864 yuima::cce: (非同期なタイムスタンプを持つ) 伊藤過程間の共分散を推定 - 用法: cce(x, method=&quot;HY&quot;, theta, kn, g=function(x)min(x,1-x), refreshing = TRUE, cwise = TRUE, delta = 0, adj = TRUE, K, c.two, J = 1, c.multi, kernel, H, c.RK, eta = 3/5, m = 2, ftregion = 0, vol.init = NA, covol.init = NA, nvar.init = NA, ncov.init = NA, mn, alpha = 0.4, frequency = 300, avg = TRUE, threshold, utime, psd = FALSE) - 詳細はマニュアル参照のこと - 一変量の時系列データを引数xに指定すれば, ボラティリティを推定することができる. # cf. https://cran.r-project.org/web/packages/yuima/yuima.pdf # yuima class data ft2 &lt;- Quote(yuima::setData(list(topixFTL_ret, nk225FTL_ret))) yuima::cce(ft2) # the Hayashi-Yoshida estimator; Hayashi and Yoshida (2005) 注) 執筆時点でのsetData()の仕様に基づいたコード (変更される可能性) # the Pre-averaged Hayashi-Yoshida estimator; Christensen et al. (2010) yuima::cce(ft2, method = &quot;PHY&quot;)$cormat # Pre-averaged Truncated Hayashi-Yoshida estimator yuima::cce(ft2, method = &quot;PTHY&quot;)$cormat # the Modulated Realized Covariance based on refresh time sampling; Christensen et al. (2010) yuima::cce(ft2, method = &quot;MRC&quot;)$cormat # Generalized multiscale estimator #yuima::cce(ft2, method = &quot;GME&quot;)$cormat # Multivariate realized kernel #yuima::cce(ft2, method = &quot;RK&quot;)$cormat # Method &quot;TSCV&quot; is an implementation of the previous tick Two Scales realized CoVariance based on refresh time sampling; Zhang (2011) #yuima::cce(ft2, method = &quot;TSCV&quot;)$cormat # the nonparametric Quasi Maximum Likelihood Estimator; Ait-Sahalia et al. (2010) yuima::cce(ft2, method = &quot;QMLE&quot;)$cormat # the Separating Information Maximum Likelihood estimator in Kunitomo and Sato (2013), with the basis of refresh time sampling yuima::cce(ft2, method = &quot;SIML&quot;)$cormat # the Truncated Hayashi-Yoshida estimator; Mancini and Gobbi (2012) yuima::cce(ft2, method = &quot;THY&quot;)$cormat # an implementation of the calendar time Subsampled realized BiPower Covariation #yuima::cce(ft2, method = &quot;SBPC&quot;)$cormat 12.3 ACDモデル ランダムに到着する取引の間隔データの持つ時系列構造を表現するモデルとして, 自己回帰条件付デュレーション (ACD) モデルを取り上げる. ここでは, 上で使用した株価指数先物データセット (topixFTL, nk225FTL) を使用する. デュレーション (取引間隔) 系列: library(tidyverse) library(lubridate) library(stringr) options(digits = 3) # デュレーション (取引間隔) dur_tx &lt;- diff(index(topixFTL)) dur_nk &lt;- diff(index(nk225FTL)) head(dur_tx) #&gt; [1] 0.030 0.336 0.001 0.002 0.001 0.003 head(dur_nk) #&gt; [1] 0.030 0.001 0.001 0.092 0.062 0.019 length(dur_tx) #&gt; [1] 10899 length(dur_nk) #&gt; [1] 7501 plot(dur_tx[1:300], type = &quot;l&quot;, main = &quot;duration (first 300)&quot;) ランダムに到着する取引の間隔データにおいても, クラスタリング現象が観察される. これを表現するためのモデルが自己回帰条件付デュレーション (ACD) モデルである. ACDモデルやそのバリエーションは, 取引が活発 (取引間隔が短く) なると, さらにそれがあらたな取引を呼び込むといった, 自己励起 (self-excitment) の現象を表現することができる. モデルの適合: acdFit: ACDモデルの適合 - 用法: acdFit(durations = NULL, model = &quot;ACD&quot;, dist = &quot;exponential&quot;, order = NULL, startPara = NULL, dailyRestart = 0, optimFnc = &quot;optim&quot;, method = &quot;Nelder-Mead&quot;, output = TRUE, bootstrapErrors = FALSE, forceErrExpec = TRUE, fixedParamPos = NULL, bp = NULL, exogenousVariables = NULL, control = list()) - model: 条件付平均の特定. &quot;ACD&quot;, &quot;LACD1&quot;, &quot;LACD2&quot;, &quot;AMACD&quot;, &quot;BACD&quot;, &quot;ABACD&quot;, &quot;SNIACD&quot;, &quot;LSNIACD&quot;の中から一つ選択. - dist: 誤差項の確率分布. &quot;exponential&quot;, &quot;weibull&quot;, &quot;burr&quot;, &quot;gengamma&quot;, &quot;genf&quot;, &quot;qweibull&quot;, &quot;mixqwe&quot;, &quot;mixqww&quot;, &quot;mixinvgauss&quot;の中から一つ選択. - order: ACDモデルの次数. 例えば, ACD(p, q)ならば, order = c(p, q)を指定. 以下では, 誤差項の確率分布として指数分布を, モデルとしてACD(1,1), LACD1(1,1), LACD2(1,1)の3つを選択. モデルは定常性を仮定することから, 実際に実証分析を行う際には, “非定常”な時間帯, 具体的には市場のオープン後やクローズ前の一定期間 (５分間, 10分間等) のデータを除いたり, また1日内の非確率的な季節性変動予め除去した系列に対して, これらのモデルの適合が行われる (diurnal adjustmentと呼ばれる). library(ACDm) distn &lt;- &quot;exponential&quot; mod0 &lt;- &quot;ACD&quot; mod1 &lt;- &quot;LACD1&quot; mod2 &lt;- &quot;LACD2&quot; # TOPIX先物 # ACD(1,1) fit_acd_tx &lt;- ACDm::acdFit(durations = dur_tx, model = mod0, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; ACD model estimation by (Quasi) Maximum Likelihood #&gt; #&gt; Call: #&gt; ACDm::acdFit(durations = dur_tx, model = mod0, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; Model: #&gt; ACD(1, 1) #&gt; #&gt; Distribution: #&gt; exponential #&gt; #&gt; N: 10899 #&gt; #&gt; Parameter estimate: #&gt; Coef SE PV robustSE #&gt; omega 1.4904 0.0523 0 0.373 #&gt; alpha1 0.6144 0.0334 0 0.281 #&gt; beta1 0.0871 0.0222 0 0.067 #&gt; #&gt; #&gt; The fixed/unfree mean distribution parameter: #&gt; lambda: 1 #&gt; #&gt; QML robust correlations: #&gt; omega alpha1 beta1 #&gt; omega 1.000 -0.217 -0.387 #&gt; alpha1 -0.217 1.000 -0.313 #&gt; beta1 -0.387 -0.313 1.000 #&gt; #&gt; #&gt; Goodness of fit: #&gt; value #&gt; LogLikelihood -19293 #&gt; AIC 38592 #&gt; BIC 38614 #&gt; MSE 1895 #&gt; #&gt; Convergence: 0 #&gt; #&gt; Number of log-likelihood function evaluations: 193 #&gt; #&gt; Estimation time: 0.04 secs #&gt; #&gt; Description: Estimated at 2024-03-19 13:24:52 by user takaki # LACD1(1,1) fit_lacd1_tx &lt;- ACDm::acdFit(durations = dur_tx, model = mod1, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; ACD model estimation by (Quasi) Maximum Likelihood #&gt; #&gt; Call: #&gt; ACDm::acdFit(durations = dur_tx, model = mod1, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; Model: #&gt; LACD1(1, 1) #&gt; #&gt; Distribution: #&gt; exponential #&gt; #&gt; N: 10899 #&gt; #&gt; Parameter estimate: #&gt; Coef SE PV #&gt; omega 0.940 0.02007 0 #&gt; alpha1 0.161 0.00371 0 #&gt; beta1 0.349 0.01807 0 #&gt; #&gt; #&gt; The fixed/unfree mean distribution parameter: #&gt; lambda: 1 #&gt; #&gt; Goodness of fit: #&gt; value #&gt; LogLikelihood -18491 #&gt; AIC 36987 #&gt; BIC 37009 #&gt; MSE 1373 #&gt; #&gt; Convergence: 0 #&gt; #&gt; Number of log-likelihood function evaluations: 140 #&gt; #&gt; Estimation time: 0.111 secs #&gt; #&gt; Description: Estimated at 2024-03-19 13:24:52 by user takaki # LACD2(1,1) fit_lacd2_tx &lt;- ACDm::acdFit(durations = dur_tx, model = mod2, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; ACD model estimation by (Quasi) Maximum Likelihood #&gt; #&gt; Call: #&gt; ACDm::acdFit(durations = dur_tx, model = mod2, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; Model: #&gt; LACD2(1, 1) #&gt; #&gt; Distribution: #&gt; exponential #&gt; #&gt; N: 10899 #&gt; #&gt; Parameter estimate: #&gt; Coef SE PV #&gt; omega 0.0832 0.012233 0 #&gt; alpha1 -0.0019 0.000276 0 #&gt; beta1 0.8975 0.015240 0 #&gt; #&gt; #&gt; The fixed/unfree mean distribution parameter: #&gt; lambda: 1 #&gt; #&gt; Goodness of fit: #&gt; value #&gt; LogLikelihood -19540 #&gt; AIC 39085 #&gt; BIC 39107 #&gt; MSE 1373 #&gt; #&gt; Convergence: 0 #&gt; #&gt; Number of log-likelihood function evaluations: 192 #&gt; #&gt; Estimation time: 0.0896 secs #&gt; #&gt; Description: Estimated at 2024-03-19 13:24:52 by user takaki # 日経平均先物 # ACD(1,1) fit_acd_nk &lt;- ACDm::acdFit(durations = dur_nk, model = mod0, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; ACD model estimation by (Quasi) Maximum Likelihood #&gt; #&gt; Call: #&gt; ACDm::acdFit(durations = dur_nk, model = mod0, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; Model: #&gt; ACD(1, 1) #&gt; #&gt; Distribution: #&gt; exponential #&gt; #&gt; N: 7501 #&gt; #&gt; Parameter estimate: #&gt; Coef SE PV robustSE #&gt; omega 0.00734 0.00153 0 0.00612 #&gt; alpha1 0.14555 0.00761 0 0.02283 #&gt; beta1 0.91804 0.00310 0 0.00858 #&gt; #&gt; #&gt; The fixed/unfree mean distribution parameter: #&gt; lambda: 1 #&gt; #&gt; QML robust correlations: #&gt; omega alpha1 beta1 #&gt; omega 1.000 -0.410 -0.692 #&gt; alpha1 -0.410 1.000 -0.137 #&gt; beta1 -0.692 -0.137 1.000 #&gt; #&gt; #&gt; Goodness of fit: #&gt; value #&gt; LogLikelihood -14762 #&gt; AIC 29531 #&gt; BIC 29552 #&gt; MSE 2277 #&gt; #&gt; Convergence: 0 #&gt; #&gt; Number of log-likelihood function evaluations: 184 #&gt; #&gt; Estimation time: 0.0224 secs #&gt; #&gt; Description: Estimated at 2024-03-19 13:24:52 by user takaki # LACD1(1,1) fit_lacd1_nk &lt;- ACDm::acdFit(durations = dur_nk, model = mod1, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; ACD model estimation by (Quasi) Maximum Likelihood #&gt; #&gt; Call: #&gt; ACDm::acdFit(durations = dur_nk, model = mod1, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; Model: #&gt; LACD1(1, 1) #&gt; #&gt; Distribution: #&gt; exponential #&gt; #&gt; N: 7501 #&gt; #&gt; Parameter estimate: #&gt; Coef SE PV #&gt; omega 0.1423 0.004049 0 #&gt; alpha1 0.0508 0.001426 0 #&gt; beta1 1.0041 0.000623 0 #&gt; #&gt; #&gt; The fixed/unfree mean distribution parameter: #&gt; lambda: 1 #&gt; #&gt; Goodness of fit: #&gt; value #&gt; LogLikelihood -13235 #&gt; AIC 26476 #&gt; BIC 26496 #&gt; MSE 2001 #&gt; #&gt; Convergence: 0 #&gt; #&gt; Number of log-likelihood function evaluations: 182 #&gt; #&gt; Estimation time: 0.094 secs #&gt; #&gt; Description: Estimated at 2024-03-19 13:24:52 by user takaki # LACD2(1,1) fit_lacd2_nk &lt;- ACDm::acdFit(durations = dur_nk, model = mod2, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; ACD model estimation by (Quasi) Maximum Likelihood #&gt; #&gt; Call: #&gt; ACDm::acdFit(durations = dur_nk, model = mod2, dist = distn, order = c(1, 1), output = T) #&gt; #&gt; Model: #&gt; LACD2(1, 1) #&gt; #&gt; Distribution: #&gt; exponential #&gt; #&gt; N: 7501 #&gt; #&gt; Parameter estimate: #&gt; Coef SE PV #&gt; omega 0.0229 0.001847 0 #&gt; alpha1 0.0028 0.000278 0 #&gt; beta1 0.9779 0.001666 0 #&gt; #&gt; #&gt; The fixed/unfree mean distribution parameter: #&gt; lambda: 1 #&gt; #&gt; Goodness of fit: #&gt; value #&gt; LogLikelihood -16185 #&gt; AIC 32377 #&gt; BIC 32398 #&gt; MSE 2003 #&gt; #&gt; Convergence: 0 #&gt; #&gt; Number of log-likelihood function evaluations: 160 #&gt; #&gt; Estimation time: 0.0549 secs #&gt; #&gt; Description: Estimated at 2024-03-19 13:24:52 by user takaki 推定パラメータ: # TOPIX先物 # summary(fit_acd_tx) # summary(fit_lacd1_tx) # summary(fit_lacd2_tx) fit_acd_tx$mPara #&gt; omega alpha1 beta1 #&gt; 1.4904 0.6144 0.0871 fit_lacd1_tx$mPara #&gt; omega alpha1 beta1 #&gt; 0.940 0.161 0.349 fit_lacd2_tx$mPara #&gt; omega alpha1 beta1 #&gt; 0.0832 -0.0019 0.8975 # 日経平均先物 fit_acd_nk$mPara #&gt; omega alpha1 beta1 #&gt; 0.00734 0.14555 0.91804 fit_lacd1_nk$mPara #&gt; omega alpha1 beta1 #&gt; 0.1423 0.0508 1.0041 fit_lacd2_nk$mPara #&gt; omega alpha1 beta1 #&gt; 0.0229 0.0028 0.9779 "],["スペクトル解析.html", "13 スペクトル解析 13.1 ARMAモデルのスペクトル密度 13.2 周期変動時系列のスペクトル密度 13.3 データ分析例 (1) 13.4 データ分析例 (2)", " 13 スペクトル解析 13.1 ARMAモデルのスペクトル密度 スペクトル密度の推定方法には, パラメトリック推定 ノンパラメトリック推定 がある. ここでは, AR(1), MA(1)モデルを取り上げ, シミュレーション・データによる計算例を示す (参考: BD, Ch.4) - spectrum: spec.arとspec.pgramを呼び出すwrapper関数 - method: &quot;pgram&quot; (デフォルト) または &quot;ar&quot; - spec.ar: パラメトリック推定 (ARモデル専用) - データxにARモデルを適合し (またはxとして適合結果オブジェクトを指定), 適合モデルのスペクトル密度を計算 - spec.pgram: ノンパラメトリック推定 (&quot;ピリオドグラム&quot;) - FFT (fast Fourier変換)を使用してピリオドグラムを計算. オプションとして, 修正Daniell平滑法 (両端のウェイトを半分にする移動平均) により平滑化 AR(1)モデル #par(mfrow=c(3,1)) Tlen &lt;- 100 phi &lt;- c(0.7); theta = NULL; sigma &lt;- 1 set.seed(10) x &lt;- arima.sim(n = Tlen, model = list(order = c(1, 0, 0), ar = phi, ma = theta), sd = sigma) #plot(x, type = &quot;l&quot;) # 時系列プロット # ACF/PACFの計算 par(mfrow = c(1, 2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) # パラメトリック推定 x_spec &lt;- spec.ar(x) # AR次数(order)は無指定の場合, AICで自動選択 # ピリオドグラム x_spec &lt;- spectrum(x) x_spec &lt;- spectrum(x, spans = 2) # 平滑化ピリオドグラム x_spec &lt;- spectrum(x, spans = 4) # AR1過程のスペクトル密度(理論値) specden_AR1_true &lt;- function(lambda, phi, sigma){ sigma^2 / (2 * pi) /(1 - 2 * phi * cos(lambda) + phi^2) } #curve(specden_AR1_true, from = 0, to = 3) l_freq &lt;- seq(0, 3, 0.01) gmain &lt;- paste0(&quot;Spectral density of AR(1):\\nphi1=&quot;, phi) l_spec_true &lt;- specden_AR1_true(l_freq, phi, sigma) plot(l_freq, l_spec_true, type = &quot;l&quot;, main = gmain, ylab = &quot;spectral density&quot;, xlab = &quot;frequency&quot;) MA(1)モデル phi &lt;- NULL; theta &lt;- c(0.9); sigma &lt;- 1 set.seed(10) x &lt;- arima.sim(n = Tlen, model = list(order = c(0, 0, 1), ar = phi, ma = theta)) #plot(x, type = &quot;l&quot;) # 時系列プロット # ACF/PACFの計算 par(mfrow = c(1, 2)) acf(x) # 自己相関(ACF) pacf(x) # 偏自己相関(PACF) # ピリオドグラム x_spec &lt;- spectrum(x) x_spec &lt;- spectrum(x, span = 2) # 平滑化ピリオドグラム x_spec &lt;- spectrum(x, span = 4) # 平滑化ピリオドグラム # MA(1)過程のスペクトル密度(理論値) specden_MA1_true &lt;- function(lambda, theta, sigma){ sigma^2 / (2 * pi) * (1 + 2 * theta * cos(lambda) + theta^2) } #curve(specden.AR1.true, from = 0, to = 3) x_freq &lt;- seq(0, 3, 0.01) gmain &lt;- paste0(&quot;Spectral density of MA(1):\\ntheta1=&quot;, theta) x_spec_true &lt;- specden_MA1_true(x_freq, theta, sigma) plot(x_freq, x_spec_true, type = &quot;l&quot;, main = gmain, ylab = &quot;spectral density&quot;, xlab = &quot;frequency&quot;) 13.2 周期変動時系列のスペクトル密度 正弦波でスペクトル密度の形状を確認する. - ノイズなしの場合: n &lt;- 200 x &lt;- c(1:n) y &lt;- 5 + 4*cos(2 * pi * x / 10 + 2.5) plot(x, y, type = &quot;l&quot;); title(&quot;Pure periodic series&quot;) # smoothed peridogram y_spec &lt;- spec.pgram(y, fast = F, taper = 0.0) \\(f = 0.1\\)の点でピークがあることが分かる. これは, 時点が1ステップ進む (\\(t_{i-1} \\rightarrow t_i\\)) ごとに\\(0.1\\)周だけ進むような周波数 (周期\\(T=10\\)) を持つ正弦波成分があることを意味する ノイズ有りの場合 err &lt;- rnorm(n, 0, 0.25) y2 &lt;- y + err plot(x, y2, type = &quot;l&quot;); title(&quot;cosine with noise&quot;) y2_spec &lt;- spec.pgram(y2, fast = F, taper = 0.0) # 対数スケール y2_spec &lt;- spec.pgram(y2, fast = F, taper = 0.0, log = &quot;no&quot;) # 線形スケール ノイズ有りの系列の場合でも, \\(f=0.1\\)の周波数を識別することができる. y3 &lt;- y + 2 * sin(2 * pi * x / 5) + err plot(x, y3, type = &quot;l&quot;); title(&quot;cosine &amp; sine waves with noise&quot;) y3_spec &lt;- spec.pgram(y3, fast = F, taper = 0.0) # 対数スケール (デフォルト) y3_spec &lt;- spec.pgram(y3, fast = F, taper = 0.0, log = &quot;no&quot;) # 線形スケール 追加で加えた余弦波成分の周波数は1時点ごとに0.2周進むこと (\\(f=0.2\\), \\(T=5\\)), さらに, 正弦波と余弦波の2つの成分のパワーの比は4 (振幅の比の2乗) であることも確認できる. 13.3 データ分析例 (1) データセット1: sunspots sunspots: - 月平均黒点相対数 (Monthly mean relative sunspot numbers), 1749年1月--1983年12月. head(sunspots) ## [1] 58.0 62.6 70.0 55.7 85.0 83.5 newsun &lt;- sunspots[12:100] - sunspots[1:89] (sun_ar &lt;- ar.yw(newsun)) ## ## Call: ## ar.yw.default(x = newsun) ## ## Coefficients: ## 1 ## 0.5014 ## ## Order selected 1 sigma^2 estimated as 353.2 plot(sun_ar$aic, xlab = &quot;Order&quot;, ylab = &quot;AIC&quot;) plot(sun_ar$resid, xlab = &quot;Year&quot;, ylab = &quot;Residual from AR Model&quot;) #abline(h = 0, col = &quot;red&quot;) # R Markdownでエラー → コメントアウト acf(sun_ar$resid[-1]) # エラー発生 → 第1要素除去 ノンパラメトリック推定 sun_spec_pgrm &lt;- spec.pgram(sunspots, fast = F, taper = 0.0) names(sun_spec_pgrm) ## [1] &quot;freq&quot; &quot;spec&quot; &quot;coh&quot; &quot;phase&quot; &quot;kernel&quot; &quot;df&quot; ## [7] &quot;bandwidth&quot; &quot;n.used&quot; &quot;orig.n&quot; &quot;series&quot; &quot;snames&quot; &quot;method&quot; ## [13] &quot;taper&quot; &quot;pad&quot; &quot;detrend&quot; &quot;demean&quot; plot(sun_spec_pgrm$freq, sun_spec_pgrm$spec, type = &quot;l&quot;) パラメトリック推定 sun_spec_ar &lt;- spec.ar(sunspots) # AR次数(order)は無指定の場合, AICで自動選択 sun_spec_ar2 &lt;- spec.ar(sunspots, order = 2) # AR(2) データセット2: SOI Southern Oscillation Index (南方振動指数): - 南太平洋上のタヒチとオーストラリアの都市ダーウィンとの気圧差を指数化したもの. - 貿易風の強さの目安の一つ. 正の値は貿易風が強いことを表す. - エルニーニョ発生時はマイナスを示す傾向. 出所: Wikipedia (アクセス 1/27/23) Rパッケージrsoiの関数によりSOIのデータセットを入手が可能. - download_soi(): Download Southern Oscillation Index data - Date: Date object that uses the first of the month as a placeholder. Date formatted as date on the first of the month because R only supports one partial of date time - Month: Month of record - Year: Year of record - SOI: Southern Oscillation Index - SOI_3MON_AVG: 3 Month Average Southern Oscillation Index -3ヶ月平均は対称平均 #install.packages(&quot;rsoi&quot;) require(rsoi) require(tidyverse) soi &lt;- download_soi() soi_2 &lt;- soi %&gt;% tidyr::drop_na(SOI) # 未観測月除去 soi_ts &lt;- ts(soi_2$SOI, start = 1951, frequency = 12) dsoi_ts &lt;- diff(soi_ts) library(forecast) soi_ma12 &lt;- ma(soi_ts, order = 12, centre = TRUE) layout(1:3) plot(soi_ts, main = &quot;SOI Index&quot;) plot(dsoi_ts, main = &quot;First difference of SOI Index&quot;) plot(soi_ma12, main = &quot;Centered 12-month moving average of SOI Index&quot;) ノンパラメトリック推定 # Periodogram #layout(1:3) soi_spec_pgram &lt;- spec.pgram(soi_ts, spans = 2, fast = F, taper = 0.0, log = &quot;no&quot;) soi_spec_pgram &lt;- spec.pgram(soi_ts, spans = 4, fast = F, taper = 0.0, log = &quot;no&quot;) soi_spec_pgram &lt;- spec.pgram(soi_ts, spans = 6, fast = F, taper = 0.0, log = &quot;no&quot;) soi_spec_pgram &lt;- spec.pgram(soi_ts, fast = F, taper = 0.0, log = &quot;no&quot;) soi_spec_pgram &lt;- spec.pgram(soi_ts, fast = F, taper = 0.1, log = &quot;no&quot;) soi_spec_pgram &lt;- spec.pgram(soi_ts, fast = F, taper = 0.2, log = &quot;no&quot;) パラメトリック推定 # Parametric estimation soi_spec_ar &lt;- spec.ar(soi_ts) データセット3: 銀行プライムローン金利 &quot;MPRIME.csv&quot;: - 月次 米国FRB 銀行プライムローン金利 (prime loan rate) - データ出所: Federal Reserve Economic Data at the Federal Reserve Bank of St. Louis.(https://fred.stlouisfed.org/series/MPRIME)[https://fred.stlouisfed.org/series/MPRIME] ifl &lt;- &quot;MPRIME.csv&quot; intrate &lt;- read.csv(ifl)$MPRIME layout(1:3) plot(as.ts(intrate), ylab = &quot;intrate rate&quot;) acf(intrate) spectrum(intrate, spans = 4) → 長期記憶性を示唆 データセット4: 事故死者数 データ出所: BD(96) deaths.dat - 米国における月別事故死者数, 1973--1978年. #idir &lt;- &quot;/Users/takaki/G_Drive_th_keio/datasets_storage/FTS_datasets_storage/&quot; idir &lt;- &quot;.&quot; ifl &lt;- file.path(idir, &quot;deaths.dat&quot;) deaths &lt;- read.csv(ifl, header = F, skip = 6) deaths &lt;- unlist(deaths) deaths_ts &lt;- ts(deaths, start = 1973, freq = 12) ノンパラメトリック推定 # Periodogram z_deaths &lt;- spec.pgram(deaths_ts, fast=F, taper = 0.0,log = &quot;no&quot;) 季節性成分のモデル適合 # Fitting Seasonal Component deaths_mean &lt;- deaths - mean(deaths_ts) # mean corrected series n &lt;- length(deaths_ts) tt &lt;- c(1:n) col_1 &lt;- rep(1, n) col_c &lt;- cos(2 * pi * tt / 12) col_s &lt;- sin(2 * pi * tt / 12) x &lt;- cbind(col_1, col_c, col_s) fit_deaths &lt;- lm(deaths_mean~ -1 + x) # no intercept needed; # it is included in X; summary(fit_deaths)[4] ## $coefficients ## Estimate Std. Error t value Pr(&gt;|t|) ## xcol_1 -14.45934 73.46755 -0.1968126 8.445612e-01 ## xcol_c -1026.61316 104.63831 -9.8110640 1.183987e-14 ## xcol_s -249.28018 103.15400 -2.4165827 1.835613e-02 適合モデルによる予測 # Predictions vs Observations preds_ts &lt;- ts(fit_deaths$fit, start = 1973, freq = 12) # turning predictions from linear # model into a time series object; plot(deaths_ts, ylab = &quot;thousands&quot;); lines(preds_ts + mean(deaths_ts), lty = 2, col = &quot;blue&quot;) legend(&quot;topright&quot;, c(&quot;obs&quot;, &quot;pred&quot;), lty = c(1, 2), col=c(&quot;black&quot;, &quot;blue&quot;), bty = &quot;n&quot; ) 13.4 データ分析例 (2) スペクトル解析への理解を深めるため, ここでは探索的に 為替レート (EUR/USD, 月次) に対するスペクトル解析を試みる. 事前の知識に頼らずに, まず為替レートの水準およびリターンの 各系列に対してスペクトル解析を行ったらどうなるかを観察する. また, 各系列を分解モデルにより分解して, それぞれの成分に 対してスペクトル解析を行ってみる. library(&#39;quantmod&#39;) # library(&#39;tidyverse&#39;) # getSymbols(&quot;DEXUSEU&quot;, src = &quot;FRED&quot;) # USD/EUR daily spot rate from FRED ## [1] &quot;DEXUSEU&quot; head(DEXUSEU) ## DEXUSEU ## 1999-01-04 1.1812 ## 1999-01-05 1.1760 ## 1999-01-06 1.1636 ## 1999-01-07 1.1672 ## 1999-01-08 1.1554 ## 1999-01-11 1.1534 tail(DEXUSEU) ## DEXUSEU ## 2024-03-08 1.0941 ## 2024-03-11 1.0928 ## 2024-03-12 1.0918 ## 2024-03-13 1.0944 ## 2024-03-14 1.0888 ## 2024-03-15 1.0888 # 休日(NA)処理 eurusd &lt;- DEXUSEU %&gt;% na.locf() # NAは直近の値を埋める # 月次データ化 # 月末だけのインデックス抽出 (最終データは月末とは限らないので除去) idx_mlast &lt;- endpoints(eurusd) # 為替水準 (月次) eurusd_m &lt;- eurusd[idx_mlast[- length(idx_mlast)]] # 為替リターン (月次) eurusd_m_lret &lt;- diff(log(eurusd_m)) %&gt;% na.omit() d1 &lt;- first(index(eurusd_m)) eu_m_ts &lt;- ts(eurusd_m, start = c(year(d1), month(d1)) , frequency = 12) spectrum(eu_m_ts, log = &quot;no&quot;) spectrum(eu_m_ts, method = &quot;ar&quot;, log = &quot;no&quot;) → トレンドの存在 (非定常性) を示唆 d1 &lt;- first(index(eurusd_m_lret)) eu_m_ts &lt;- ts(eurusd_m_lret, start = c(year(d1), month(d1)) , frequency = 12) spectrum(eu_m_ts) spectrum(eu_m_ts, method = &quot;ar&quot;) - → (ほぼ)白色ノイズ spectrum(eu_m_ts^2, method = &quot;ar&quot;) # → AR(3) spectrum(eu_m_ts^2) #spectrum(abs(eu_m_ts), method = &quot;ar&quot;) # → AR(2) ARCH効果を反映 為替水準に対する分解 &amp; スペクトル解析 (古典的)分解モデルを使って, 為替水準を周期成分・トレンド成分・定常成分に分解し, それぞれのスペクトル密度を確認する. # 古典的分解 eu_decom &lt;- decompose(eu_m_ts) # additive #eu_decom &lt;- decompose(eu, type = &quot;mult&quot;) # multiplicative plot(eu_decom) # 乗法モデル # eu_decom_mult &lt;- decompose(eu_m_ts, type = &quot;multiplicative&quot;) # plot(eu_decom_mult) # 代替的方法 # stl(), Seasonal Decomposition of Time Series by Loess # loess(locally weighted regression)によるsmoothingを行い, 3成分に分解 #stl(eu_m_ts, s.window = &quot;periodic&quot;) #stl(eu_m_ts, s.window = 7) # トレンドおよびランダム成分は, NA有り → 欠損値処理が必要 spectrum(eu_decom$trend %&gt;% na.omit(), log = &quot;no&quot;) spectrum(eu_decom$seasonal, log = &quot;no&quot;) # → decomp()のアルゴリズム反映 spectrum(eu_decom$random %&gt;% na.omit(), log = &quot;no&quot;) spectrum(eu_decom$random %&gt;% na.omit(), method = &quot;ar&quot;, log = &quot;no&quot;) # y軸のスケールは, デフォルトはlogスケール (&quot;yes&quot;) トレンドの存在. 絶対値の大きさ, 圧倒的に大 季節性はfreq = 1,…6 (1年当たりのサイクル数) → Nyquist freq = 1月に0.5サイクル 但し, 絶対値は3要素の内最小 (→ (抽出された方法での)季節性成分は無視出来るほど小さい) 定常成分 (ランダム項) は1位55, 2位115, 3位198でピーク(500点中, ARのケース) (ARだと季節性よりは桁が1桁大きいがトレンドより圧倒的に小さい) 周波数が2/3, 4/3付近にピーク (1年間に3分の2回, 3分の4回の回転相当) 為替リターンに対する分解 &amp; スペクトル解析 (古典的)分解モデルを使って, 為替リターンを周期成分・トレンド成分・定常成分に分解し, それぞれのスペクトル密度を確認する. # 古典的分解 eu_decom &lt;- decompose(eu_m_ts) # additive #eu_decom &lt;- decompose(eu, type = &quot;mult&quot;) # multiplicative plot(eu_decom) # トレンドおよびランダム成分は, NA有り → 欠損値処理が必要 spectrum(eu_decom$trend %&gt;% na.omit(), log = &quot;no&quot;)#, main = &quot;monthly EURUSD: return\\ntrend&quot;) spectrum(eu_decom$seasonal, log = &quot;no&quot;)#, main = &quot;monthly EURUSD: return\\nseasonality&quot;) # → decomp()のアルゴリズム反映 spectrum(eu_decom$random %&gt;% na.omit(), log = &quot;no&quot;)#, main = &quot;monthly EURUSD: return\\nrandom&quot;) spectrum(eu_decom$random %&gt;% na.omit(), method = &quot;ar&quot;, log = &quot;no&quot;)#, main = &quot;monthly EURUSD: return\\nrandom&quot;) 3成分の桁, 差なし. 最大値はむしろ定常成分 (ランダム項) そもそも白色ノイズを無理に分解しようとしているため ここでは, スペクトル解析への理解を深めることを主眼に, 成分分解 → スペクトル解析 (スペクトル密度の形状確認) を行ったが, モデリングの観点では, スペクトル解析 → 分解モデルの構築のフローが重要 (特に, 季節性成分のモデリングにおいて, 分析対象の周期性に関する事前の知識がない場合. 上の事故死者数データの 分析を参照) prophetモデルでは, 季節性成分に調和回帰が使われる (正弦波・余弦波を説明変数に持つ回帰モデル) cf. https://facebook.github.io/prophet/docs/multiplicative_seasonality.html "],["動的線形モデル.html", "14 動的線形モデル 14.1 パッケージdlm 14.2 パッケージstatespacer 14.3 パッケージbssm", " 14 動的線形モデル 本章では, 動的線形モデル (Dynamic Linear Models) を扱うRパッケージを幾つか取り上げ, 利用方法を紹介する. 特に, 共通のデータセット (ナイル川の年間流量) に対する共通のモデル (local levelモデル, ランダムウォーク+ノイズ・モデル) を用いて, 各々のパッケージにおける操作 (フィルタリング・平滑化 (スムージング)・予測等) を行い, 使い勝手を比較する. - Nileデータセット - アスワン (Aswan) におけるナイル川の年間流量の計測量 - 1871--1970年 (単位 10^8立方メートル) - 1898年付近に変化点が見られる (Cobb(1978), Table 1, p.249） 14.1 パッケージdlm 出所: Petris, Petrone, and Campagnoli (2009). Dynamic Linear Models with R. Springer. パッケージdlmについて: - 動的線形モデル (DLM) のベイズ分析用パッケージ - DLMのパラメータの最尤推定とカルマン・フィルターの関数を含む - dlm()関数: Dynamic Linear Objectsの生成 - dlmModReg()関数: 線形回帰モデルのDLM表現 - dlmModPoly()関数: $n$-次多項式DLM表現 - order=1: local level(ランダムウォーク+ノイズ) - order=2: stochastic linear trend (局所線形トレンドモデル)(デフォルト) - dlmModSeas()関数: 季節成分のDLM表現 - dlmModTrig()関数: 周期成分のDLM表現 - dlmModARMA()関数: (多変量)ARMA過程のDLM表現 - dlmModReg()関数 - dV: 観測ノイズ$V$ - dW: システムノイズの共分散行列$W$対角成分 - m0: 状態ベクトル初期値の期待値$m0$ - C0: 状態ベクトル初期値の共分散行列$C0$ 以下の実行結果の解説, Petris, et al.(2009), Ch.2を参照 library(dlm) ## Linear regression as a DLM x &lt;- matrix(rnorm(10),ncol = 2) # 説明変数 (デザイン行列) mod &lt;- dlmModReg(x) # is.dlm(mod) mod ## $FF ## [,1] [,2] [,3] ## [1,] 1 1 1 ## ## $V ## [,1] ## [1,] 1 ## ## $GG ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 ## ## $W ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## [3,] 0 0 0 ## ## $JFF ## [,1] [,2] [,3] ## [1,] 0 1 2 ## ## $X ## [,1] [,2] ## [1,] 0.2349 -0.5491 ## [2,] -2.06 -1.161 ## [3,] ... ## ## $m0 ## [1] 0 0 0 ## ## $C0 ## [,1] [,2] [,3] ## [1,] 1e+07 0e+00 0e+00 ## [2,] 0e+00 1e+07 0e+00 ## [3,] 0e+00 0e+00 1e+07 ## Adding dlm&#39;s # dlmModPoly() + dlmModSeas(4) # linear trend plus quarterly seasonal component - dlmModPoly()関数: $n$-次多項式DLMの生成 - order=1: local level(ランダムウォーク+ノイズ) - order=2: stochastic linear trend (局所線形トレンドモデル)(デフォルト) ## the default dlmModPoly() ## $FF ## [,1] [,2] ## [1,] 1 0 ## ## $V ## [,1] ## [1,] 1 ## ## $GG ## [,1] [,2] ## [1,] 1 1 ## [2,] 0 1 ## ## $W ## [,1] [,2] ## [1,] 0 0 ## [2,] 0 1 ## ## $m0 ## [1] 0 0 ## ## $C0 ## [,1] [,2] ## [1,] 1e+07 0e+00 ## [2,] 0e+00 1e+07 ## random walk plus noise dlmModPoly(1, dV = .3, dW = .01) ## $FF ## [,1] ## [1,] 1 ## ## $V ## [,1] ## [1,] 0.3 ## ## $GG ## [,1] ## [1,] 1 ## ## $W ## [,1] ## [1,] 0.01 ## ## $m0 ## [1] 0 ## ## $C0 ## [,1] ## [1,] 1e+07 local levelモデル cf. https://kevinkotze.github.io/ts-4-tut/ local level modelの例 ts.plot(Nile) NilePoly &lt;- dlmModPoly(order = 1, dV = 15100, dW = 1468) unlist(NilePoly) ## m0 C0 FF V GG W ## 0 10000000 1 15100 1 1468 フィルタリング 最新の観測値に基づいて, 現在の状態を推定 Kalman filterによる, 状態空間ベクトルのフィルター値と, 分散共分散行列の計算 NileFilt &lt;- dlmFilter(Nile, NilePoly) #str(NileFilt, 1) n &lt;- length(Nile) attach(NileFilt) #dlmSvd2var(U.C[[n + 1]], D.C[n + 1, ]) S/N比 (\\(W/V\\)), Kalman”ゲイン”を決める重要な要因 観測値の変動に対する状態の(事前→事後)更新の感応度合い plot(Nile, type = &#39;o&#39;, col = c(&quot;darkgrey&quot;), xlab = &quot;&quot;, ylab = &quot;Level&quot;) mod1 &lt;- dlmModPoly(order = 1, dV = 15100, dW = 755) NileFilt1 &lt;- dlmFilter(Nile, mod1) lines(dropFirst(NileFilt1$m), lty = &quot;longdash&quot;) mod2 &lt;- dlmModPoly(order = 1, dV = 15100, dW = 7550) NileFilt2 &lt;- dlmFilter(Nile, mod2) lines(dropFirst(NileFilt2$m), lty = &quot;dotdash&quot;) leg &lt;- c(&quot;data&quot;, paste(&quot;filtered, W/V =&quot;, format(c(W(mod1) / V(mod1), W(mod2) / V(mod2))))) legend(&quot;bottomright&quot;, legend = leg, col=c(&quot;darkgrey&quot;, &quot;black&quot;, &quot;black&quot;), lty = c(&quot;solid&quot;, &quot;longdash&quot;, &quot;dotdash&quot;), pch = c(1, NA, NA), bty = &quot;n&quot;) スムージング (平滑化) 最新時点までの全観測値を使い, 過去の全時点の状態を推定(し直す) NileSmooth &lt;- dlmSmooth(NileFilt) str(NileSmooth, 1) ## List of 3 ## $ s : Time-Series [1:101] from 1870 to 1970: 1111 1111 1111 1105 1113 ... ## $ U.S:List of 101 ## $ D.S: num [1:101, 1] 74.1 63.5 56.9 53.1 50.9 ... attach(NileSmooth) drop(dlmSvd2var(U.S[[n + 1]], D.S[n + 1,])) ## [1] 4031.035 drop(dlmSvd2var(U.C[[n + 1]], D.C[n + 1,])) ## [1] 4031.035 drop(dlmSvd2var(U.S[[n / 2 + 1]], D.S[n / 2 + 1,])) ## [1] 2325.985 drop(dlmSvd2var(U.C[[n / 2 + 1]], D.C[n / 2 + 1,])) ## [1] 4031.035 hwid &lt;- qnorm(0.025, lower = FALSE) * sqrt(unlist(dlmSvd2var(U.S, D.S))) smooth &lt;- cbind(s, as.vector(s) + hwid %o% c(-1, 1)) plot(dropFirst(smooth), plot.type = &quot;s&quot;, type = &quot;l&quot;, lty = c(1, 5, 5), ylab = &quot;Level&quot;, xlab = &quot;&quot;, ylim = range(Nile)) lines(Nile, type = &quot;o&quot;, col = &quot;darkgrey&quot;) legend(&quot;bottomleft&quot;, col = c(&quot;darkgrey&quot;, rep(&quot;black&quot;, 2)), lty = c(1, 1, 5), pch = c(1, NA, NA), bty = &quot;n&quot;, legend = c(&quot;data&quot;, &quot;smoothed level&quot;, &quot;95% probability limits&quot;)) 予測 a &lt;- window(cbind(Nile, NileFilt1$f, NileFilt2$f), start = 1880, end = 1920) plot(a[, 1], type = &#39;o&#39;, col = &quot;darkgrey&quot;, xlab = &quot;&quot;, ylab = &quot;Level&quot;) lines(a[, 2], lty = &quot;longdash&quot;) lines(a[, 3], lty = &quot;dotdash&quot;) leg &lt;- c(&quot;data&quot;, paste(&quot;one-step-ahead forecast, W/V =&quot;, format(c(W(mod1) / V(mod1), W(mod2) / V(mod2))))) legend(&quot;bottomleft&quot;, legend = leg, col = c(&quot;darkgrey&quot;, &quot;black&quot;, &quot;black&quot;), lty = c(&quot;solid&quot;, &quot;longdash&quot;, &quot;dotdash&quot;), pch = c(1, NA, NA), bty = &quot;n&quot;) mod0 &lt;- dlmModPoly(order = 1, dV = 15100, dW = 1468) X &lt;- ts(matrix(mod0$W, nc = 1, nr = length(Nile)), start = start(Nile)) window(X, 1898, 1899) &lt;- 12 * mod0$W modDam &lt;- mod0 modDam$X &lt;- X modDam$JW &lt;- matrix(1, 1, 1) damFilt &lt;- dlmFilter(Nile, modDam) mod0Filt &lt;- dlmFilter(Nile, mod0) a &lt;- window(cbind(Nile, mod0Filt$f, damFilt$f), start = 1880, end = 1920) plot(a[, 1], type = &#39;o&#39;, col = &quot;darkgrey&quot;, xlab = &quot;&quot;, ylab = &quot;Level&quot;) lines(a[, 2], lty = &quot;longdash&quot;) lines(a[, 3], lty = &quot;dotdash&quot;) abline(v = 1898, lty = 2) leg &lt;- c(&quot;data&quot;, paste(&quot;one-step-ahead forecast -&quot;, c(&quot;mod0&quot;, &quot;modDam&quot;))) legend(&quot;bottomleft&quot;, legend = leg, col = c(&quot;darkgrey&quot;, &quot;black&quot;, &quot;black&quot;), lty = c(&quot;solid&quot;, &quot;longdash&quot;, &quot;dotdash&quot;), pch = c(1, NA, NA), bty = &quot;n&quot;) モデル診断 qqnorm(residuals(damFilt, sd = FALSE)) qqline(residuals(damFilt, sd = FALSE)) tsdiag(damFilt) local level plus seasonal componentモデル データ2: 英国における耐久消費財の消費支出 (四半期ベース), 1957Q1–1967Q4, Time Series Data Library: https://robjhyndman.com/tsdl/) 出所: Petris, etal (2009), p.64– - qconsum.dat - quarterly consumer expenditure - durable goods - all other goods and services - investment - inventory investment - imports of goods and services - gross domestic product - personal disposable income - Source: (Hyndman (n.d.) expd &lt;- ts(read.table(&quot;qconsum.dat&quot;, skip = 4, colClasses = &quot;numeric&quot;)[, 1], start = c(1957, 1), frequency = 4) expd.dlm &lt;- dlm(m0 = rep(0,4), C0 = 1e8 * diag(4), FF = matrix(c(1, 1, 0, 0), nr = 1), V = 1e-3, GG = bdiag(matrix(1), matrix(c(-1, -1, -1, 1, 0, 0, 0, 1, 0), nr = 3, byrow = TRUE)), W = diag(c(771.35, 86.48, 0, 0), nr = 4)) plot(expd, xlab = &quot;&quot;, ylab = &quot;Expenditures&quot;, type = &#39;o&#39;, col = &quot;darkgrey&quot;) ### Filter expdFilt &lt;- dlmFilter(expd, expd.dlm) lines(dropFirst(expdFilt$m[, 1]), lty = &quot;dotdash&quot;) ### Smooth expdSmooth &lt;- dlmSmooth(expdFilt) lines(dropFirst(expdSmooth$s[,1]), lty = &quot;longdash&quot;) legend(&quot;bottomright&quot;, col = c(&quot;darkgrey&quot;, rep(&quot;black&quot;, 2)), lty = c(&quot;solid&quot;, &quot;dotdash&quot;, &quot;longdash&quot;), pch = c(1, NA, NA), bty = &quot;n&quot;, legend = c(&quot;data&quot;, &quot;filtered level&quot;, &quot;smoothed level&quot;)) ### Seasonal component plot(dropFirst(expdSmooth$s[, 3]), type = &#39;o&#39;, xlab = &quot;&quot;, ylab = &quot;Expenditure - Seasonal component&quot;) abline(h = 0) 予測 set.seed(1) expdFore &lt;- dlmForecast(expdFilt, nAhead = 12, sampleNew = 10) plot(window(expd, start = c(1964, 1)), type = &#39;o&#39;, xlim = c(1964, 1971), ylim = c(350, 850), xlab = &quot;&quot;, ylab = &quot;Expenditures&quot;) names(expdFore) ## [1] &quot;a&quot; &quot;R&quot; &quot;f&quot; &quot;Q&quot; &quot;newStates&quot; &quot;newObs&quot; attach(expdFore) invisible(lapply(newObs, function(x) lines(x, col = &quot;darkgrey&quot;, type = &#39;o&#39;, pch = 4))) lines(f, type = &#39;o&#39;, lwd = 2, pch = 16) abline(v = mean(c(time(f)[1], time(expd)[length(expd)])), lty = &quot;dashed&quot;) detach() その他 未知パラメータの推定(特に, \\(V,W\\))は, dlmMLE()関数により最尤推定が可能 代替法. ベイズ推定 詳細は, Petris, et al. (2009), Ch.4を参照のこと 参考文献 Giovanni Petris (2010). An R Package for Dynamic Linear Models. Journal of Statistical Software, 36(12), 1-16. http://www.jstatsoft.org/v36/i12/. 14.2 パッケージstatespacer 出所: Introduction to statespacer パッケージstatespacerについて: 状態空間モデルにおける以下の成分をカバー： The Local Level The Local Level + Slope Smoothing Splines Trigonometric Seasonality, BSM (Business) Cycles Explanatory Variables Explanatory Variables with time-varying coefficients Explanatory Variables in the Local Level Explanatory Variables in the Local Level + Slope ARIMA SARIMA 独自に指定した成分 これらの成分は, 一変量モデルにも多変量モデルにも使用可能. 成分を組み合わせることも可能. 各ユーザーは, 各成分の分散-共分散行列の形式をコントロールすることで, 成分を確率的ではなく非確率的に指定可能. 多変量の場合, 分散-共分散行列にランク制約を課すことで, 共通のレベルや傾きなど, 成分中の共通性が推定されるようにすることも可能. install.packages(&quot;statespacer&quot;) # install.packages(&quot;devtools&quot;) # devtools::install_github(&quot;DylanB95/statespacer&quot;) # Load statespacer library(statespacer) local levelモデル ナイル川データセットに対して, local levelモデルを適用. - local levelモデル. 観測変数 \\(y_t\\) に対して, \\[ y_t = \\mu_t + \\epsilon_t,\\ \\epsilon_t \\sim 𝑁(0,\\sigma^2_\\epsilon) \\\\ \\mu_{t+1} = \\mu_t + \\eta_t,\\ \\eta_t \\sim 𝑁(0,\\sigma^2_\\eta) \\] ここで, \\(\\mu_t\\)は時点\\(t\\)における (未知の) 水準 (level), \\(\\epsilon_t,\\eta_t\\)は攪乱項. このモデルは, 二つの未知パラメータ\\(\\sigma^2_\\epsilon,\\sigma^2_\\eta\\) (攪乱項の分散) を持ち, これらは最尤法により求められる. 状態変数 \\(\\mu_t\\) はKalman filterにより推定される. ナイル川データセットの読み込み # Load the dataset library(datasets) y &lt;- matrix(Nile) local levelモデルの適合 fit &lt;- statespacer(y = y, local_level_ind = TRUE, initial = 0.5 * log(var(y)), verbose = TRUE) ## Parameter scaling:[1] 1 1 ## initial value 6.623273 ## iter 10 value 6.334646 ## final value 6.334646 ## converged 攪乱項の分散\\(\\sigma^2_\\epsilon,\\sigma^2_\\eta\\)の推定値の確認. c(fit$system_matrices$H$H, fit$system_matrices$Q$level) ## [1] 15100.252 1468.724 推定されたレベル plot(1871:1970, fit$function_call$y, type = &#39;p&#39;, ylim = c(500, 1400), xlab = NA, ylab = NA, sub = &quot;The filtered level with 90% confidence intervals, and the observed data points&quot; ) lines(1871:1970, fit$filtered$level, type = &#39;l&#39;) lines(1871:1970, fit$filtered$level + qnorm(0.95) * sqrt(fit$filtered$P[1,1,]), type = &#39;l&#39;, col = &#39;gray&#39; ) lines(1871:1970, fit$filtered$level - qnorm(0.95) * sqrt(fit$filtered$P[1,1,]), type = &#39;l&#39;, col = &#39;gray&#39; ) 平滑化されたレベル plot(1871:1970, fit$function_call$y, type = &#39;p&#39;, ylim = c(500, 1400), xlab = NA, ylab = NA, sub = &quot;The smoothed level with 90% confidence intervals, and the observed data points&quot;) lines(1871:1970, fit$smoothed$level, type = &#39;l&#39;) lines(1871:1970, fit$smoothed$level + qnorm(0.95) * sqrt(fit$smoothed$V[1,1,]), type = &#39;l&#39;, col = &#39;gray&#39;) lines(1871:1970, fit$smoothed$level - qnorm(0.95) * sqrt(fit$smoothed$V[1,1,]), type = &#39;l&#39;, col = &#39;gray&#39;) statespacer()によって返されるオブジェクトには, 他にも多くの便利なアイテム有り. これらの詳細については、vignette(“dictionary”, “statespacer”)を参照. statespacerパッケージの詳細については, https://DylanB95.github.io/statespacer/ の他のチュートリアルを参照するか, browseVignettes(“statespacer”)を参照せよ. 参考文献 Durbin, James, and Siem Jan Koopman. 2012. Time Series Analysis by State Space Methods. Oxford university press. 季節性への対応・説明変数の追加・従属変数が複数ある場合への対応 出所: statespacer applied to UK Road Deaths データセット: 英国自動車交通事故者数 (UK Road Deaths). 1969年1月–1984年12月までの英国自動車交通事故者数に関する月次データ. - Seatbelts - DriversKilled: 死亡した自動車ドライバー - drivers: 英国における自動車運転者の死者・重傷者の月次合計 (データセットUKDriverDeathsの内容) - front: 死亡または重傷を負った前席の同乗者 - rear: 死亡または重傷の後席の同乗者 - kms: 走行距離 - PetrolPrice: ガソリン価格 - VanKilled: バン (軽貨物車) の運転者数 - law: シートベルト着用義務化 (1983年1月31日) 以降は1, それ以前は0 # Load statespacerlibrary(statespacer)# Load the dataset library(datasets) Data &lt;- Seatbelts # Data preparation # The log of &quot;drivers&quot;, &quot;front&quot;, and &quot;rear&quot; will be used as dependent variables # The log of &quot;PetrolPrice&quot; and &quot;kms&quot; will be used as explanatory variables Data[, c(&quot;drivers&quot;, &quot;front&quot;, &quot;rear&quot;, &quot;PetrolPrice&quot;, &quot;kms&quot;)] &lt;- log(Data[, c(&quot;drivers&quot;, &quot;front&quot;, &quot;rear&quot;, &quot;PetrolPrice&quot;, &quot;kms&quot;)]) 確定的水準と季節性を持つ1変量モデル # Dependent variable y &lt;- as.matrix(Data[, &quot;drivers&quot;]) # Period of the seasonal component BSM_vec &lt;- 12 # Explanatory variables # Note: Must be a list of matrices! # Each dependent gets its own matrix of explanatory variables. addvar_list &lt;- list(as.matrix(Data[, c(&quot;PetrolPrice&quot;, &quot;law&quot;)])) # Format of the variance - covariance matrix of the level component # By setting the elements of this matrix to 0, # the component becomes deterministic. format_level &lt;- matrix(0) # Format of the variance - covariance matrix of the seasonal component # Note: This format must be a list of matrices, because multiple # seasonalities can be specified! format_BSM_list &lt;- list(matrix(0)) モデル適合 # Fitting the model fit &lt;- statespacer(y = y, local_level_ind = TRUE, BSM_vec = BSM_vec, addvar_list = addvar_list, format_level = format_level, format_BSM_list = format_BSM_list, method = &quot;BFGS&quot;, initial = 0.5 * log(var(y)), verbose = TRUE) ## Parameter scaling:[1] 1 ## initial value -0.443442 ## final value -0.735372 ## converged パラメータ推定値 # The estimated variance of the observation disturbance fit$system_matrices$H$H ## [,1] ## [1,] 0.007402017 # Smoothed estimate of the coefficient of log &quot;PetrolPrice&quot; fit$smoothed$addvar_coeff[1, 1] ## [1] -0.4521301 # Smoothed estimate of the coefficient of the &quot;law&quot; dummy fit$smoothed$addvar_coeff[1, 2] ## [1] -0.1971395 # Plot the data next to the smoothed level + explanatory variables components plot(Data[, c(&quot;drivers&quot;)], type = &quot;l&quot;, ylim = c(6.95, 8.1), xlab = &quot;year&quot;, ylab = &quot;logarithm of drivers&quot;) lines(seq(tsp(Data)[1], tsp(Data)[2], 1 / tsp(Data)[3]), fit$smoothed$level + fit$smoothed$addvar, type = &#39;l&#39;, col = &quot;red&quot;) legend(1978, 8.09, c(&quot;log(drivers)&quot;, &quot;level + regression effects&quot;), lty = c(1,1), lwd=c(2.5, 2.5), col = c(&quot;black&quot;, &quot;red&quot;)) 確率的水準+確率的季節性モデル (stochastic level and seasonal model) モデルの特定および適合 # By setting the entries in the format to 1, the component becomes stochastic format_level &lt;- matrix(1) format_BSM_list &lt;- list(matrix(1)) fit &lt;- statespacer(y = y, local_level_ind = TRUE, BSM_vec = BSM_vec, addvar_list = addvar_list, format_level = format_level, format_BSM_list = format_BSM_list, method = &quot;BFGS&quot;, initial = log(var(y)), verbose = TRUE) ## Parameter scaling:[1] 1 1 1 ## initial value -0.172423 ## iter 10 value -0.893962 ## iter 20 value -0.915493 ## iter 30 value -0.915515 ## final value -0.915517 ## converged パラメータ推定値 # The estimated variance of the observation disturbance fit$system_matrices$H$H ## [,1] ## [1,] 0.003786182 # The estimated variance of the level disturbance fit$system_matrices$Q$level ## [,1] ## [1,] 0.0002676898 # The estimated variance of the seasonal disturbance fit$system_matrices$Q$BSM12 ## [,1] ## [1,] 1.161433e-06 # Smoothed estimate of the coefficient of log &quot;PetrolPrice&quot; fit$smoothed$addvar_coeff[1, 1] ## [1] -0.2913941 # Smoothed estimate of the coefficient of the &quot;law&quot; dummy fit$smoothed$addvar_coeff[1, 2] ## [1] -0.2377374 # Plot the data next to the smoothed level + explanatory variables components plot(Data[, c(&quot;drivers&quot;)], type = &quot;l&quot;, ylim = c(6.95, 8.1), xlab = &quot;year&quot;, ylab = &quot;logarithm of drivers&quot;) lines(seq(tsp(Data)[1], tsp(Data)[2], 1 / tsp(Data)[3]), fit$smoothed$level + fit$smoothed$addvar, type = &#39;l&#39;, col = &quot;red&quot;) legend(1978, 8.09, c(&quot;log(drivers)&quot;, &quot;level + regression effects&quot;), lty = c(1,1), lwd=c(2.5, 2.5), col = c(&quot;black&quot;, &quot;red&quot;)) 確率的季節性は, 時間と共にほとんど変化せず. 季節成分を確定的に, レベルのみを確率論的に設定する価値あり? (AICを比較し, どちらがベターか確認せよ). # Plot the stochastic seasonal plot(seq(tsp(Data)[1], tsp(Data)[2], 1 / tsp(Data)[3]), fit$smoothed$BSM12, type = &quot;l&quot;, ylim = c(-0.2, 0.3), xlab = &quot;year&quot;, ylab = &quot;stochastic seasonal&quot;) abline(h = 0) 非規則性成分 plot(seq(tsp(Data)[1], tsp(Data)[2], 1/tsp(Data)[3]), fit$smoothed$epsilon, type = &quot;l&quot;, ylim = c(-0.15, 0.15), xlab = &quot;year&quot;, ylab = &quot;irregular component&quot;) abline(h = 0) 前部座席・後部座席の同乗者の2変量モデル # Dependent variable y &lt;- as.matrix(Data[, c(&quot;front&quot;, &quot;rear&quot;)]) # Explanatory variables # Note: Must be a list of matrices! # Each dependent gets its own matrix of explanatory variables. X &lt;- as.matrix(Data[, c(&quot;PetrolPrice&quot;, &quot;kms&quot;, &quot;law&quot;)]) addvar_list &lt;- list(X, X) # Format of the variance - covariance matrix of the level component # Note: Only the lower triangular part of the format is used. # The format specifies which elements in the matrices L and D should be # non-zero, where L and D are the matrices of the Cholesky LDL decomposition. # The diagonal is used to specify which elements of the Diagonal matrix # should be non-zero. The lower triangular part excluding the diagonal # specifies which elements in the Loading matrix should be non-zero. format_level &lt;- matrix(1, 2, 2) # Format of the variance - covariance matrix of the seasonal component # Note: This format must be a list of matrices, because multiple seasonalities # can be specified! format_BSM_list &lt;- list(matrix(0, 2, 2)) # Format of the variance - covariance matrix of the observation disturbances H_format &lt;- matrix(1, 2, 2) モデル適合 # Fitting the model fit &lt;- statespacer(y = y, H_format = H_format, local_level_ind = TRUE, BSM_vec = BSM_vec, addvar_list = addvar_list, format_level = format_level, format_BSM_list = format_BSM_list, method = &quot;BFGS&quot;, initial = 0.5 * log(diag(var(y))), verbose = TRUE) ## Parameter scaling:[1] 1 1 1 1 1 1 ## initial value 0.389588 ## iter 10 value -1.583531 ## iter 20 value -1.676130 ## iter 30 value -1.676530 ## final value -1.676537 ## converged (実行時間が多少かかる.) 推定結果 # The estimated variance - covariance matrix of the observation disturbance fit$system_matrices$H$H ## [,1] [,2] ## [1,] 0.005402169 0.004449533 ## [2,] 0.004449533 0.008566858 # The estimated variance - covariance matrix of the level disturbance fit$system_matrices$Q$level ## [,1] [,2] ## [1,] 0.0002556381 0.0002247037 ## [2,] 0.0002247037 0.0002319556 # Coefficients + T-stats coeff &lt;- cbind( c(&quot;front PetrolPrice&quot;, &quot;front kms&quot;, &quot;front law&quot;, &quot;rear PetrolPrice&quot;, &quot;rear kms&quot;, &quot;rear law&quot;), fit$smoothed$addvar_coeff[1,], fit$smoothed$addvar_coeff[1,] / fit$smoothed$addvar_coeff_se[1,]) colnames(coeff) &lt;- c(&quot;Variable&quot;, &quot;Coefficient&quot;, &quot;T-Stat&quot;) coeff ## Variable Coefficient T-Stat ## [1,] &quot;front PetrolPrice&quot; &quot;-0.30761498952755&quot; &quot;-2.898564300443&quot; ## [2,] &quot;front kms&quot; &quot;0.151804487016903&quot; &quot;1.16776317642797&quot; ## [3,] &quot;front law&quot; &quot;-0.337045864410277&quot; &quot;-6.84659677395525&quot; ## [4,] &quot;rear PetrolPrice&quot; &quot;-0.0857573081006879&quot; &quot;-0.763930782505291&quot; ## [5,] &quot;rear kms&quot; &quot;0.550388846597698&quot; &quot;3.79267978722466&quot; ## [6,] &quot;rear law&quot; &quot;0.000887654967915423&quot; &quot;0.0171338265272815&quot; 前部座席に関する水準のプロット # plot of level for &quot;front&quot; plot(seq(tsp(Data)[1], tsp(Data)[2], 1/tsp(Data)[3]), fit$smoothed$level[, 1], type = &quot;l&quot;, xlab = &quot;year&quot;, ylab = &quot;level of front passengers&quot;) 後部座席に関する水準のプロット # plot of level for &quot;rear&quot; plot(seq(tsp(Data)[1], tsp(Data)[2], 1/tsp(Data)[3]), fit$smoothed$level[, 2], type = &quot;l&quot;, xlab = &quot;year&quot;, ylab = &quot;level of rear passengers&quot;) 二つの水準の動きは似ており, 相関関係は1に近い. fit$system_matrices$Q_correlation_matrix$level ## [,1] [,2] ## [1,] 1.0000000 0.9227734 ## [2,] 0.9227734 1.0000000 format_levelを以下のように設定することで, レベル成分の分散-共分散行列のランクを1に制限を加えることも可能: format_level &lt;- matrix(0, 2, 2) format_level[, 1] &lt;- 1 この新しいモデル・スペシフィケーションにてモデルを推定してみるとどうなるか. なお, “rear”同乗者については”law”ダミーを削除し, “front”同乗者についてはダミーを残すと良いかもしれない. 参考文献 Commandeur, Jacques JF, and Siem Jan Koopman. 2007. An Introduction to State Space Time Series Analysis. Oxford University Press. 14.3 パッケージbssm 出所: (Package ‘bssm’)[https://cran.r-project.org/web/packages/bssm/bssm.pdf] (bssm: Bayesian Inference of Non-linear and Non-Gaussian State Space Models in R)[https://cran.r-project.org/web/packages/bssm/vignettes/bssm.html] パッケージbssmについて: Bayesian Inference of Non-Linear and Non-Gaussian State Space Models (非線形・非ガウス状態空間モデルのベイズ推論) 非ガウス and/or 非 線形の観測方程式と状態方程式を持つ一般的な状態空間モデルのベイズ推論を行う 外生共変量を含む基本構造時系列モデル(BSM) (Harvey 1989), 単純な確率ボラティリティ・モデル, 離散化拡散過程モデルなどの一般的な時系列モデルに対して, ベイジアンの設定における予測その他の推論を簡単かつ効率的に実行 具体的には, bssmパッケージでは, 次のモデルを仮定することができる: 指数分布族状態空間モデル (状態方程式は線形ガウス. 条件付き観測分布の密度関数は, 正規, ポアソン, 二項, 負の二項, ガンマ分布) 基本的な確率ボラティリティ・モデル ガウスノイズ項を持つ一般的な非線形モデル 連続確率微分方程式のダイナミクスを持つモデル パッケージ内で, モデルを構築するための各種関数が用意されている: bsm_lg: 基本的な一変量構造時系列モデル(BSM) ar1: ノイズ付きの1変量AR(1)過程 ssm_ulg/ssm_mlg: 一変量/多変量観測値を持つ任意の線形ガウスモデル これらの非ガウス版として, 関数 bsm_ng, ar1_ng, ssm_ung/ssm_mng 等. install.packages(&quot;bssm&quot;) # Load bssm library(bssm) local levelモデル ナイル川データセットNileに対して, local levelモデルを適合. 関数bsm_lg(): Basic Structural (Time Series) Model - local level, またはlocal trend成分および季節性成分を持つ基本構造時系列モデル (Basic Structural Time Series Model) を構築する. - usage: bsm_lg(y, sd_y, sd_level, sd_slope, sd_seasonal, beta, xreg = NULL, period, a1 = NULL, P1 = NULL, D = NULL, C = NULL) - 引数 - y: 観測値のvector, またはtsオブジェクト - sd_y: 観測方程式のノイズの標準偏差 - sd_level: レベル方程式のノイズの標準偏差 - sd_slope: 勾配方程式のノイズの標準偏差 - sd_seasonal： 季節性方程式のノイズの標準偏差 - beta: 回帰係数の事前分布 - xreg: yの長さと同一の行数を持つ共変量行列 - period: 季節性パターンの長さ (2&lt;period&lt;入力時系列の長さ). デフォルトは frequency(y). - a1: 初期状態（水準, 勾配, 季節性）の事前平均. デフォルトは0 - P1: 初期状態（水準, 勾配, 季節性）の事前共分散行列. 対角成分に100が並ぶ対角行列 - D: 観測方程式の切片項. 時変切片の場合はスカラー - C: 状態方程式の切片項. m x n, または, m x 1の行列として与えられる． # Create a local level model (latent random walk + noise) to the Nile # dataset using the bsm_lg function: model &lt;- bsm_lg(Nile, sd_y = tnormal(init = 100, mean = 100, sd = 100, min = 0), sd_level = tnormal(init = 50, mean = 50, sd = 100, min = 0), a1 = 1000, P1 = 500^2) - tnormal: truncated normal distribution (切断正規分布) - init: パラメータ初期値. モデル成分を初期化し, MCMCの初期値として使用 - min: truncated normal priorの下限値 - max: truncated normal priorの上限値 - sd: truncateする前の正規分布の標準偏差 - mean: 正規priorの平均. 関数run_mcmc(): Bayesian Inference of State Space Models - Vihola(2012)によるRobust Adaptive Metropolisアルゴリズムを用いたSSMのためのAdaptive MCMCシミュレーション. いくつかの異なるMCMCサンプリングスキームを実装. - 主な引数 (詳しくはマニュアルを参照) - model: bssm_modelクラスのモデル - iter: MCMC繰り返し計算の回数 - output_type: &quot;full&quot;(デフォルト. 事後分布からの事後サンプルを返す), &quot;theta&quot; (未知パラメータthetaの周辺事後分布から), &quot;summary&quot; (状態とthetaの事後サンプルの平均と分散推定値を返す) ... - 線形ガウスモデルの場合, オプション &quot;summary&quot;は、状態を直接シミュレーションするのではなく、高速カルマン平滑化を使って状態の事後平均と事後分散を計算 # the priors for the unknown paramters sd_y and sd_level were defined # as trunctated normal distributions, see ?bssm_prior for details # Run the MCMC for 2000 iterations (notice the small number of iterations to # comply with the CRAN&#39;s check requirements) fit &lt;- run_mcmc(model, iter = 2000) # Some diagnostics checks: check_diagnostics(fit) ## ## Acceptance rate after the burn-in period: 0.234 ## ## Run time (wall-clock): ## 0.03 seconds. ## ## Smallest bulk-ESS: 68 (level[90]) ## Smallest tail-ESS: 22 (level[91]) ## Largest Rhat: 1.045 (level[58]) # print some summary information: fit ## ## Call: ## run_mcmc.lineargaussian(model = model, iter = 2000) ## ## Iterations = 1001:2000 ## Thinning interval = 1 ## Length of the final jump chain = 235 ## ## Acceptance rate after the burn-in period: 0.234 ## ## Summary for theta: ## ## variable Mean SE SD 2.5% 97.5% ESS ## sd_level 44.36092 1.795784 16.97667 17.43660 77.52529 89 ## sd_y 122.13758 1.114178 12.71891 98.71335 145.00349 130 ## ## Summary for alpha_101: ## ## variable time Mean SE SD 2.5% 97.5% ESS ## level 1971 775.6908 7.828845 84.59991 613.8982 926.1021 117 ## ## Run time: ## user system elapsed ## 0.030 0.001 0.030 # traceplots: plot(fit) # extract the summary statistics for state variable sumr &lt;- summary(fit, variable = &quot;states&quot;) # visualize library(&quot;ggplot2&quot;) ggplot(sumr, aes(time, Mean)) + geom_ribbon(aes(ymin = `2.5%`, ymax = `97.5%`),alpha = 0.25) + geom_line() + theme_bw() 確率的季節性成分を持つドリフト有りランダムウォーク・モデル データセット: UKgas - UKgas: - 英国の四半期ガス消費量 - 1960年第1四半期--1986年第4四半期 (単位：百万トルム) UKgas ## Qtr1 Qtr2 Qtr3 Qtr4 ## 1960 160.1 129.7 84.8 120.1 ## 1961 160.1 124.9 84.8 116.9 ## 1962 169.7 140.9 89.7 123.3 ## 1963 187.3 144.1 92.9 120.1 ## 1964 176.1 147.3 89.7 123.3 ## 1965 185.7 155.3 99.3 131.3 ## 1966 200.1 161.7 102.5 136.1 ## 1967 204.9 176.1 112.1 140.9 ## 1968 227.3 195.3 115.3 142.5 ## 1969 244.9 214.5 118.5 153.7 ## 1970 244.9 216.1 188.9 142.5 ## 1971 301.0 196.9 136.1 267.3 ## 1972 317.0 230.5 152.1 336.2 ## 1973 371.4 240.1 158.5 355.4 ## 1974 449.9 286.6 179.3 403.4 ## 1975 491.5 321.8 177.7 409.8 ## 1976 593.9 329.8 176.1 483.5 ## 1977 584.3 395.4 187.3 485.1 ## 1978 669.2 421.0 216.1 509.1 ## 1979 827.7 467.5 209.7 542.7 ## 1980 840.5 414.6 217.7 670.8 ## 1981 848.5 437.0 209.7 701.2 ## 1982 925.3 443.4 214.5 683.6 ## 1983 917.3 515.5 224.1 694.8 ## 1984 989.4 477.1 233.7 730.0 ## 1985 1087.0 534.7 281.8 787.6 ## 1986 1163.9 613.1 347.4 782.8 prior &lt;- halfnormal(0.1, 1) UKgas_model &lt;- bsm_lg(log10(UKgas), sd_y = prior, sd_level = prior, sd_slope = prior, sd_seasonal = prior) mcmc_bsm &lt;- run_mcmc(UKgas_model, iter = 4e4, seed = 1) mcmc_bsm ## ## Call: ## run_mcmc.lineargaussian(model = UKgas_model, iter = 40000, seed = 1) ## ## Iterations = 20001:40000 ## Thinning interval = 1 ## Length of the final jump chain = 4666 ## ## Acceptance rate after the burn-in period: 0.233 ## ## Summary for theta: ## ## variable Mean SE SD 2.5% 97.5% ESS ## sd_level 0.005003611 1.755466e-04 0.003289163 0.0001617486 0.012013391 351 ## sd_seasonal 0.026093324 1.219744e-04 0.003684879 0.0189052091 0.033431632 913 ## sd_slope 0.001200382 2.345435e-05 0.000523736 0.0002079971 0.002309162 499 ## sd_y 0.016314018 2.894970e-04 0.005538082 0.0043639303 0.026345063 366 ## ## Summary for alpha_109: ## ## variable time Mean SE SD 2.5% 97.5% ## level 1987 2.84506115 3.656806e-04 0.01700774 2.811472331 2.87822366 ## seasonal_1 1987 0.26737674 7.132008e-04 0.03544500 0.194987187 0.33908649 ## seasonal_2 1987 0.06192612 4.155558e-04 0.01797639 0.028077857 0.09923766 ## seasonal_3 1987 -0.29493927 3.003881e-04 0.01559836 -0.326940852 -0.26553733 ## slope 1987 0.00974463 8.195493e-05 0.00395237 0.002323525 0.01816920 ## ESS ## 2163 ## 2470 ## 1871 ## 2696 ## 2326 ## ## Run time: ## user system elapsed ## 5.778 0.016 5.810 suppressMessages(library(&quot;ggplot2&quot;)) d &lt;- as.data.frame(mcmc_bsm, variable = &quot;theta&quot;) ggplot(d, aes(x = value)) + geom_density(adjust = 3, fill = &quot;#92f0a8&quot;) + facet_wrap(~ variable, scales = &quot;free&quot;) + theme_bw() suppressMessages(library(&quot;dplyr&quot;)) d &lt;- as.data.frame(mcmc_bsm, variable = &quot;states&quot;) level_fit &lt;- d |&gt; filter(variable == &quot;level&quot;) |&gt; group_by(time) |&gt; summarise(consumption = mean(value), lwr = quantile(value, 0.025), upr = quantile(value, 0.975)) ggplot(level_fit, aes(x = time, y = consumption)) + geom_ribbon(aes(ymin = lwr, ymax = upr), fill = &quot;#92f0a8&quot;, alpha = 0.25) + geom_line(colour = &quot;#92f0a8&quot;) + geom_line(data = data.frame( consumption = log10(UKgas), time = time(UKgas)), colour = &quot;grey30&quot;, linetype = &quot;dashed&quot;) + theme_bw() 参考文献 Helske, Jouni, and Matti Vihola. 2021. “Bssm: Bayesian Inference of Non-Linear and Non-Gaussian State Space Models in R.” R Journal. https://arxiv.org/abs/2101.08492. "],["バブル-生成崩壊-検出.html", "A バブル (生成・崩壊) 検出 A.1 検定法に関する最近のレビュー論文 A.2 Supreme ADF検定/SADF (PWY, 2011), Generalized supreme ADF 検定/GSADF (PSY, 2015) A.3 実証分析", " A バブル (生成・崩壊) 検出 2023年11月17日 論文多数. 一部の紹介. A.1 検定法に関する最近のレビュー論文 Skrobotov, A.(2021). Testing for Explosive Bubbles: A Review, preprint. https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3779111 A.2 Supreme ADF検定/SADF (PWY, 2011), Generalized supreme ADF 検定/GSADF (PSY, 2015) Phillips, P.C.B., Wu, Y., Yu, J. (2011). Explosive behavior in the 1990s Nasdaq: when did exuber- ance escalate asset values? Int. Econ. Rev. 52 (1), 201–226. Phillips, P. C. B., Shi, S., &amp; Yu, J. (2015a). Testing for multiple bubbles: Historical episodes of exuberance and collapse in the S&amp;P 500. International Economic Review, 56(4), 1034–1078. Phillips, P. C. B., Shi, S., &amp; Yu, J. (2015b). Testing for multiple bubbles: Limit Theory for Real- Time Detectors. International Economic Review, 56(4), 1079–1134. Phillips, P. C. B., &amp; Shi, S.(2020) Real time monitoring of asset markets: Bubbles and crisis. In Hrishikesh D. Vinod and C.R. Rao (Eds.), Handbook of Statistics Volume 41 - Econometrics Using R. Rパッケージ psymonitor: https://cran.r-project.org/web/packages/psymonitor/psymonitor.pdf MultiBubbles: https://cran.r-project.org/web/packages/MultipleBubbles/MultipleBubbles.pdf exuber: https://www.dallasfed.org/~/media/documents/institute/wpapers/2020/0383.pdf https://cran.rstudio.com/web/packages/exuber/vignettes/exuber.html A.2.1 数理ファイナンス (Jarrow, Protterら) Jarrow, R., Protter P., and Shimbo, K. (2007), Asset price bubbles in complete markets, in Advances in Mathematical Finance, Birkha ̈user Boston, Cambridge, MA, 97–121. Jarrow, R., Protter P., and Shimbo, K. (2010). Asset price bubbles in incomplete markets, Math. Finance, 20, 145–185. Jarrow, R., Kchia, Y., and Protter, P. (2011). How to Detect an Asset Bubble, SIAM Journal on Financial Mathematics, 2-1, 839-865. Protter P. (2013) A Mathematical Theory of Financial Bubbles. In: Paris-Princeton Lectures on Mathematical Finance 2013. Lecture Notes in Mathematics, vol 2081. Springer, Cham. https://doi.org/10.1007/978-3-319-00413-6_1 A.2.2 経済物理学 (Sornetteら) Johansen, A., Ledoit, O., Sornette, D. (2000). Crashes as critical points, International Journal of Theoretical and Applied Finance 3, 219–255. https://arxiv.org/pdf/cond-mat/9810071.pdf Sornette, D., Woodard, R., Yan, W., and Zhou, W.X. (2013). Clarifications to Questions and Criticisms on the Johansen-Ledoit-Sornette Financial Bubble Model, Physica A, 392-19, Pages 4417-4428. https://arxiv.org/pdf/1107.3171.pdf Sornette, D. (2017) Why Stock Markets Crash: Critical Events in Complex Financial Systems, Revised ed., Princeton Science Library. ISBN-10: 0691175950 A.3 実証分析 株式市場の例 Breitung, J. and Kruse, R. (2013) ‘When bubbles burst: econometric tests based on structural breaks’, Statistical Papers, 54(4), pp. 911–930. Available at: https://doi.org/10.1007/s00362-012-0497-3. Monschang, V. and Wilfling, B. (2021) ‘Sup-ADF-style bubble-detection methods under test’, Empirical Economics, 61(1), pp. 145–172. Available at: https://doi.org/10.1007/s00181-020-01859-7. Shi, S. and Song, Y. (2014) ‘Identifying Speculative Bubbles Using an Infinite Hidden Markov Model’, Journal of Financial Econometrics, p. nbu025. Available at: https://doi.org/10.1093/jjfinec/nbu025. 暗号資産市場の例 Cross, J.L., Hou, C. and Trinh, K. (2021) ‘Returns, volatility and the cryptocurrency bubble of 2017–18’, Economic Modelling, 104, p. 105643. Available at: https://doi.org/10.1016/j.econmod.2021.105643. Yao, C.-Z. and Li, H.-Y. (2021) ‘A study on the bursting point of Bitcoin based on the BSADF and LPPLS methods’, The North American Journal of Economics and Finance, 55, p. 101280. Available at: https://doi.org/10.1016/j.najef.2020.101280. "],["長期記憶過程-1.html", "B 長期記憶過程 B.1 理論・概説 B.2 株式市場 B.3 外国為替市場 B.4 コモディティ・暗号資産 B.5 VIX B.6 高頻度データ (ボラティリティ, 注文フロー等) B.7 長期記憶性の発生要因, 非長期記憶モデルによる近似", " B 長期記憶過程 2023年11月17日 ダウンロード可能なものを中心に紹介します (ワーキングペーパー含む). 文献多数あり, 重要なものをカバーしている訳ではありません. ここにないものについては, 電子ジャーナル等を通じて適宜入手してください B.1 理論・概説 Gennady Samorodnitsky (2006). Long Range Dependence. Foundations and Trends in Stochastic Systems, 1(3), 163–257. https://people.orie.cornell.edu/gennady/techreports/LRD-NOW.pdf https://pdfs.semanticscholar.org/f182/3f5bcc8524d73af14ba3e29e7bbdcc50545e.pdf Rama Cont (2005). Long range dependence in financial markets, In: Lévy-Véhel J., Lutton E. (eds) Fractals in Engineering. Springer, London. https://doi.org/10.1007/1-84628-048-6_11 https://www.researchgate.net/publication/226697823_Long_range_dependence_in_financial_market Thomas Mikosch and Ca ̆ta ̆lin Sta ̆rica ̆ (2004). Nonstationarities in Financial Time Series, the Long-range Dependence, and the IGARCH Effects. The Review of Economics and Statistics, 86(1), 378–390. https://gec.cr.usgs.gov/outgoing/threshold_articles/Mikosch_Starica2004.pdf Richard T. Baillie (1996). Long memory processes and fractional integration in econometrics, Journal of Econometrics, 73, 5-59. http://long-memory.com/Baillie1996.pdf B.2 株式市場 Andrew W. Lo (1991). Long term memory in stock market prices, Econometrica 59 1279–313. https://www.nber.org/system/files/working_papers/w2984/w2984.pdf Walter Willinger, Murad S. Taqqu, Vadim Teverovsky (1999). Stock market prices and long-range dependence, Finance &amp; Stochastics, 3, 1–13. http://www.long-memory.com/returns/WillingerTaqquTeverovsky1999.pdf B.3 外国為替市場 Yin-Wong Cheung (1993). Long Memory in Foreign-Exchange Rates, Journal of Business &amp; Economic Statistics, 11(1), 93-101, DOI: 10.1080/07350015.1993.10509935. https://people.ucsc.edu/~cheung/JBES/LongMemoryFX_JBES1993.pdf Richard T. Baillie and Tim Bollerslev(1994). The long memory of the forward premium, Journal of International Money and Finance, 13(5), 565-571. https://dukespace.lib.duke.edu/dspace/bitstream/handle/10161/1965/Bollerslev_the_long_memory.pdf?sequence=1 Dominique M. Guillaume, Michel M. Dacorogna, Rakhal R. Davé, Ulrich A. Müller, Richard B. Olsen &amp; Olivier V. Pictet (1997). From the bird’s eye to the microscope: A survey of new stylized facts of the intra-daily foreign exchange markets. Finance and Stochastics, 1, pages95–129. https://link.springer.com/article/10.1007%2Fs007800050018 B.4 コモディティ・暗号資産 Mohamed El Hedi Arouri, Shawkat Hammoudeh, Amine Lahiani, Duc Khuong Nguyen(2012). Long memory and structural breaks in modeling the return and volatility dynamics of precious metals, The Quarterly Review of Economics and Finance, 52-2, 207-218. https://hal.archives-ouvertes.fr/file/index/docid/798033/filename/Arouri_et_al_QREF_R3-1.pdf Guglielmo Maria Caporale, Luis Gil-Alana, Alex Plastun (2018), Persistence in the cryptocurrency market, Research in International Business and Finance, 46, pp. 141-148. https://www.sciencedirect.com/science/article/pii/S0275531917309200 B.5 VIX Guglielmo Maria Caporale, Luis Gil-Alana, Alex Plastun (2018). Is market fear persistent? A long-memory analysis. Finance Research Letters, 27, 140-147. https://doi.org/10.1016/j.frl.2018.02.007. https://www.sciencedirect.com/science/article/pii/S1544612317303793 B.6 高頻度データ (ボラティリティ, 注文フロー等) Lillo, F. and Farmer, J. D. (2004). The Long Memory of the Efficient Market, Studies in Nonlinear Dynamics &amp; Econometrics, 8(3). doi: https://doi.org/10.2202/1558-3708.1226 https://arxiv.org/pdf/cond-mat/0311053 Torben G Andersen and Tim Bollerslev (1997), Heterogeneous Information Arrivals and Return Volatility Dynamics: Uncovering the Long‐Run in High Frequency Returns. The Journal of Finance, 52, 975-1005. https://doi.org/10.1111/j.1540-6261.1997.tb02722.x https://www.nber.org/system/files/working_papers/w5752/w5752.pdf Torben G Andersen, Tim Bollerslev, Francis X Diebold &amp; Paul Labys (2001). The Distribution of Realized Exchange Rate Volatility, Journal of the American Statistical Association, 96, 42-55. https://www.nber.org/system/files/working_papers/w6961/w6961.pdf B.7 長期記憶性の発生要因, 非長期記憶モデルによる近似 Chevillon, G. and Mavroeidis, S. (2018) ‘Perpetual learning and apparent long memory’, Journal of Economic Dynamics and Control, 90, pp. 343–365. Available at: https://doi.org/10.1016/j.jedc.2018.03.012. Corsi, F. (2004) ‘A Simple Long Memory Model of Realized Volatility’, SSRN Electronic Journal [Preprint]. Available at: https://doi.org/10.2139/ssrn.626064. Corsi, F., Audrino, F. and Renò, R. (2012) ‘HAR Modeling for Realized Volatility Forecasting’, in L. Bauwens, C. Hafner, and S. Laurent (eds) Handbook of Volatility Models and Their Applications. 1st edn. Wiley, pp. 363–382. Available at: https://doi.org/10.1002/9781118272039.ch15. Granger, C.W.J. (1980) ‘LONG MEMORY RELATIONSHIPS AND THE AGGREGATION OF DYNAMIC MODELS’, Journal of Econometrics, 14(2), pp. 227–238. Available at: https://www.sciencedirect.com/science/article/pii/0304407680900925. Granger, C.W.J. and Hyung, N. (2004) ‘Occasional structural breaks and long memory with an application to the S&amp;P 500 absolute stock returns’, Journal of Empirical Finance, 11(3), pp. 399–421. Available at: https://doi.org/10.1016/j.jempfin.2003.03.001. "],["markov-switching-regime-switchingモデル.html", "C Markov switching/ regime switchingモデル C.1 理論・概説 C.2 株式市場 C.3 金利・債券市場 C.4 外国為替市場 C.5 アセット・アロケーション", " C Markov switching/ regime switchingモデル 2023年11月30日 論文多数につき, ごく一部のみ紹介. ダウンロード可能なもの中心に紹介 (ワーキングペーパー含む) C.1 理論・概説 Hamilton, J. D. (1989). A New Approach to the Economic Analysis of Nonstationary Time Series and the Business Cycle. Econometrica, 57, 357–384. https://www.ssc.wisc.edu/~bhansen/718/Hamilton1989.pdf Hamilton J.D. (2008) Regime Switching Models. In: Durlauf S.N., Blume L.E. (eds) The New Palgrave Dictionary of Economics. Palgrave Macmillan, London. https://doi.org/10.1007/978-1-349-58802-2_1408 https://econweb.ucsd.edu/~jhamilto/palgrav1.pdf Timmermann, Allan (2000). Moments of Markov switching models, Journal of Econometrics, 96(1), 75-111. https://ideas.repec.org/a/eee/econom/v96y2000i1p75-111.html C.2 株式市場 Lunde, A. and Timmermann, A. (2004). Duration dependence in stock prices: An analysis of bull and bear markets. Journal of Business &amp; Economic Statistics, 22(3), 253–273. https://www.tandfonline.com/doi/pdf/10.1198/073500104000000136?casa_token=rx5Tgip1JfUAAAAA:VVHIVFY86vzPzWi-05QLaeEa3Inkb8Wo70zQI9OQaiUCAtbkj57H3r3b2uSftk9sUq6nADGUjRY54wg Maheu, J. M. and McCurdy, T. H. (2000). Identifying bull and bear markets in stock returns. Journal of Business &amp; Economic Statistics, 18(1), 100–112. https://www.tandfonline.com/doi/abs/10.1080/07350015.2000.10524851#aHR0cHM6Ly93d3cudGFuZGZvbmxpbmUuY29tL2RvaS9wZGYvMTAuMTA4MC8wNzM1MDAxNS4yMDAwLjEwNTI0ODUxP25lZWRBY2Nlc3M9dHJ1ZUBAQDA= C.3 金利・債券市場 Ang, A. and Bekaert, G. (2002). Regime switches in interest rates. Journal of Business and Economic Statistics 20, 163–82. https://www.nber.org/system/files/working_papers/w6508/w6508.pdf Dai, Qiang, Singleton, Kenneth J. and Yang, Wei (2007). Regime Shifts in a Dynamic Term Structure Model of U.S. Treasury Bond Yields. The Review of Financial Studies, 20(5), 1669-1706. https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.409.8573&amp;rep=rep1&amp;type=pdf C.4 外国為替市場 Dueker, Michael and Neely, Christopher J. (2007). Can Markov Switching Models Predict Excess Foreign Exchange Returns? Journal of banking &amp; finance, 31(2), 279-296. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.197.9927&amp;rep=rep1&amp;type=pdf Cheung, Yin-Wong and Erlandsson, Ulf G. (2005). Exchange Rates and Markov Switching Dynamics, Journal of Business &amp; Economic Statistics, 23(3), 314-320. https://papers.ssrn.com/sol3/papers.cfm?abstract_id=637163 C.5 アセット・アロケーション Ang, A. and Bekaert, G. (2002). International asset allocation with regime shifts. Review of Financial Studies, 15(4), 1137–1187. https://pdfs.semanticscholar.org/2521/155069503babc51b65fae22ee7281674ea4a.pdf Guidolin, M. and Timmermann, A. (2007). Asset allocation under multivariate regime switching. Journal of Economics Dynamics &amp; Control, 31(11), 3503–3544. https://papers.ssrn.com/sol3/papers.cfm?abstract_id=940652 "],["archgarchモデル.html", "D ARCH/GARCHモデル D.1 概説 D.2 ARCH model D.3 GARCH model D.4 ARCH-M Model D.5 GJR model D.6 APARCH model", " D ARCH/GARCHモデル 2023年12月9日 論文多数. ダウンロード可能なものごく一部の紹介. D.1 概説 Tim Bollerslev, Ray Y. Chou and Kenneth F. Kroner (1992). “ARCH modeling in finance: A review of the theory and empirical evidence”, Journal of Econometrics, 52, 1–2, 5-59. http://www-stat.wharton.upenn.edu/~steele/Courses/434/434Context/GARCH/BollerslevReview.pdf Tim Bollerslev, Robert F. Engle, Danile B. Nelson(1994). “ARCH models”, in Handbook of Econometrics, Volume IV (Edited by R.F. Engle and D.L. McFadden). https://d1wqtxts1xzle7.cloudfront.net/43834885/arch-with-cover-page-v2.pdf?Expires=1639120389&amp;Signature=ImncR825Ozi~78eBe4x-ZZPU0pp9cebOmIEaGK06oLukIeZ8uviF3xhkW1~4SJkc4GWLQMrcFR1~C-Uc218lxMhj1bgt8lFtaVOhuvDPuXyUEkf~WpC4zFmFnC3Re20YzFmx7CQEOPbmCmPWiwOcO4SZvw~CwebW4Q2f~2eRj7xKzVYJn-59E66cuk3chFx3xCeH47QVZwd959Nq55ncW4CA7CsTi2CHCNCZesdznpZBsC4xd-F-GaKHuFN9O7O2qDataXJkvPhRqYMJV2SwHcBGfYp3ASXXwDNgsmKl7PJD7XwMQ9Aqj2H61rXo12lg6-dH4-r7mFdGGS~G~BE5tw__&amp;Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA Robert Engle(2003). “Risk and Volatility: Econometric Models and Financial Practice”, Nobel Lecture, December 8, 2003. https://www.nobelprize.org/uploads/2018/06/engle-lecture.pdf https://www.nobelprize.org/prizes/economic-sciences/2003/engle/lecture/ D.2 ARCH model Robert F. Engle (1982). “Autoregressive Conditional Heteroskedasticity with Estimates of the Variance of U.K. Inflation”, Econometrica, 50, 987-1008. http://www.econ.uiuc.edu/~econ508/Papers/engle82.pdf D.3 GARCH model Tim Bollerslev (1986). “Generalized Autoregressive Conditional Heteroskedasticity”, Journal of Eco- nometrics, 31, 307 327. http://public.econ.duke.edu/~boller/Published_Papers/joe_86.pdf D.4 ARCH-M Model Robert Engle, David M. Lilien and Russell P. Robins (1987). “Estimating Time Varying Risk Premia in the Term Structure: The Arch-M Model”, Econometrica, 1987, 55(2), 391-407. https://econpapers.repec.org/article/ecmemetrp/v_3a55_3ay_3a1987_3ai_3a2_3ap_3a391-407.htm D.5 GJR model Lawrence R. Glosten, Ravi Jagannathan and David E. Runkle(1993). “On the Relation between the Expected Value and the Volatility of the Nominal Excess Return on Stocks”, Journal of Finance, 48(5), 1779-1801. http://finance.martinsewell.com/stylized-facts/volatility/GlostenJagannathanRunkle1993.pdf D.6 APARCH model Zhuanxin Ding, Clive W.J. Granger and Robert F. Engle(1993). “A long memory property of stock market returns and a new model”, Journal of Empirical Finance 1 (1), 83-106. https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.471.7587&amp;rep=rep1&amp;type=pdf "],["共和分-誤差修正モデル.html", "E 共和分/ 誤差修正モデル E.1 株式市場とマクロ変数, 国際株式市場間の分析 E.2 個別株式の複数取引所株価間の分析 E.3 高頻度データ (bid/ask価格) の分析 E.4 統計的アービトラージ / ペアトレード E.5 国際株式市場間のヘッジ E.6 クレジット・スプレッド (株式, CDS, 債券) の分析", " E 共和分/ 誤差修正モデル 2024年1月17日 金融/経済時系列の分析, 近年, 新興市場に関する実証研究多数. (確立された方法論, 論文書き易い) 金融市場における応用例: 統計的アービトラージ・ペア・トレード, 現物–先物裁定取引, 指数トラッキング, 信用スプレッド取引, ヘッジ取引, … E.1 株式市場とマクロ変数, 国際株式市場間の分析 Ramin Cooper Maysami, Tiong Sim Koh (2000). A vector error correction model of the Singapore stock market, International Review of Economics &amp; Finance, 9(1), 79-96. https://doi.org/10.1016/S1059-0560(99)00042-8. (https://www.sciencedirect.com/science/article/pii/S1059056099000428) E.2 個別株式の複数取引所株価間の分析 deB. Harris F.H., McInish T.H., Shoesmith G.L., Wood R.A. (1995). Cointegration, Error Correction, and Price Discovery on Informationally Linked Security Markets. Journal of Financial and Quantitative Analysis, 30(4):563-579. https//doi.org.10.2307/2331277 E.3 高頻度データ (bid/ask価格) の分析 Robert F. Engle, Andrew J. Patton (2004). Impacts of trades in an error-correction model of quote prices, Journal of Financial Markets, 7(1), 1-25. https://doi.org/10.1016/S1386-4181(03)00018-1.(https://www.sciencedirect.com/science/article/pii/S1386418103000181) https://archive.nyu.edu/bitstream/2451/26697/2/FIN-00-033.pdf E.4 統計的アービトラージ / ペアトレード Krauss, Christopher (2017). Statistical arbitrage pairs trading strategies: Review and outlook, Journal of Economic Surveys, 31(2), 513–545. https://doi.org/10.1111/joes.12153. E.5 国際株式市場間のヘッジ Alexander Carol (1999). Optimal hedging using cointegration, Phil. Trans. R. Soc. A. 3572039–2058. http://doi.org/10.1098/rsta.1999.0416 E.6 クレジット・スプレッド (株式, CDS, 債券) の分析 Santiago Forte, Juan Ignacio Peña (2009). Credit spreads: An empirical analysis on the informational content of stocks, bonds, and CDS, Journal of Banking &amp; Finance, 33(11), 2013-2025. https://doi.org/10.1016/j.jbankfin.2009.04.015. (https://www.sciencedirect.com/science/article/pii/S037842660900096X) "],["今後の学習のために.html", "F 今後の学習のために F.1 AI/機械学習と時系列解析 F.2 カテゴリーデータや整数値データ等に対する時系列解析 F.3 状態空間モデル・動的線形モデル F.4 その他", " F 今後の学習のために 2024年2月7日 今学期授業でカバー出来なかった内容や, 授業を踏まえた発展的内容に関する参考書や (ダウンロード可能な) サーベイ論文や概説論文を幾つか紹介します. 個別の論文については, これらの文献内の参考文献リストや, Google検索などで, サーチしてください. 多数見つかるはずです. なお, 学術誌に掲載された論文については, 都立大学の電子ジャーナル検索サービスを利用して入手を試みてください. F.1 AI/機械学習と時系列解析 (サーベイ) John W. Goodell, Satish Kumar, Weng Marc Lim, Debidutta Pattnaik (2021). Artificial intelligence and machine learning in finance: Identifying foundations, themes, and research clusters from bibliometric analysis, Journal of Behavioral and Experimental Finance 32, 100577. https://linkinghub.elsevier.com/retrieve/pii/S2214635021001210 (時系列予測 + 深層学習) Bryan Lim and Stefan Zohren (2020). Time Series Forecasting With Deep Learning: A Survey. *Philosophical Transactions A. https://arxiv.org/pdf/2004.13408.pdf (同) John Cristian Borges Gamboa (2017). Deep Learning for Time-Series Analysis, arXiv. https://arxiv.org/abs/1701.01887 (時系列予測+自然言語処理) Xing, Frank Z., et al. (2018). Natural Language Based Financial Forecasting: A Survey. Artificial Intelligence Review, vol. 50, no. 1, June 2018, pp. 49–73. https://dspace.mit.edu/bitstream/handle/1721.1/116314/10462_2017_9588_ReferencePDF.pdf?sequence=2&amp;isAllowed=y (GARCH + 深層学習 (LSTM)) Wing Ki Liu and Mike K.P.So (2020). A GARCH Model with Artificial Neural Networks, Information, 11, 489. https://www.mdpi.com/863510 (GAN (シミュレーター)) Lezmi, Edmond, Roche, Jules, Roncalli, Thierry, and Xu, Jiali (2020). Improving the Robustness of Trading Strategy Backtesting with Boltzmann Machines and Generative Adversarial Networks, http://arxiv.org/abs/2007.04838. (同) Magnus Wiese, Robert Knobloch, Ralf Korn, and Peter Kretschmer (2020). Quant GANs: Deep Generation of Financial Time Series, Quantitative Finance, 20(9), 1419-1440. http://arxiv.org/abs/1907.06673 (Variational Autoencoder (シミュレーター)) Hans Buehler,, Blanka Horvath, Terry Lyons, Imanol Perez Arribas, and Ben Wood (2020). A Data-driven Market Simulator for Small Data Environments. http://arxiv.org/abs/2006.14498. (高頻度データ/マイクロストラクチャ + 深層学習) Justin Sirignano and Rama Cont (2019), Universal features of price formation in financial markets: perspectives from deep learning, Quantitative Finance, 2019 Vol. 19, No. 9, 1449–1459, https://doi.org/10.1080/14697688.2019.1622295 F.2 カテゴリーデータや整数値データ等に対する時系列解析 (動的一般化線形モデル) Mike West, P. Jeff Harrison, and Helio S. Migon (1985), Dynamic Generalized Linear Models and Bayesian Forecasting, J. American Statistical Association, 80 (389). https://www2.stat.duke.edu/~mw/MWextrapubs/West1985a.pdf (整数値自己回帰モデル) 中嶋 雅彦, 酒折文武, 川崎能典 (2017). 整数値自己回帰モデルの最近の発展, 統計数理, 第 65 巻 第 2 号 323–339. https://www.ism.ac.jp/editsec/toukei/pdf/65-2-323.pdf 参考書 (一般化線形モデルの時系列モデリングへの拡張) Fahrmeir, L. and Tutz, G. (2001). Multivariate Statistical Modelling Based on Generalized Linear Models, 2nd ed., Springer-Verlag, New York. F.3 状態空間モデル・動的線形モデル 参考書 Giovanni Petris, Sonia Petrone, and Patrizia Campagnoli (2009). Dynamic Linear Models with R, Springer. (R利用ガイド) Giovanni Petris, Petrone (2011). State Space Models in R, J. Statistical Software 41(104). https://www.researchgate.net/publication/227450969_State_Space_Models_in_R (ウェブサイト) Giovanni Petris, State Space Models in R - useR! 2011 Tutorial. https://www.r-project.org/conferences/useR-2011/tutorials/Petris.html 参考書 萩原淳一郎, 瓜生真也, 牧山幸史(2018). 基礎からわかる時系列分析. 技術評論社. F.4 その他 参考書 (時系列解析全般. “バイブル”) James D. Hamilton (1994). Time Series Analysis, Princeton University Press. 参考書 (Wavelet) Ramazan Gençay, Faruk Selçuk and Brandon Whitcher (2001). An Introduction to Wavelets and Other Filtering Methods in Finance and Economics, Academic Press. 参考書 (高頻度データ分析) 林, 佐藤彰洋(2016). 金融市場の高頻度データ分析. 朝倉書店. 参考書 (パネル回帰) Jeffrey M.Wooldridge (2016). Econometric Analysis of Cross Section and Panel Data, 2nd ed., MIT Press. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
